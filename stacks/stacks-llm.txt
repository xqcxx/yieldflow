# Introduction

<div data-with-frame="true"><figure><picture><source srcset="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fx09gHeYU67yvfXLh7Iis%2Fbitcoin-stacks.png?alt=media&#x26;token=7635e08d-2495-44ed-a93c-68351882fbf3" media="(prefers-color-scheme: dark)"><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fam7BqpV0sbUexW7Zpqoh%2Fbitcoin-stacks-dark.png?alt=media&#x26;token=28aa61b3-628a-4519-a574-0b5856762626" alt=""></picture><figcaption></figcaption></figure></div>

{% hint style="info" %}
For the official Stacks whitepaper: <https://stacks-network.github.io/stacks/stacks.pdf>
{% endhint %}

### Stacks: The TL;DR

Stacks activates the Bitcoin economy. Bitcoin is the most adopted, most valuable, and most decentralized cryptocurrency. The Stacks L2 enables fast, cheap BTC and full-featured smart contracts on the L2 without modifying Bitcoin itself. Users and developers can use BTC in their apps and pay gas fees with BTC. All transactions on Stacks L2 are secured by Bitcoin L1 with 100% finality, enabling you to build apps and digital assets that are integrated
&#x20;with Bitcoin security.

The Stacks layer for smart contracts has the following innovations that make it unique:

**S**: Secured by the entire hash power of Bitcoin (Bitcoin finality).\
**T**: Trust-minimized Bitcoin peg mechanism; write to Bitcoin.\
**A**: Atomic BTC swaps and assets owned by BTC addresses.\
**C**: Clarity language for safe, decidable smart contracts.\
**K**: Knowledge of full Bitcoin state; read from Bitcoin.\
**S**: Scalable, fast transactions that settle on Bitcoin.

#### All of this is accomplished by three core components:

{% stepper %}
{% step %}

#### Proof of Transfer

Proof of Transfer (PoX) is the block production mechanism of the Stacks chain. Essentially, it attempts to recreate the block production patterns of PoW programmatically. Stacks miners spend BTC for a chance to mine new Stacks blocks. Under the hood, this block production mechanism anchors Stacks blocks to Bitcoin blocks, making it as hard to reverse a Stacks block as it is to reverse a Bitcoin block. That's a big claim, and we unpack it in further detail in the sections on Nakamoto block production.

[Learn more about PoX](https://docs.stacks.co/learn/stacks-101/proof-of-transfer)
{% endstep %}

{% step %}

#### Clarity

Clarity is the smart contract language that Stacks uses. It has been designed from the ground up to make it easier for developers to write safe, secure smart contracts. Additionally, since it has been purpose-built for Stacks and Bitcoin, there are built-in functions for reading Bitcoin state, which means you can use Bitcoin state to perform actions in Clarity. For example, you could set up a check to make sure a particular Bitcoin transaction has occurred before executing a mint function in Clarity, which just so happens to be what happens with the third component: sBTC.

[Learn more about Clarity](https://docs.stacks.co/learn/clarity)
{% endstep %}

{% step %}

#### sBTC

sBTC is the trust-minimized 2-way Bitcoin peg on the Stacks layer. sBTC is the key to making Bitcoin programmable and bringing full smart contract functionality to Bitcoin via Stacks. sBTC is not a federation, but operates as an open-network, decentralized 2-way peg solution to bring smart contract functionality to Bitcoin with as little counterparty risk as possible.

[Learn more about sBTC](https://docs.stacks.co/learn/sbtc)
{% endstep %}
{% endstepper %}

***

### Why you need to learn the fundamentals of Stacks?

Stacks fundamentals give you the intuition to build apps that are safer, more Bitcoin-aligned, and more future-proof. A developer who learns the basics doesn’t just write Clarity—they build apps that actually *feel like* Bitcoin apps.

1. You'll build apps that actually leverage Bitcoin
2. You'll avoid costly design mistakes
3. You'll write better smart contracts
4. You'll use sBTC and Bitcoin writes correctly

***

### What to learn next?

<table data-card-size="large" data-view="cards"><thead><tr><th></th><th></th><th data-hidden data-card-target data-type="content-ref"></th></tr></thead><tbody><tr><td><h4>Stacks 101</h4></td><td>Really dive into the nuts and bolts of how Stacks is built on Bitcoin.</td><td><a href="stacks-101">stacks-101</a></td></tr><tr><td><h4>Network Fundamentals</h4></td><td>Learn about accounts, testnets, SIPs, authentication, BNS, and more.</td><td><a href="network-fundamentals">network-fundamentals</a></td></tr><tr><td><h4>Block Production</h4></td><td>How do Stacks blocks get validated and mined?</td><td><a href="block-production">block-production</a></td></tr><tr><td><h4>Transactions</h4></td><td>Learn about the lifecycle of a transaction on Stacks.</td><td><a href="transactions">transactions</a></td></tr><tr><td><h4>Clarity</h4></td><td>Discover the philosophy and design principles of the Clarity smart contract language.</td><td><a href="clarity">clarity</a></td></tr><tr><td><h4>sBTC</h4></td><td>Understand how bitcoin is unwrapped into a productive and programmable asset.</td><td><a href="sbtc">sbtc</a></td></tr><tr><td><h4>Dual Stacking</h4></td><td>A financial innovation on top of the core foundation of Stacking. Earn bitcoin with bitcoin.</td><td><a href="dual-stacking">dual-stacking</a></td></tr><tr><td><h4>Bridging</h4></td><td>Explore how cross-chain interoperability works with Stacks and other major networks.</td><td><a href="bridging">bridging</a></td></tr></tbody></table>

***

### Additional Resources

* \[[Stacks YT](https://youtu.be/0erpW7IEo6Y?si=Ldu4RlVVnLqOL4eP)] How Stacks Will Grow In 2025 With Stacks Founder Muneeb Ali
* \[[Token2049 Dubai](https://youtu.be/DFTXAOmi0es?si=sMOO6Yfj_TCVdFTF)] Muneeb Ali - Building Bitcoin’s Future: The Role of Stacks L2&#x20;


# Stacks 101

Stacks has a very unique technical model in the blockchain world. This section will help you get a high-level overview of the essential components to understand how Stacks works.

We'll cover the basics of what Stacks is and how it works from both a philosophical and technical level, and you can dive into the further sections for more details.

First up, let's get an overview of exactly what Stacks is.


# What Is Stacks?

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-273720c2164bb69aeb720d97d2c2bd48c974507d%2FFrame%20316126258.jpg?alt=media" alt=""><figcaption></figcaption></figure>

We can get an idea of the goal and ethos behind Stacks by looking at [how Satoshi envisioned generalizing Bitcoin](https://satoshi.nakamotoinstitute.org/posts/bitcointalk/threads/244/#222) back in 2010:

> "...to be a completely separate network and separate block chain, yet share CPU power with Bitcoin...all networks in the world would share combined CPU power, increasing the total strength."

This is a major theme in the design decisions for Stacks. A bit of a contradiction in the Bitcoin world, the Stacks network is a Bitcoin L2, but it does have its own token.

This is an intentional and critical design decision primarily for the purpose of maintaining decentralization, rather than needing to rely on a federation.

If that's confusing or you are skeptical, that's understandable — we'll be diving deeper into these ideas as we go through the docs.

### Stacks and the Purpose of Blockchain Technology

When evaluating new blockchain technologies, it's important to keep the original intent and purpose of them intact. If we go back to Bitcoin, it was originally designed to be:

* Decentralized
* Immutable
* Secure

You've likely heard of the blockchain trilemma — the problem of trying to balance decentralization, scalability, and security of a blockchain network.

Stacks takes the approach of solving this trilemma by separating out chains into layers.

So at the bottom, you have the foundational layer: Bitcoin.

Bitcoin is the most decentralized, most secure, and most immutable blockchain network. However, that comes with a few tradeoffs.

* Bitcoin is very slow compared to other networks. Bitcoin only has a new block written once every \~10 minutes, making its throughput negligible compared to networks designed for speed like Solana.
* Bitcoin is also "boring". Ethereum came along after Bitcoin and sought to do the same thing for software that Bitcoin did for money. Ethereum's goal is to be a decentralized supercomputer of sorts, serving as a global compute environment for smart contracts (code that is written to a blockchain).
* Bitcoin is not scalable. Because every new block must propagate to every node on the network, Bitcoin can only run as fast as the slowest node in the network.

Now we are seeing the rise of modular blockchain networks like Cosmos that are designed to make it easy for people to spin up their own blockchain networks.

While most new blockchain protocols popping up these days see these properties as negatives and seek to eliminate them, the Stacks community sees things differently.

### The Stacks Way

Stacks takes a layered approach: the foundational settlement layer is Bitcoin, and scalability and functionality are added on top of that using layers.

There are many different types of L2s and different ways they can be built. They all come with [different tradeoffs](https://docs.stacks.co/learn/stacks-101/stacks-among-other-layers) and have their own way of accomplishing the goals of scalability or functionality.

By taking this layered approach, we are able to have all of the same functionality as chains like Ethereum, but built on Bitcoin.

So Stacks is a Bitcoin layer 2 with some unique properties, like having its own token, that acts as an incentive mechanism to maintain a historical ledger of all of its transactions and operate with its own security budget (in addition to Bitcoin's security budget — more on this in the next section).

This is one of the things that separates Stacks from other Bitcoin layers like Lightning.

* Lightning doesn't add any additional functionality to Bitcoin; it simply helps to scale functionality Bitcoin already has and helps it operate faster. Lightning is also ephemeral — it has no permanent state — and so is unsuitable for things like smart contracts that need to keep track of data and maintain state.
* Contrast this to Stacks, which adds additional functionality to Bitcoin but still ultimately settles to Bitcoin (we'll cover this in the next section as well).

The benefit is that we can maintain a separation of concerns and keep Bitcoin simple and sturdy, chugging along producing blocks, while adding additional layers for functionality and speed. If those other layers were compromised, the foundational layer would remain unaffected.

This is important when building systems intended to be a global decentralized money (Bitcoin) and a decentralized economy built on top of that money (Stacks).

The STX token is a separate token used to incentivize honest block production. It does not represent pegged Bitcoin (there is a separate Bitcoin peg called [sBTC](https://docs.stacks.co/learn/sbtc) for that purpose). While this may ruffle some feathers among parts of the Bitcoin community, it has several advantages.

By implementing a token into the Stacks chain, we provide additional economic incentive for miners to produce Stacks blocks honestly.

This token provides additional incentive as a way to grow the chain. Rather than relying on altruism to produce blocks and grow the chain, we can incentivize builders, token-holders, and investors all at the same time by having a token.

The ICO scams of 2017 put a bad taste in many people's mouths, which has justifiably made a lot of people skeptical of every new blockchain project that pops up with a new token.

But the problem with many of those projects was they had no actual value, weren't anchored to anything else of value, and provided no real utility.

With a project like Stacks, we have real utility in the sense of serving as a way to utilize Bitcoin and make it a productive asset in a decentralized way. This is a key point: currently the only common ways to make Bitcoin productive are to give it to a custodial service or transfer it off the Bitcoin chain via something like wBTC on Ethereum.

Stacks allows us to do this while ultimately still settling to the Bitcoin chain.

In addition, Stacks allows us to build decentralized and censorship-resistant software utilizing Bitcoin as the foundational settlement layer. Eventually, the goal is to build a network of financial systems and decentralized software products that all utilize Bitcoin as their money.

With that context, let's dive into exactly how Stacks is connected to Bitcoin.


# The Bitcoin Connection

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-dfb22d998899604417b072202f52fa3cdda377ef%2FFrame%20316126254.jpg?alt=media" alt=""><figcaption></figcaption></figure>

In the previous section, we described Stacks as bringing smart contract functionality to Bitcoin, without modifying Bitcoin itself, and explained a bit about how the chain works.

That's a big promise, but how does Stacks actually deliver on it? And what makes Stacks unique among other Bitcoin layers and other blockchains like Ethereum?

Before we get into the technical details of how Stacks works, it's important to get a high-level overview of the problem it's solving and how it actually does that. We'll dive deeper into some of these topics as we go through the docs, but it's good to get a high-level picture to bring everything together.

This topic is a bit of a rabbit hole, and this section is pretty long, but it will give you an in-depth understanding of exactly the problem Stacks is looking to solve, and how it solves it.

Let's get into it.

### Is Stacks a Bitcoin L2?

Stacks is a Bitcoin layer for smart contracts. The classification as a layer-1 (L1) or layer-2 (L2) or sidechain really depends on the definition used. With that said, generally speaking L1 chains are sovereign meaning that (a) they have their own security budget, and (b) they can survive without the need for any other L1 chain. L2 chains typically do not have their own security budget and share the security of the underlying L1 chain, and they cannot live without the underlying L1 chain. There are many different design mechanisms that L2s can use, and we cover several of them and how Stacks compares in the [Stacks Among Other Bitcoin Layers](https://docs.stacks.co/learn/stacks-101/stacks-among-other-layers) section.

The initial release of Stacks in early 2021 had a separate security budget from Bitcoin L1. Even though the Stacks layer could not function without Bitcoin L1, the developers working on the project described it as a different system that does not fit neatly into existing classifications, sometimes using the term layer 1.5 (see [this Decrypt article](https://decrypt.co/82019/bitcoin-defi-thing-says-stacks-founder-muneeb-ali) for example).

The upcoming planned release of Stacks, called the Nakamoto release, will no longer have a separate security budget from Bitcoin. Instead, a 100% of Bitcoin hashpower will determine finality on Stacks layer. After the next upgrade, to reorg Stacks blocks/transactions the attacker will need to reorg Bitcoin L1 itself (which is very hard to do and therefore a great security property for a Bitcoin layer to have). More details in the [Stacks paper](https://stacks.co/stacks.pdf).

The definition of [L2 used in Ethereum](https://ethereum.org/en/layer-2/) and other newer ecosystems is different and focuses on the ability to withdraw assets using only L1 security and L1 miners. According to that definition Stacks layer is not a clear L2, given the set of peg-out signers determine if users can withdraw sBTC. Bitcoin cannot support such verification without changes to Bitcoin L1 (which may happen in the future). The Ethereum L2 definition also does not apply that cleanly to Bitcoin L2s, given new assets are issued on L2s when it comes to Bitcoin and not issued on L1 (only BTC is the L1 asset). Therefore, using the definition of security of withdrawing assets is not directly applicable given assets are defined and used on L2s and not withdrawn out to Bitcoin L1 anyway (with the exception of BTC itself). Rather, what becomes more important is "settlement on Bitcoin" i.e., is contract data and state secured by 100% of Bitcoin's hashpower or not.

Remember that L2s on Bitcoin also have to serve the additional purpose of expanding both functionality and scalability, which means L2s accomplish fundamentally different goals depending on the functionality of the L1.

Users and developers organically call Stacks a Bitcoin L2, since it is a simpler concept to understand. There are certain properties of Stacks layer that also help the concept of Stacks as a Bitcoin L2:

{% stepper %}
{% step %}
**Bitcoin finality**

100% of the Bitcoin hashpower decides block ordering and transaction finality.
{% endstep %}

{% step %}
**Consensus runs on Bitcoin L1**

Stacks consensus runs on Bitcoin L1, and Stacks L2 cannot operate or survive without Bitcoin L1.
{% endstep %}

{% step %}
**sBTC and economic unit**

With the upcoming decentralized Bitcoin peg, called sBTC, most of the economy on Stacks layer will likely use BTC as the unit of economy. It is expected that most users will simply use Bitcoin in wallets and apps and then peg out their BTC to Bitcoin L1.
{% endstep %}

{% step %}
**Data hashed and stored on Bitcoin L1**

All data and transactions on Stacks are automatically hashed and permanently stored on Bitcoin L1 on every Bitcoin block. Anyone can verify that some data on Stacks is valid by checking the corresponding hash on Bitcoin L1. This compact storage of hashes on L1 is somewhat similar to rollups (although there are other differences). You can read more about this process in the [Block Production](https://docs.stacks.co/learn/block-production) section.
{% endstep %}

{% step %}
**Contracts can read Bitcoin L1**

Contracts on Stacks layer can read Bitcoin L1 transactions and respond to them. Assets on Stacks layer can be moved simply through Bitcoin L1 transactions.
{% endstep %}
{% endstepper %}

Given all the details above, why would some people think that Stacks is not a Bitcoin L2? There are a couple of reasons this question comes up often:

{% stepper %}
{% step %}
**Old security-budget material**

The initial version of Stacks (released early 2021) had a separate security budget which changed to following 100% Bitcoin hashpower with the Nakamoto release. There is old material and blog posts floating around that still talk about the initial Stacks version. The old materials will likely get updated with time.
{% endstep %}

{% step %}
**Ethereum L2 withdrawal definition doesn't map cleanly**

According to the Ethereum definition of L2s a user should be able to withdraw their base-layer assets purely by doing an L1 transaction and relying only on L1 security (this is true for Lightning for example). This definition does not apply cleanly to Bitcoin L2s because assets are not defined at Bitcoin L1 but are defined in L2s instead. The only asset where this matters is the pegged BTC asset from Bitcoin L1, given all other assets are native to L2s anyway. In the upcoming Stacks release, users can withdraw their BTC by sending just a Bitcoin L1 transaction but Bitcoin L1 cannot validate that complex transaction and a majority of peg-out signers will need to sign on the peg-out request. In an ideal world Bitcoin miners can validate such transactions but that would require a change to Bitcoin L1. Therefore, Stacks design optimizes for a method that is decentralized and can be deployed without any changes to Bitcoin L1. If in the future it is possible to make changes to Bitcoin L1 then Stacks layer security can benefit from that as well.
{% endstep %}

{% step %}
**Healthy Bitcoin skepticism**

Bitcoin community members are generally skeptical of claims and on the lookout for people making any false marketing claims. This is generally a healthy thing for the Bitcoin ecosystem and builds up the immune system. Some such community members might be skeptical about Stacks as a Bitcoin layer or L2 until they fully read the technical details and reasoning. There is a good [Twitter thread](https://twitter.com/lopp/status/1623756872976158722?s=20) about this topic as well.
{% endstep %}
{% endstepper %}

Why don't we use the term 'sidechain' for Stacks then? Sidechains in Bitcoin typically have a different security budget from Bitcoin L1, typically as a subset of Bitcoin miners who participate in the sidechain (they don't follow 100% Bitcoin finality), their consensus runs on the sidechain (vs running on Bitcoin L1), and they don't publish their data/hashes on Bitcoin L1. The Stacks layer does not fit that definition cleanly given the consensus runs on Bitcoin L1, it follows Bitcoin finality, and publishes data/hashes on L1.

Can Stacks layer work with rollups?

Yes! There is already an active R\&D effort to integrate rollups with the Stacks layer. Both with the Stacks layer and sovereign rollups the technically challenging part is how to get BTC in and out of the Stacks layer or the sovereign rollup. The decentralized BTC peg, [sBTC](https://docs.stacks.co/learn/sbtc), applies to both the Stacks layer and sovereign rollups. Without modifying Bitcoin L1, an sBTC-like design with a decentralized open-membership group of signers is the most trust-minimized way to move BTC in and out of Bitcoin layers. Once the necessary upgrades to Bitcoin L1 can be made to enable validity rollups i.e., Bitcoin L1 can enforce BTC withdrawal from a layer, then the Stacks layer can also upgrade to benefit from it.

Given a trust-minimized asset like sBTC is needed for sovereign rollups, with the launch of sBTC such sovereign rollups become even more interesting to deploy. The Stacks layer can potentially provide the decentralized group of signers for a trust-minimized BTC asset that can be used in a sovereign rollup, and DA comes directly from Bitcoin L1 e.g., with Ordinals.

### Why Does Stacks Need a Token?

This brings us to a central philosophical conversation in the world of crypto and Bitcoin, whether or not blockchains need tokens.

Let's start by looking at the fundamental reason why tokens exist: to fund the maintenance and forward progress of a blockchain.

Bitcoin is a token. It is a cryptocurrency that is used to incentivize miners to add new blocks to the chain. In Bitcoin's case, mining rewards are set on a predefined schedule, and once those mining rewards run out, the chain will need to survive on transaction fees alone.

The purpose of a blockchain is to have a permanent historical record of every transaction that has ever occurred on the chain. Blockchains are basically ledgers. The token aspect is used as an incentive mechanism to secure and maintain the chain.

This is why networks like Lightning and other P2P networks don't need tokens, they don't need to maintain a historical record. Channel-based solutions like Lightning rely on users opening 2-of-2 multisigs with each other. Once those channels are closed, the state disappears. When we are talking about a system that is supposed to maintain a global financial system, it is important for the maintenance of that system to be incentivized correctly.

Let's look at this concept in the context of Stacks and its goals. Stacks seeks to provide smart contract functionality to Bitcoin, to serve as the programming rails for building a decentralized economy on top of Bitcoin.

Many Bitcoin community members are skeptical of new tokens and rightly so. There are countless projects out there that force the use of a token on their project and in many cases a token is actually not needed. The Stacks project was started by Bitcoin builders who have a long history of building apps & protocols on Bitcoin L1 without any token (e.g., BNS launched in 2015 on Bitcoin L1 which was one of the largest protocols using OP\_RETURN on Bitcoin L1). So why did a bunch of Bitcoin builders decide to have a separate token for Stacks L2? Great question! Let's dig into the details.

The Stacks token (STX) is primarily meant to be used for two things:

{% stepper %}
{% step %}
**Incentives for Stacks L2 miners**

Newly minted STX are used to incentivize decentralized block production on Stacks L2.
{% endstep %}

{% step %}
**Incentives for peg-out signers**

Signers participating in peg-out operations receive incentives in STX to economically align them with protocol rules.
{% endstep %}
{% endstepper %}

The only way to remove the token is to build Stacks as a federated network like Liquid. In a federation the pre-selected group of companies control the mining and block production and a pre-selected group of companies need to be trusted for peg-out transactions.

Stacks developers wanted to design an open and permissionless system. The only way to have a decentralized mining process is through incentives. As mentioned above, this is how Bitcoin works as well, where newly minted BTC are used as incentives to mine new blocks and anyone in the world can decide to become a miner. Anyone with BTC can mine the Stacks L2 chain, it is open and permissionless.

Similarly, the way sBTC is designed is that the group of signers is open and permissionless (unlike a federation). These signers have economic incentives to correctly follow the protocol for peg-out requests. In a federation, users need to blindly trust the pre-set federation members to get their BTC out of the federation and back on Bitcoin L1. Stacks developers wanted to have an open, permissionless, and decentralized way to move BTC from Bitcoin L1 to Stacks L2 and back. This is made possible through economic incentives i.e., need for a token.

{% hint style="info" %}
With more and more Bitcoin layers emerging, there is some nuance in this federated vs open network design. Some protocols like Botanix's Spiderchain offer an open network but have different incentive mechanisms. We dig into these in detail in the [Stacks Among Other Layers](https://docs.stacks.co/learn/stacks-101/stacks-among-other-layers) section.
{% endhint %}

Other than these two reasons, STX is also used to pay gas fees for transactions. However, once the upcoming sBTC peg is live most of the economy of Stacks L2 is expected to follow a Bitcoin standard and work using BTC as the economic unit. It is expected that users will mostly interact just with Bitcoin and use BTC in wallets and apps (gas fees can be paid with BTC using atomic swaps in the background). It is important to note that BTC cannot be used for mining incentives on Stacks L2 because the only way to incentivize decentralized block production is through newly minted assets by the protocol (similar to how Bitcoin works itself) i.e., need for a token.

### The Symbiotic Relationship Between Stacks and Bitcoin

Stacks and Bitcoin complement each other. Stacks leverages the extreme decentralization of Bitcoin, its PoW consensus mechanism, and its value as a cryptocurrency.

But Stacks also complements Bitcoin by unlocking additional use cases, thereby increasing its value over time. This also helps to solve the additional problem of the future maintainability of Bitcoin after the coinbase rewards are gone and Bitcoin has to function on transaction fees alone.

If Bitcoin is seen as only a store of value, the economic density, meaning how much value is being exchanged, of each transaction will be minimal. But if Bitcoin is the underlying foundation for an entire decentralized economy, those [transactions become much more valuable](https://twitter.com/muneeb/status/1506976317618728963), increasing transaction fees. This is a crucial incentive for miners to continue securing the network as coinbase rewards drop.

### Reading from Bitcoin State

One of the things that gives the Stacks chain its superpowers in connecting with Bitcoin is not only how it connects to Bitcoin at a protocol level, discussed above, but also how we can utilize that Bitcoin at a programmatic level.

That's where Clarity comes in. Clarity is the smart contract language for Stacks, and is how we actually build out a lot of the functionality we are talking about here.

One of the often-touted features of Clarity is that it has access to the state of the Bitcoin chain built in, but how does it actually do that? Because of Stacks' PoX mechanism, every Stacks block is connected to a Bitcoin block, and can query Bitcoin block header hashes with the [`get-burn-block-info?` function](https://github.com/stacksgov/sips/blob/feat/sip-015/sips/sip-015/sip-015-network-upgrade.md#new-method-get-burn-block-info).

This function allows us to pass in a Bitcoin block height and get back the header hash. The [`burn-block-height` Clarity keyword](https://docs.stacks.co/docs/write-smart-contracts/clarity-language/language-keywords#burn-block-height) will give us the current block height of the Bitcoin chain.

However, `get-burn-block-info?` only returns data of the Bitcoin block at that height if it has already been processed and was created after the launch of the Stacks chain. So if we want to evaluate whether or not something happened on Bitcoin, we have to wait at least one block later to do so.

This is step 1 of Clarity contracts being able to serve as the programming layer for Bitcoin. When a BTC transaction is initiated, the first thing that needs to happen is that a Clarity contract needs to become aware of it. This can happen manually by utilizing Clarity functions discussed above with the [BTC library](https://explorer.stacks.co/txid/0x8b112f2b50c1fa864997b7496aaad1e3940700309a3fdcc6c07f1c6f8b9cfb7b?chain=mainnet), as [Catamaran Swaps](https://docs.catamaranswaps.org/en/latest/catamaran.html) do.

{% hint style="info" %}
Note that this process is made easier by the additional Clarity functions added in 2.1, like the `get-burn-block-info?` function we looked at above.
{% endhint %}

Or we can automate (albeit at a cost of some centralization in our dapp) using an event-based architecture using something like Hiro's [chainhooks](https://www.hiro.so/blog/meet-4-new-features-in-clarinet#setting-up-trigger-actions-with-chainhooks), which will allow us to automatically trigger a Clarity contract call when a certain BTC transaction is initiated.

This is the first component of using Stacks to build Bitcoin dapps, the read access to Bitcoin chain.

Next up, let's dig a bit deeper into how exactly Stacks is "built on Bitcoin" by taking a look at Stacks' block production mechanism, Proof of Transfer.


# Proof of Transfer (PoX)

<figure><picture><source srcset="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2FqhGYp66lKo0jjZ57rDpy%2Fpox-light.png?alt=media&#x26;token=0d44f0ac-4595-40b4-b554-a510af89fea4" media="(prefers-color-scheme: dark)"><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2FEUW1W0NPEuoCYBtienyL%2Fpox.png?alt=media&#x26;token=2edba99c-91f7-4df2-8ea1-aceb9f3bb712" alt=""></picture><figcaption></figcaption></figure>

In the previous sections, we took a look at the vision and ethos of Stacks and talked a lot about it being connected to Bitcoin and how it enables expanding functionality without modifying Bitcoin itself.

In this section, we'll run through the block production mechanism that makes that happen, Proof of Transfer.

This section will be a conceptual overview of Proof of Transfer. For more details on exactly how block production happens at a technical level, check out the section on [Block Production](https://docs.stacks.co/learn/block-production).

Consensus algorithms for blockchains require compute or financial resources to secure the blockchain. The general practice of decentralized consensus is to make it practically infeasible for any single malicious actor to have enough computing power or ownership stake to attack the network.

Popular consensus mechanisms in modern blockchains include proof of work, in which nodes dedicate computing resources, and proof of stake, in which nodes dedicate financial resources to secure the network.

Proof of burn is another, less-frequently used consensus mechanism where miners compete by ‘burning’ (destroying) a proof of work cryptocurrency as a proxy for computing resources.

Proof of Transfer (PoX) is an extension of the proof of burn mechanism. PoX uses the proof of work cryptocurrency of an established blockchain (Bitcoin in this case) to secure a new blockchain. However, unlike proof of burn, rather than burning the cryptocurrency, miners transfer the committed cryptocurrency to some other participants in the network (Stackers in this case).

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2FDdAEe8T2U2HNgOsnAaFb%2FStacks_graphic%20-%2067.png?alt=media&#x26;token=2a4344b9-c8e8-4ab1-990d-2d2ab61d3932" alt=""><figcaption></figcaption></figure></div>

This allows network participants to secure the PoX cryptocurrency network and earn a reward in the base cryptocurrency (BTC). Thus, PoX blockchains are anchored on their chosen PoW chain. Stacks uses Bitcoin as its anchor chain.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fjt1GkSXIb4cL4d1e4SDo%2FStacks_graphic%20-%2080.png?alt=media&#x26;token=6ba8fe68-ad75-4178-9ebc-51ee2b2f7b7b" alt=""><figcaption></figcaption></figure></div>

### Why Bitcoin?

There are a number of reasons that Stacks chose Bitcoin as the blockchain to power consensus. It's the oldest blockchain protocol, having launched in 2009, and has become a recognized asset outside of the cryptocurrency community. BTC has held the highest market capitalization of any cryptocurrency for the past decade.

Bitcoin champions simplicity and stability, and has stood the test of time. Influencing or attacking the network is infeasible or impractical for any potential hackers. It's one of the only cryptocurrencies to capture public attention. Bitcoin is a household name, and is recognized as an asset by governments, large corporations, and legacy banking institutions. Lastly, Bitcoin is largely considered a reliable store of value, and provides extensive infrastructure to support the PoX consensus mechanism.

SIP-001 provides a full [list of reasons why Bitcoin was chosen to secure Stacks](https://github.com/stacksgov/sips/blob/main/sips/sip-001/sip-001-burn-election.md).

{% hint style="info" %}
By the way, SIP stands for Stacks Improvement Proposal, and it's the process by which community members agree on making changes to the network. Reading the SIPs in detail is an excellent way to familiarize yourself with Stacks at the implementation level. All of the SIPs are available in the [SIPs section](https://docs.stacks.co/learn/network-fundamentals/sips) of the docs.
{% endhint %}

### Unlocking Bitcoin capital

In the previous section we talked about Stacks being able to allow us to build a decentralized economy on top of Bitcoin and that PoX was a key piece of being able to do that.

The reason is two-fold. First, as a part of this PoX mining process we have covered here, a hash of each Stacks block is recorded to the OP\_RETURN opcode of a Bitcoin transaction. If you aren't familiar, the OP\_RETURN opcode allows us to store up to 40 bytes of arbitrary data in a Bitcoin transaction.

{% hint style="info" %}
This [Stack Exchange answer](https://bitcoin.stackexchange.com/questions/29554/explanation-of-what-an-op-return-transaction-looks-like) gives a good overview of the reasoning and history of this opcode.
{% endhint %}

This is the first part of how Stacks inherits Bitcoin's security: its history is anchored block-by-block to the Bitcoin chain. Anyone can use merkle roots to verify these hashes to determine if the history is correct.

Additionally, after the Nakamoto Upgrade, Stacks no longer forks on its own. Miners are required at a protocol level to build atop the last mined Stacks blocks, meaning that **Stacks is secured by both 100% of Bitcoin's hashrate in addition to the Stacks security budget from its miners.** We'll get into this process in more detail in the [Block Production](https://docs.stacks.co/learn/block-production) section.

Additionally, part of this PoX process involves each Stacks block also knowing which Bitcoin block it is anchored to. Clarity, Stacks' smart contract language, has built-in functions for reading this data, such as [`get-block-info`](https://docs.stacks.co/docs/write-smart-contracts/clarity-language/language-functions#get-block-info), which returns, among other things, a field called `burnchain-header-hash`, which gives us the hash of the Bitcoin header corresponding to this Stacks block.

This allows us to do really interesting things like trigger certain things to happen in a Clarity contract by watching the chain and verifying whether or not certain transactions occurred. You can see this in action in [Catamaran Swaps](https://docs.catamaranswaps.org/en/latest/catamaran.html), with other interesting projects like [Zest](https://www.zestprotocol.com/) seeking to expand on this functionality.

The ultimate goal of all this is to enable the vision of web3, building a decentralized economy and enabling true user ownership of assets and data, on top of Bitcoin as a settlement layer, and using Bitcoin as a base decentralized money.

### Proof of Transfer Contracts and Technical Details

The Proof of Transfer functionality is implemented on the Stacks chain via a [Clarity smart contract](https://explorer.hiro.so/txid/0xc6d6e6ec82cabb2d7a9f4b85fcc298778d01186cabaee01685537aca390cdb46?chain=mainnet). An overview of this contract is available in the docs.

You can see the original design for stacking and proof of transfer by reading the relevant SIP, [SIP-007](https://github.com/stacksgov/sips/blob/main/sips/sip-007/sip-007-stacking-consensus.md). You can also utilize [Hiro's API](https://docs.hiro.so/api#tag/Info/operation/get_pox_info) to get proof of transfer details including the relevant contract address.


# Stacks Among Other Layers

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2FHnpCVWQoXIlwJ3zHUMoU%2Fbitcoin-layer-2s.jpg?alt=media&#x26;token=e26f76f4-20af-49f0-a762-54e8409c6688" alt=""><figcaption></figcaption></figure>

Recently, we have seen a flurry of new "Bitcoin layers" popping up across the ecosystem as the market has finally woken up to the idea.

However, not all Bitcoin layers are made equal. While a large chunk of these projects are vaporware riding the hype train, there are several projects that are making a good faith effort to grow the Bitcoin economy and build on top of Bitcooin using various approaches.

The [Bitcoin Layers project](https://www.bitcoinlayers.org/) is an excellent place to begin learning about these different layers. In addition, here we've broken down how Stacks compares to some of the most promising Bitcoin L2 solutions so you can begin to learn about them all and make an educated decision on which to use.

### What is a Bitcoin Layer?

It's important to define terms, especially in a new and evolving ecosystem like web3, and an even newer and more rapidly evolving subecosystem like Bitcoin layers.

For the purpose of this document and comparison, we can use the following definition of a Bitcoin layer: A Bitcoin layer is a separate distributed computing system built either alongside or on top of Bitcoin for the purpose of enhancing its scalability, functionality, or both.

That definition is intentionally general, and encompasses many different projects like L2s, sidechains, federated, open network, etc.

#### Technical vs Economic Considerations

It's important to understand that when designing blockchains, especially layer 2 systems, we have to consider both technical and economic factors. Since a core component of a blockchain system is money, we need to make sure that our systems are both technically robust and economically efficient. And we need to accomplish both of these things while maintaining decentralization.

While it is trivial to create a trusted bridge to bridge BTC from the L1 to a L2, that defeats the purpose of blockchain technology in general, since the goal should be to create permissionless, trust-minimized systems.

At the same time, a great technical solution that doesn't consider the economic incentives of the decentralized actors running the network will not have a sustainable path to long-term adoption and viability.

This balance is why Stacks has chosen the design it has, to balance both achieving the technical features of a Bitcoin L2 like security inheritance and a trust-minimized BTC peg with the economic incentives for the participants in the ecosystem to maintain it in the long term.

As an example of this, Galaxy recently [conducted research](https://www.galaxy.com/insights/research/exploring-bitcoin-for-data-availability/) on this topic and found that a Bitcoin rollup "will need to generate approximately between $1.9m and $9.63m in revenue from L2 transaction fees per month." That is a significant number and again highlights the need to consider both technical and economic factors when designing Bitcoin layers.

### Popular Bitcoin Layers Compared

#### Lightning

Lightning is probably the most well-known Bitcoin layer, and is primarily designed to address scalability issues. Lightning functions as a separate P2P network from Bitcoin, allowing participants to move their BTC from the main chain to Lightning, conduct multiple transactions on Lightning, and then send the final result to the BTC chain where it is finalized.

This is actually a completely separate problem from what Stacks is trying to address. Where Lightning takes the existing functionality of Bitcoin and makes it much more scalable, Stacks is seeking to expand Bitcoin's functionality to do things you can't do now.

Crucially, Lightning is ephemeral, meaning it has no state management. There is no continuous record of what has happened on the Lightning network, only current channels. Once users close their channel and their transactions are written back to the Bitcoin chain, they are gone.

A key component of fully-expressive smart contracts is that they maintain a permanent historical record of all transactions that have happened on the chain.

Bitcoin does this now, but its scripting language is very limited. So where Lightning seeks to make existing Bitcoin functionality happen faster, Stacks seeks to add new functionality.

#### RSK

Like Stacks, [RSK](https://www.rsk.co/) seeks to add additional functionality to Bitcoin, but it goes about that process differently than Stacks.

RSK is a merge-mined chain, meaning that it is mined concurrently with Bitcoin. Stacks has its own miners and mining process, and its own economic value and security that is a function of that token value, more on this below.

There are multiple perspectives to look at this from. Because RSK is merge-mined, Bitcoin miners are also the ones mining RSK blocks, and RSK does not have its own token.

RSK can only exist with opt-in from Bitcoin miners and mining rewards are highly dependent on transaction volume.

This also opens up a wider discussion on the costs and benefits of having a separate token, which we'll get into below a bit when we discuss rollups.

RSK is also EVM-compatible, where Stacks uses Clarity and the Clarity VM.

#### Liquid

[Liquid](https://liquid.net/) is a federated network focused on unlocking more advanced financial capabilities with Bitcoin. Being federated, Liquid is not an open network, and thus not decentralized.

The Liquid consensus mechanism is managed by 15 functionaries, who handle the transaction processing and validating. Liquid also does not support general-purpose applications, but is solely focused on financial applications.

For another perspective, Hiro wrote an [excellent post](https://www.hiro.so/blog/building-on-bitcoin-project-comparison) comparing Stacks with other Bitcoin projects.

#### Bitcoin Rollups

Rollups are an exciting development for scaling decentralized applications. There are many different types of rollups; they're broadly divided into ZK rollups and Optimistic rollups, although other classifications are also there (see [this overview](https://era.zksync.io/docs/dev/fundamentals/rollups.html#what-are-rollups)).

Rollups are generally considered layer-2 (L2) technology that runs on top of a layer-1 blockchain like Bitcoin or Ethereum. A critical aspect of rollups is the trustless nature where logic running on the L1 chain can determine whether something that happened on the rollup was valid. This is not true for all types of rollups, and there is some fuzziness around exact definitions. [Sovereign rollups](https://blog.celestia.org/sovereign-rollup-chains/), for example, only use the underlying L1 for data availability (DA) and not for consensus.

Most of the rollups work on Ethereum uses Ethereum L1 both as a data availability layer, and for consensus, i.e., the validity of rollup transactions is determined by logic running on Ethereum L1. Newer systems, [like Celestia](https://celestia.org/), are taking a more modular approach and are separating DA from consensus. One interesting aspect of separating DA is that more established and durable chains like Bitcoin can be used for DA as well. Below is an interesting comparison of sidechains and two types of rollups possible on Bitcoin (John Light posted this [on Twitter](https://twitter.com/lightcoin/status/1630301411962388481?s=20)):

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-341e6adabafad87e3633375f45fdd4d8e4ba323d%2Fimage.png?alt=media" alt=""><figcaption></figcaption></figure>

This image broadly means developers can build sovereign rollups on Bitcoin today, but you'll need a "trusted" setup for moving BTC in and out of the rollup. In fact, people are already doing this -- see the recent [Rollkit announcement](https://rollkit.dev/blog/sovereign-rollups-on-bitcoin/). To build validity rollups, meaning Bitcoin L1 enforces BTC withdrawals from the rollup, you'll need modifications to Bitcoin L1. See [this overview](https://bitcoinrollups.org/) for more details.

One important nuance here is the cost required to effectively run a rollup on Bitcoin as discussed in the Galaxy research report linked in the first section.

Now we have a solid grasp of how Stacks works and how it fits in among other layers. Let's begin to dig into some of the technical implementation details and see how Stacks actually works.

***

Additional Resources

* \[[Hiro Blog](https://www.hiro.so/blog/building-on-bitcoin-project-comparison)] Building on Bitcoin: a Comparison of Bitcoin Projects
* \[[Hiro Books](https://www.hiro.so/books/a-beginners-guide-to-bitcoin-layers)] A Beginner's Guide to Bitcoin Layers


# Financial Incentive And Security Budget

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-412a18b7879f6c85d7d9cb6d6290ded4fc1a1afc%2Fimage.png?alt=media" alt=""><figcaption><p>image source: <a href="https://www.hiro.so/blog/securing-web3-apps-through-bitcoin-an-overview-of-stacks-consensus-mechanism">Hiro blog</a></p></figcaption></figure>

In order to reorg the Stacks chain, someone must take control of at least 70% of the STX that are currently Stacked and conduct a 51% attack on Bitcoin itself. If acquired at market prices, then at the time of this writing, that amounts to spending nearly $1 billion USD in only the STX stacked.

In addition to this, because of how Stacks achieves Bitcoin finality by not allowing forks, Stacks security budget reaches 51% of Bitcoin's mining power because in order to reverse the chain state you would need to reverse the Bitcoin chain state as well.

Stackers have the new-found power to sign blocks in order to append them to the Stacks chain. However, some of them could refuse to sign, and ensure that no block ever reaches the 70% signature threshold. While this can happen by accident, this is not economically rational behavior -- if they stall the chain for too long, their STX loses their value, and furthermore, they cannot re-stack or liquidate their STX or activate PoX to earn BTC. Also, miners will stop mining if no blocks are getting confirmed, which eliminates their ongoing PoX payouts.

The technical details of how this all works are discussed in the [Block Production](https://docs.stacks.co/learn/block-production) section.


# Network Fundamentals

Now that you have a high-level understanding of what Stacks is and how it works, let's dive into some more details of all of the components that make up the Stacks Bitcoin L2.

We're going to start with the basics of how the network is actually structured and the components that comprise it.


# Network Basics

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-38bbfbae841ffaa0d8ed353ebfc33f0b6fcac882%2Fimage.png?alt=media" alt=""><figcaption><p>image source: <a href="https://www.hiro.so/blog/understanding-nakamotos-fast-blocks-on-stacks">Hiro blog</a></p></figcaption></figure>

### Tokens

Stacks (STX) tokens are the native tokens on the Stacks blockchain. The smallest fraction is one micro-STX. 1,000,000 micro-STX make one Stacks (STX).

STX amounts should be stored as integers (8 bytes long), and represent the amount of micro-STX.

### Fees

Fees are used to incentivize miners to confirm transactions on the Stacks blockchain. The fee is calculated based on the estimate fee rate and the size of the raw transaction in bytes. The fee rate is a market determined variable. For the testnet, it is set to 1 micro-STX.

Fee estimates can obtained through the [`GET /v2/fees/transfer`](https://docs.hiro.so/api#operation/get_fee_transfer) endpoint of the API.

{% hint style="info" %}
Note that this example uses an external tool, [Hiro's Stacks API](https://www.hiro.so/stacks-api). You can also use the native [Stacks API ](https://app.gitbook.com/u/ZrQItu6D9bMKmf1HfsLTnGc05WZ2)if you would rather run your own node or connect to one.
{% endhint %}

{% code title="terminal" %}

```bash
# for mainnet, replace `testnet` with `mainnet`
curl 'https://api.testnet.hiro.so/v2/fees/transfer'
```

{% endcode %}

The API will respond with the fee rate (as integer):

```json
1
```

[The Stacks Transactions JS library](https://github.com/stx-labs/stacks.js/tree/master/packages/transactions) supports fee estimation for:

* token transfers (`estimateTransfer`)
* contract deploys (`estimateContractDeploy`)
* non read-only contract calls (`estimateContractFunctionCall`)

{% hint style="info" %}
For an implementation using a different language than JavaScript, please review [this reference implementation](https://github.com/stx-labs/stacks.js/blob/master/packages/transactions/src/builders.ts#L97).
{% endhint %}

### Nonces

Every account carries a [nonce property](https://en.wikipedia.org/wiki/Cryptographic_nonce) that indicates the number of transactions processed for the given account. Nonces are one-time codes, starting at `0` for new accounts, and incremented by 1 on every transaction.

Nonces are added to all transactions and help identify them in order to ensure transactions are processed in order and to avoid duplicated processing.

{% hint style="info" %}
The consensus mechanism also ensures that transactions aren't "replayed" in two ways. First, nodes query its unspent transaction outputs (UTXOs) in order to satisfy their spending conditions in a new transaction. Second, messages sent between nodes review sequence numbers.
{% endhint %}

When a new token transfer transaction is constructed, the most recent nonce of the account needs to be fetched and set.

{% hint style="info" %}
The API provides an endpoint to [simplify nonce handling](https://docs.hiro.so/get-started/stacks-blockchain-api#nonce-handling).
{% endhint %}

### Querying

Stacks network details can be queried using the [Stacks Blockchain API](https://docs.hiro.so/get-started/stacks-blockchain-api).

#### Health check

The [status checker](https://status.stacks.org/) is a service that provides a user interface to quickly review the health of the Stacks blockchain.

#### Network info

The network information can be obtained using the [`GET /v2/info`](https://docs.hiro.so/api#operation/get_core_api_info) endpoint:

{% code title="curl (testnet)" %}

```bash
# for mainnet, replace `testnet` with `mainnet`
curl 'https://api.testnet.hiro.so/v2/info'
```

{% endcode %}

Sample response:

```js
{
    "peer_version": 385875968,
    "burn_consensus": "826401d65cf3671210a3fb135d827d549c0b4d37",
    "burn_block_height": 1972,
    "stable_burn_consensus": "e27ea23f199076bc41a729d76a813e125b725f64",
    "stable_burn_block_height": 1971,
    "server_version": "blockstack-core 0.0.1 => 23.0.0.0 (master:bdd042242+, release build, linux [x86_64]",
    "network_id": 2147483648,
    "parent_network_id": 3669344250,
    "stacks_tip_height": 933,
    "stacks_tip": "1f601823fbcc5b6b2215b2ff59d2818fba61ee4a3cea426d8bc3dbb268005d8f",
    "stacks_tip_burn_block": "54c56a9685545c45accf42b5dcb2787c97eda8185a1c794daf9b5a59d4807abc",
    "unanchored_tip": "71948ee211dac3b241eb65d881637f649d0d49ac08ee4a41c29217d3026d7aae",
    "exit_at_block_height": 28160
}
```


# Mainnet and Testnets

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-b9085514942994a4f51310436d9280ca02b58aca%2Fimage.png?alt=media" alt=""><figcaption><p>image source: <a href="https://www.hiro.so/blog/what-are-blockchain-layers">Hiro blog</a></p></figcaption></figure>

Stacks has both a mainnet and a testnet for different purposes. Mainnet and testnet are two completely different networks and tokens cannot be transferred between one or the other.

### Mainnet

Stacks mainnet is directly connected to the Bitcoin mainnet and its the network where tokens have actual monetary worth. This is the production network and should be treated as such.

You can view mainnet activity using the official [Stacks explorer](https://explorer.hiro.so/).

### Testnet

The Stacks testnet serves as a live public sandbox for developers, allowing them to build, test, and iterate on apps and smart contracts in an environment that mimics the mainnet. It provides a risk-free space to experiment with changes or new features before deploying them on the Stacks mainnet, ensuring that everything functions correctly without the risk of real financial loss.

You can view testnet activity using the official [Stacks explorer](https://explorer.hiro.so/?chain=testnet).

#### Testnet Faucets

Testnet faucets provide you with mock Stacks (STX) tokens to test with. These testnet STX have no value and are not the same as STX on mainnet. There are a couple of different options for getting testnet STX.

{% tabs %}
{% tab title="Hiro" %}
You can get testnet STX from the [Hiro Platform](https://platform.hiro.so/faucet), which is the recommended way.

To get STX tokens from within the Hiro Platform, navigate to the "Faucet" tab at the top. You can then choose either testnet STX or sBTC, and then paste in your desired testnet STX address to receive.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2FjjVK8GVvGbnDTQxzgJ5t%2Fimage.png?alt=media&#x26;token=e82a313d-4381-45cc-9a36-ba02a598d9f4" alt=""><figcaption></figcaption></figure></div>
{% endtab %}

{% tab title="Sandbox" %}
Using the faucet provided by the [Explorer Sandbox](https://explorer.hiro.so/sandbox/deploy?chain=testnet) is another option.

You'll first need to connect your wallet to the Explorer Sandbox and hit 'Request STX'. Be sure your wallet is on the testnet network before requesting.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2FQCTtyAN2r4btyxWOyJs3%2Fsandbox-faucet.png?alt=media&#x26;token=ac55a1c3-fbe8-4424-a513-3074c7befc5d" alt=""><figcaption></figcaption></figure></div>
{% endtab %}

{% tab title="LearnWeb3" %}
Alternatively, you can use the [LearnWeb3 faucet](https://learnweb3.io/faucets).

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-6b3929bea804b05efe83f4bb140709378b6024fb%2Fimage.png?alt=media" alt=""><figcaption></figcaption></figure></div>
{% endtab %}
{% endtabs %}


# Wallets & Accounts

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-2d782448481ac5b6f078b0307da62a30af1d8d6f%2FFrame%20316126255.jpg?alt=media" alt=""><figcaption></figcaption></figure></div>

{% hint style="info" %}
For the technical breakdown and standard for how wallets/accounts are generated in Stacks, check out [**SIP-005 standard**](https://github.com/stacksgov/sips/blob/main/sips/sip-005/sip-005-blocks-and-transactions.md) that outlines all of this.
{% endhint %}

### Introduction

Stacks wallets are software or hardware tools for storing cryptocurrencies, NFTs, and other digital assets. They are also used for establishing on-chain identity in decentralized applications (dApps). These wallets cryptographically store and manage each user’s identity and funds through a single blockchain address, which leverage public-key cryptography.&#x20;

#### Purpose of a Stacks wallet

* Establish User Identity
* Store Assets
* Display Balances
* Sign Transactions
* Sign Messages
* Participate in the Bitcoin Economy

Wallets in Stacks consists of accounts, which uses an accounts-based model, rather than a UTXO model like Bitcoin. This model is simpler than the UTXO model and has a more traditional concept of “balance”, similar to what you would encounter at a bank. In this model, each address has a single “balance” figure for a given token that increases/decreases as transactions are sent to/from that account. This is what most Web3 ecosystems use. In a UTXO model, the network operates as a ledger, with each UTXO being analogous to a cash bill.

#### Components of a Stacks account

* **Private Key** - The private key is an alphanumeric code that is paired to a single public key on a 1:1 basis. Never share your private key with anyone. A private key is how you prove ownership of a public key and how you can spend assets held by that particular key-pair.\
  \
  Example private key in Stacks (32 bytes appended with a 0x01 byte):\
  `5a4133fec2cf923d37238d3ba2fcd2ee9c8dce882c22218fd210d8a02ceb2c7401`
* **Public Key** - The public key is derived mathematically from the private key. It can be shared safely and is used by the network to verify signatures created by the private key, without revealing the private key itself.\
  \
  Example public key in Stacks (compressed format):\
  `02e8eb87862945d369511fdcce326ffef9a01b68c7d070e3ce685a5cbb9b1ecfc5`
* **Address (Principal)** - The address is a shorter, user-friendly representation derived from the public key. It’s what you share to receive sBTC, STX, tokens, or NFTs on Stacks, and it acts as the on-chain identifier for the user.\
  \
  Example public address in Stacks (c32check encoding):\
  `SPM9G3CNGSCTB4956290NESM0MR9W9CCEPVEPSQC`

{% hint style="info" %}
The private/public key generation uses the cryptographic **secp256k1** curve.

The cryptographic signature algorithm used in Stacks is **ECDSA** over **secp256k1**.
{% endhint %}

Stacks accounts are entities that own assets, like Stacks (STX) tokens. An account has an address, private key, nonce, and one or more asset balances. Assets cannot leave an account without an action from the account owner. All changes to assets (and the balances of the account) require a corresponding transaction.

All Stacks wallets also support Bitcoin addresses, enabling seamless participation across both the Stacks and Bitcoin ecosystems.

***

### Creation

An wallet's accounts are generated from a 24-word mnemonic phrase conforming to the BIP39 standard. This is often referred to as the **seed phrase**. The seed phrase provides access to Stacks accounts.

{% hint style="danger" %}
If the seed phrase is lost, access to the associated account cannot be restored. No person or organization can recover a lost seed phrase.
{% endhint %}

The easiest way to generate a new Stacks account is to use the [Stacks CLI](https://github.com/stx-labs/stacks.js/tree/master/packages/cli):

{% code title="Generate a new account (CLI)" %}

```bash
# install CLI globally
npm install --global @stacks/cli

# generate a new account and store details in a new file

# '-t' option makes this a testnet account
stx make_keychain -t > cli_keychain.json
```

{% endcode %}

`make_keychain` creates the following file:

```js
{
  "mnemonic": "aaa bbb ccc ddd ...",
  "keyInfo": {
    "privateKey": "5a3f1f15245bb3fb...",
    "address": "STJRM2AMVF90ER6G3RW1QTF85E3HZH37006D5ER1",
    "btcAddress": "biwSd6KTEvJcyX2R8oyfgj5REuLzczMYC1",
    "wif": "L4HXn7PLmzoNW...",
    "index": 0
  }
}
```

{% hint style="info" %}
Check out the [Stacks CLI reference](https://docs.hiro.so/references/stacks-cli) for more details
{% endhint %}

| Field                | Description                                                                                                                                                        |
| -------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `mnemonic`           | A 24-word seed phrase used to access the account, generated using [BIP39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki) with 256 bits of entropy |
| `keyInfo.privateKey` | Private key for the account. Required for token transfers and often referred to as `senderKey`                                                                     |
| `keyInfo.address`    | Stacks address for the account                                                                                                                                     |
| `keyInfo.btcAddress` | Corresponding BTC address for the account.                                                                                                                         |
| `keyInfo.wif`        | Private key of the btcAddress in compressed format.                                                                                                                |
| `keyInfo.index`      | Nonce for the account, starting at 0                                                                                                                               |

Note that a new account automatically exists for each new private key. There is no need to manually instantiate an account on the Stacks blockchain.

{% hint style="info" %}
Addresses are created by generating the [RIPEMD-160 hash](https://en.wikipedia.org/wiki/RIPEMD#RIPEMD-160_hashes) of the [SHA256](https://en.bitcoinwiki.org/wiki/SHA-256) of the public key. BTC addresses are encoded with [Base58Check](https://bitcoin.it/wiki/Base58Check_encoding). For Stacks addresses, [c32check](https://github.com/stacks-network/c32check) is used. Deriving an address from a public key can be done without internet access, for instance using the c32check `c32addressDecode` method.
{% endhint %}

Alternatively to the CLI creation, the [Stacks Transactions JS](https://github.com/stx-labs/stacks.js/tree/master/packages/transactions) library can be used:

{% code title="Generate a private key & derive address (transactions library)" %}

```js
import {
  makeRandomPrivKey,
  privateKeyToString,
  getAddressFromPrivateKey,
  TransactionVersion,
  getPublicKey,
} from "@stacks/transactions";

const privateKey = makeRandomPrivKey();

// Get public key from private
const publicKey = getPublicKey(privateKey);

const stacksAddress = getAddressFromPrivateKey(
  privateKeyToString(privateKey),
  TransactionVersion.Testnet // remove for Mainnet addresses
);
```

{% endcode %}

Finally, you can generate new account using a Stacks-enabled wallet like [Leather](https://leather.io/), [Xverse](https://www.xverse.app/), or [Asigna](https://asigna.io/).

***

### Handling different formats

It's common for new Stacks developers to get tripped up on the different ways when specifying Stacks' principals (aka addresses) in their development.

Here's a breakdown of dealing with principals in 3 different use cases.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2F9habwlXLqQ25fu6TUVM5%2Fhandling-principal-formats.jpeg?alt=media&#x26;token=08fcc12c-ee57-48e9-9ab5-a18233773fe2" alt=""><figcaption></figcaption></figure></div>

***

### The Stacks and Bitcoin address connection

What makes Stacks beautifully connected to its L1 settlement layer, Bitcoin, is their many shared aspects. One being how both utilize a similar address generation scheme based on the P2PKH format, which allows for both a Bitcoin & Stacks address to share the same public key hash. If you base58check decode a legacy bitcoin address, you can reveal the public key hash, which can then be used to generate its respective c32check encoded Stacks address.

Programmatically, you could also use a method called `b58ToC32`, from the `c32check` javascript library, which can abstract the conversion for you.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2FVqWJul0cMmHoNGXiwsg3%2Fbitcoin-stacks-address-connection.jpeg?alt=media&#x26;token=90fe1ed0-29dc-4a1f-a2d4-0a89d57acc23" alt=""><figcaption></figcaption></figure></div>

***

### Additional Resources

* \[[Hiro Blog](https://www.hiro.so/blog/understanding-the-differences-between-bitcoin-address-formats-when-developing-your-app)] Understanding the Differences Between Bitcoin Address Formats When Developing Your App
* \[[Hiro Blog](https://www.hiro.so/blog/how-every-stacks-address-has-a-corresponding-bitcoin-address)] How Every Stacks Address Has a Corresponding Bitcoin Address&#x20;
* \[[Hiro Blog](https://www.hiro.so/blog/an-intro-to-web3-wallets-for-web3-founders)] An Intro to Web3 Wallets for Web3 Founders
* \[[Hiro Blog](https://www.hiro.so/blog/why-web3-needs-bitcoin-centric-wallet-standards)] Why Web3 Needs Bitcoin-Centric Wallet Standards


# Authentication

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-b5725bb6dcf6851197f3b5508e1addb40c1fa1be%2Fimage.png?alt=media" alt=""><figcaption><p>source: <a href="https://www.hiro.so/blog/how-to-authenticate-your-users">Hiro blog</a></p></figcaption></figure>

### Introduction

This guide explains how authentication is performed on the Stacks blockchain.

Authentication provides a way for users to identify themselves to an app while retaining complete control over their credentials and personal details.

Users who register for your app can subsequently authenticate to any other app with support for the [Bitcoin Name System](https://docs.stacks.co/learn/network-fundamentals/bitcoin-name-system) and vice versa.

### Web2 vs Web3 Authentication

If you come from the web2 world, you are likely used to authenticating with usernames and passwords, where the user's info is stored in a database. Upon entering the password, it is hashed and compared to the hash stored in the database and, if it matches, the user is logged in.

Web3 authentication works a bit differently. One of the core philosophies of web3 is data ownership, which means users are in control of their data, including their authentication.

Authentication in the Bitcoin and Stacks world makes use of cryptography to generate private keys, public keys and addresses.

We'll go over the basics here, but if you want to dig in, [Learn Me a Bitcoin](https://learnmeabitcoin.com/beginners/guide/keys-addresses/) is a great place to start.

To generate a Stacks account, we generate a private key from a 24 word mnemonic phrase, as discussed in the previous section. This private key is then used to generate a public key using a one-way hash function. Meaning you can derive a public key from a private key, but not vice versa.

A user's private key is their main source of security and is used to authenticate them. Do not lose your private key.

So, when I use a wallet app like [Leather](https://leather.io/) and I want to use it to authenticate with a dapp like StackingDAO, what I am doing is that I am giving my wallet my private key, proving that I own the corresponding address.

The wallet will then pass that information (my address and public key) to the app along with a signature.

A signature can be thought of as proof that I own the private key without actually revealing the private key. That mechanism is how I can use the same wallet and address to log in to any app that supports Stacks authentication.

Third Web has a great [conceptual primer](https://blog.thirdweb.com/web3-auth/) on web3 authentication.

For a more practical introduction, take a look at the [Quickstart tutorial ](https://app.gitbook.com/o/hoh4mQXTl8NvI3cETroY/s/Zz9BLmTU9oydDpL3qiUh/)and [Hiro's Stacks.js docs](https://docs.hiro.so/stacks/connect/guides/authenticate-users).

### How it works

The authentication flow with Stacks is similar to the typical client-server flow used by centralized sign in services (for example, OAuth). However, with Stacks the authentication flow happens entirely client-side.

{% hint style="info" %}
This explanation is here so you can understand how this process works, but the bulk of this functionality is handled by the wallet and the JS library you use. Take a look at the [Stacks.js docs](https://docs.hiro.so/stacks/stacks.js/concepts/accounts-and-addresses) for more info.
{% endhint %}

An app and authenticator, such as the [Leather wallet](https://leather.io/), communicate during the authentication flow by passing back and forth two tokens. The requesting app sends the authenticator an `authRequest` token. Once a user approves authentication, the authenticator responds to the app with an `authResponse` token.

These tokens are based on [a JSON Web Token (JWT) standard](https://tools.ietf.org/html/rfc7519) with additional support for the `secp256k1` curve used by Bitcoin and many other cryptocurrencies. They are passed via URL query strings.

When a user chooses to authenticate an app, it sends the `authRequest` token to the authenticator via a URL query string with an equally named parameter:

`https://wallet.hiro.so/...?authRequest=j902120cn829n1jnvoa...`

When the authenticator receives the request, it generates an `authResponse` token for the app using an ephemeral transit key. The ephemeral transit key is just used for the particular instance of the app, in this case, to sign the `authRequest`.

The app stores the ephemeral transit key during request generation. The public portion of the transit key is passed in the `authRequest` token. The authenticator uses the public portion of the key to encrypt an app private key which is returned via the `authResponse`.

The authenticator generates the app private key from the user's identity address private key and the app's domain. The app private key serves three functions:

{% stepper %}
{% step %}
**It is used to create credentials that give the app access to a storage bucket in the user's Gaia hub**

This allows the app to access the user's app-specific storage in their Gaia hub.
{% endstep %}

{% step %}
**It is used in the end-to-end encryption of files stored for the app in the user's Gaia storage**

This key is used to encrypt files so only the app (with the derived key) can decrypt them.
{% endstep %}

{% step %}
**It serves as a cryptographic secret that apps can use to perform other cryptographic functions**

Apps can use this deterministic secret for additional cryptographic operations tied to the user's identity and domain.
{% endstep %}
{% endstepper %}

Finally, the app private key is deterministic, meaning that the same private key will always be generated for a given Stacks address and domain.

### Key pairs

Authentication with Stacks makes extensive use of public key cryptography generally and ECDSA with the `secp256k1` curve in particular.

The following sections describe the three public-private key pairs used, including how they're generated, where they're used and to whom private keys are disclosed.

#### Transit private key

The transit private key is an ephemeral key that is used to encrypt secrets that need to be passed from the authenticator to the app during the authentication process. It is randomly generated by the app at the beginning of the authentication response.

The public key that corresponds to the transit private key is stored in a single element array in the `public_keys` key of the authentication request token. The authenticator encrypts secret data such as the app private key using this public key and sends it back to the app when the user signs in to the app. The transit private key signs the app authentication request.

#### Identity address private key

The identity address private key is derived from the user's keychain phrase and is the private key of the Stacks username that the user chooses to use to sign in to the app. It is a secret owned by the user and never leaves the user's instance of the authenticator.

This private key signs the authentication response token for an app to indicate that the user approves sign in to that app.

#### App private key

The app private key is an app-specific private key that is generated from the user's identity address private key using the `domain_name` as input.

The app private key is securely shared with the app on each authentication, encrypted by the authenticator with the transit public key. Because the transit key is only stored on the client side, this prevents a man-in-the-middle attack where a server or internet provider could potentially snoop on the app private key.


# Bitcoin Name System

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-402906fc4f7e845fcfdf66d4752cf3674090b37e%2Fimage.png?alt=media" alt=""><figcaption><p>source: <a href="https://www.hiro.so/blog/getting-started-on-chain-usernames-stacks">Hiro blog</a></p></figcaption></figure>

Bitcoin Name System (BNS) is a network system that binds Stacks usernames to off-chain state without relying on any central points of control.

The Stacks V1 blockchain implemented BNS through first-order name operations. In Stacks V2, BNS is instead implemented through a smart-contract loaded during the genesis block.

Names in BNS have three properties:

* **Names are globally unique.** The protocol does not allow name collisions, and all well-behaved nodes resolve a given name to the same state.
* **Names are human-meaningful.** Each name is chosen by its creator.
* **Names are strongly owned.** Only the name's owner can change the state it resolves to. Specifically, a name is owned by one or more ECDSA private keys.

The Stacks blockchain ensures that each node's BNS view is synchronized to all of the other nodes in the world, so queries on one node will be the same on other nodes. Stacks blockchain nodes allow a name's owner to bind up to 40Kb of off-chain state to their name, which will be replicated to all other Stacks blockchain nodes via a P2P network.

The biggest consequence for developers is that in BNS, reading name state is fast and cheap but writing name state is slow and expensive. This is because registering and modifying names requires one or more transactions to be sent to the underlying blockchain, and BNS nodes will not process them until they are sufficiently confirmed. Users and developers need to acquire and spend the requisite cryptocurrency (STX) to send BNS transactions.

### Motivation behind name systems

We rely on name systems in everyday life, and they play a critical role in many different applications. For example, when you look up a friend on social media, you are using the platform's name system to resolve their name to their profile. When you look up a website, you are using the Domain Name Service to resolve the hostname to its host's IP address. When you check out a Git branch, you are using your Git client to resolve the branch name to a commit hash. When you look up someone's PGP key on a keyserver, you are resolving their key ID to their public key.

What kinds of things do we want to be true about names? In BNS, names are globally unique, names are human-meaningful, and names are strongly owned. However, if you look at these examples, you'll see that each of them only guarantees two of these properties. This limits how useful they can be.

* In DNS and social media, names are globally unique and human-readable, but not strongly owned. The system operator has the final say as to what each name resolves to.
  * Problem: Clients must trust the system to make the right choice in what a given name resolves to. This includes trusting that no one but the system administrators can make these changes.
* In Git, branch names are human-meaningful and strongly owned, but not globally unique. Two different Git nodes may resolve the same branch name to different unrelated repository states.
  * Problem: Since names can refer to conflicting state, developers have to figure out some other mechanism to resolve ambiguities.
* In PGP, names are key IDs. They are globally unique and cryptographically owned, but not human-readable. PGP key IDs are derived from the keys they reference.
  * Problem: These names are difficult for most users to remember since they do not carry semantic information relating to their use in the system.

BNS names have all three properties, and none of these problems. This makes it a powerful tool for building all kinds of network applications. With BNS, we can do the following and more:

* Build domain name services where hostnames can't be hijacked.
* Build social media platforms where user names can't be stolen by phishers.
* Build version control systems where repository branches do not conflict.
* Build public-key infrastructure where it's easy for users to discover and remember each other's keys.

### Organization of BNS

BNS names are organized into a global name hierarchy. There are three different layers in this hierarchy related to naming:

* **Namespaces.** These are the top-level names in the hierarchy. An analogy to BNS namespaces are DNS top-level domains. Existing BNS namespaces include `.id`, `.podcast`, and `.helloworld`. All other names belong to exactly one namespace. Anyone can create a namespace, but in order for the namespace to be persisted, it must be *launched* so that anyone can register names in it. Namespaces are not owned by their creators.
* **BNS names.** These are names whose records are stored directly on the blockchain. The ownership and state of these names are controlled by sending blockchain transactions. Example names include `verified.podcast` and `muneeb.id`. Anyone can create a BNS name, as long as the namespace that contains it exists already.
* **BNS subdomains.** These are names whose records are stored off-chain, but are collectively anchored to the blockchain. The ownership and state for these names lives within the P2P network data. While BNS subdomains are owned by separate private keys, a BNS name owner must broadcast their subdomain state. Example subdomains include `jude.personal.id` and `podsaveamerica.verified.podcast`. Unlike BNS namespaces and names, the state of BNS subdomains is *not* part of the blockchain consensus rules.

A feature comparison matrix summarizing the similarities and differences between these name objects:

| Feature                                | **Namespaces** | **BNS names** | **BNS Subdomains** |
| -------------------------------------- | -------------- | ------------- | ------------------ |
| Globally unique                        | X              | X             | X                  |
| Human-meaningful                       | X              | X             | X                  |
| Owned by a private key                 |                | X             | X                  |
| Anyone can create                      | X              | X             | \[1]               |
| Owner can update                       |                | X             | \[1]               |
| State hosted on-chain                  | X              | X             |                    |
| State hosted off-chain                 |                | X             | X                  |
| Behavior controlled by consensus rules | X              | X             |                    |
| May have an expiration date            |                | X             |                    |

\[1] Requires the cooperation of a BNS name owner to broadcast its transactions

### Namespaces

Namespaces are the top-level name objects in BNS. They control a few properties about the names within them:

* How expensive they are to register
* How long they last before they have to be renewed
* Who (if anyone) receives the name registration fees
* Who is allowed to seed the namespace with its initial names

At the time of this writing, by far the largest BNS namespace is the `.id` namespace. Names in the `.id` namespace are meant for resolving user identities. Short names in `.id` are more expensive than long names, and have to be renewed by their owners every two years. Name registration fees are not paid to anyone in particular—they are instead sent to a "black hole" where they are rendered non-spendable (the intention is to discourage ID squatters).

Unlike DNS, anyone can create a namespace and set its properties. Namespaces are created on a first-come first-serve basis, and once created, they last forever.

However, creating a namespace is not free. The namespace creator must burn cryptocurrency to do so. The shorter the namespace, the more cryptocurrency must be burned (that is, short namespaces are more valuable than long namespaces). For example, it cost Blockstack PBC 40 BTC to create the `.id` namespace in 2015 (in transaction `5f00b8e609821edd6f3369ee4ee86e03ea34b890e242236cdb66ef6c9c6a1b281`).

Namespaces can be between 1 and 19 characters long, and are composed of the characters `a-z`, `0-9`, `-`, and `_`.

### Subdomains

BNS names are strongly owned because the owner of its private key can generate valid transactions that update its zone file hash and owner. However, this comes at the cost of requiring a name owner to pay for the underlying transaction in the blockchain. Moreover, this approach limits the rate of BNS name registrations and operations to the underlying blockchain's transaction bandwidth.

BNS overcomes this with subdomains. A **BNS subdomain** is a type of BNS name whose state and owner are stored outside of the blockchain, but whose existence and operation history are anchored to the blockchain. Like their on-chain counterparts, subdomains are globally unique, strongly owned, and human-readable. BNS gives them their own name state and public keys. Unlike on-chain names, subdomains can be created and managed cheaply, because they are broadcast to the BNS network in batches. A single blockchain transaction can send up to 120 subdomain operations.

This is achieved by storing subdomain records in the BNS name zone files. An on-chain name owner broadcasts subdomain operations by encoding them as `TXT` records within a DNS zone file. To broadcast the zone file, the name owner sets the new zone file hash with a `NAME_UPDATE` transaction and replicates the zone file. This, in turn, replicates all subdomain operations it contains, and anchors the set of subdomain operations to an on-chain transaction. The BNS node's consensus rules ensure that only valid subdomain operations from valid `NAME_UPDATE` transactions will ever be stored.

For example, the name `verified.podcast` once wrote the zone file hash `247121450ca0e9af45e85a82e61cd525cd7ba023`, which is the hash of the following zone file:

```bash
$TTL 3600
1yeardaily TXT "owner=1MwPD6dH4fE3gQ9mCov81L1DEQWT7E85qH" "seqn=0" "parts=1" "zf0=JE9SSUdJTiAxeWVhcmRhaWx5CiRUVEwgMzYwMApfaHR0cC5fdGNwIFVSSSAxMCAxICJodHRwczovL3BoLmRvdHBvZGNhc3QuY28vMXllYXJkYWlseS9oZWFkLmpzb24iCg=="
2dopequeens TXT "owner=1MwPD6dH4fE3gQ9mCov81L1DEQWT7E85qH" "seqn=0" "parts=1" "zf0=JE9SSUdJTiAyZG9wZXF1ZWVucwokVFRMIDM2MDAKX2h0dHAuX3RjcCBVUkkgMTAgMSAiaHR0cHM6Ly9waC5kb3Rwb2RjYXN0LmNvLzJkb3BlcXVlZW5zL2hlYWQuanNvbiIK"
10happier TXT "owner=1MwPD6dH4fE3gQ9mCov81L1DEQWT7E85qH" "seqn=0" "parts=1" "zf0=JE9SSUdJTiAxMGhhcHBpZXIKJFRUTCAzNjAwCl9odHRwLl90Y3AgVVJJIDEwIDEgImh0dHBzOi8vcGguZG90cG9kY2FzdC5jby8xMGhhcHBpZXIvaGVhZC5qc29uIgo="
31thoughts TXT "owner=1MwPD6dH4fE3gQ9mCov81L1DEQWT7E85qH" "seqn=0" "parts=1" "zf0=JE9SSUdJTiAzMXRob3VnaHRzCiRUVEwgMzYwMApfaHR0cC5fdGNwIFVSSSAxMCAxICJodHRwczovL3BoLmRvdHBvZGNhc3QuY28vMzF0aG91Z2h0cy9oZWFkLmpzb24iCg=="
359 TXT "owner=1MwPD6dH4fE3gQ9mCov81L1DEQWT7E85qH" "seqn=0" "parts=1" "zf0=JE9SSUdJTiAzNTkKJFRUTCAzNjAwCl9odHRwLl90Y3AgVVJJIDEwIDEgImh0dHBzOi8vcGguZG90cG9kY2FzdC5jby8zNTkvaGVhZC5qc29uIgo="
30for30 TXT "owner=1MwPD6dH4fE3gQ9mCov81L1DEQWT7E85qH" "seqn=0" "parts=1" "zf0=JE9SSUdJTiAzMGZvcjMwCiRUVEwgMzYwMApfaHR0cC5fdGNwIFVSSSAxMCAxICJodHRwczovL3BoLmRvdHBvZGNhc3QuY28vMzBmb3IzMC9oZWFkLmpzb24iCg=="
onea TXT "owner=1MwPD6dH4fE3gQ9mCov81L1DEQWT7E85qH" "seqn=0" "parts=1" "zf0=JE9SSUdJTiBvbmVhCiRUVEwgMzYwMApfaHR0cC5fdGNwIFVSSSAxMCAxICJodHRwczovL3BoLmRvdHBvZGNhc3QuY28vb25lYS9oZWFkLmpzb24iCg=="
10minuteteacher TXT "owner=1MwPD6dH4fE3gQ9mCov81L1DEQWT7E85qH" "seqn=0" "parts=1" "zf0=JE9SSUdJTiAxMG1pbnV0ZXRlYWNoZXIKJFRUTCAzNjAwCl9odHRwLl90Y3AgVVJJIDEwIDEgImh0dHBzOi8vcGguZG90cG9kY2FzdC5jby8xMG1pbnV0ZXRlYWNoZXIvaGVhZC5qc29uIgo="
36questionsthepodcastmusical TXT "owner=1MwPD6dH4fE3gQ9mCov81L1DEQWT7E85qH" "seqn=0" "parts=1" "zf0=JE9SSUdJTiAzNnF1ZXN0aW9uc3RoZXBvZGNhc3RtdXNpY2FsCiRUVEwgMzYwMApfaHR0cC5fdGNwIFVSSSAxMCAxICJodHRwczovL3BoLmRvdHBvZGNhc3QuY28vMzZxdWVzdGlvbnN0aGVwb2RjYXN0bXVzaWNhbC9oZWFkLmpzb24iCg=="
_http._tcp URI 10 1 "https://dotpodcast.co/"
```

Each `TXT` record in this zone file encodes a subdomain-creation. For example, `1yeardaily.verified.podcast` resolves to:

```json
{
  "address": "1MwPD6dH4fE3gQ9mCov81L1DEQWT7E85qH",
  "blockchain": "bitcoin",
  "last_txid": "d87a22ebab3455b7399bfef8a41791935f94bc97aee55967edd5a87f22cce339",
  "status": "registered_subdomain",
  "zonefile_hash": "e7acc97fd42c48ed94fd4d41f674eddbee5557e3",
  "zonefile_txt": "$ORIGIN 1yeardaily\n$TTL 3600\n_http._tcp URI 10 1 \"https://ph.dotpodcast.co/1yeardaily/head.json\"\n"
}
```

This information was extracted from the `1yeardaily` `TXT` resource record in the zone file for `verified.podcast`.

Subdomain lifecycle

{% stepper %}
{% step %}
**Creation**

A subdomain-creation operation is created by the subdomain owner and encoded into a `TXT` record in an on-chain name owner's zone file. The on-chain name owner broadcasts the zone file by issuing a `NAME_UPDATE` transaction, which anchors the subdomain-creation on-chain.
{% endstep %}

{% step %}
**Update**

Subdomain updates are done off-chain by creating signed operations from the subdomain owner's private key. Any on-chain name owner can include these signed operations in their zone file and broadcast via `NAME_UPDATE`. Operations are ordered by a sequence number and require a valid signature that links to the previous operation's public key.
{% endstep %}

{% step %}
**Transfer**

To change the address (public key hash) owning a subdomain, the subdomain owner signs a subdomain-transfer operation and asks an on-chain name owner (typically the one who created the subdomain) to broadcast it via `NAME_UPDATE`. The broadcasting on-chain name owner's zone file must be present in the Atlas network to prove absence of conflicting operations.
{% endstep %}
{% endstepper %}

Sequence and validation rules

* Subdomain operations are ordered by sequence number, starting at 0. Each new operation must include:
  * The next sequence number
  * The public key that hashes to the previous subdomain transaction's address
  * A signature from the corresponding private key over the entire subdomain operation
* If two correctly signed but conflicting operations have the same sequence number, the one earlier in blockchain history is accepted. Invalid operations are ignored.

Subdomain creation and management rules

* A subdomain-creation transaction can only be processed by the owner of the on-chain name that shares its suffix (e.g., only the owner of `res_publica.id` can broadcast creations for `*.res_publica.id`).
* A subdomain-transfer transaction can only be broadcast by the owner of the on-chain name that created it.
* To send a subdomain-creation or subdomain-transfer, all of an on-chain name owner's zone files must be present in the Atlas network. This allows proving the absence of conflicting operations.
* A subdomain update can be broadcast by any on-chain name owner, but the subdomain owner needs to find a cooperating on-chain name owner to include and broadcast it.

To create a subdomain, the subdomain owner generates the creation operation and gives it to the on-chain name owner. Once created, the subdomain owner can use any on-chain name owner to broadcast updates by providing signed operations packaged into zone files.

Subdomain registrars

Because subdomain names are cheap, developers may run subdomain registrars for their applications. For example, the name `personal.id` is used to register usernames without requiring users to spend Bitcoin.

A reference implementation is available: <https://github.com/stacks-network/subdomain-registrar>. Users still own their subdomain names; the registrar helps developers broadcast subdomain operations.

### BNS and DID Standards

BNS names are compliant with the emerging Decentralized Identity Foundation (DIF) protocol specification for decentralized identifiers (DIDs): <http://identity.foundation>

Each name in BNS has an associated DID. The DID format for BNS is:

```bash
did:stack:v0:{address}-{index}
```

Where:

* `{address}` is an on-chain public key hash (for example a Bitcoin address).
* `{index}` refers to the `nth` name this address created.

Examples:

* `personal.id` → `did:stack:v0:1dARRtzHPAFRNE7Yup2Md9w18XEQAtLiV-0` (first name created by that address)
* `jude.id` → `did:stack:v0:16EMaNw3pkn3v6f2BgnSSs53zAKH4Q8YJg-1` (the address had created one earlier name before this one)

Purpose: a DID provides an eternal identifier for a public key. The public key may change, but the DID will not.

For a DID to be resolvable, all of the following must be true for a name:

* The name must exist
* The name's zone file hash must be the hash of a well-formed DNS zone file
* The DNS zone file must be present in the Stacks node's data
* The DNS zone file must contain a `URI` resource record that points to a signed JSON Web Token
* The public key that signed the JSON Web Token (and is included with it) must hash to the address that owns the name

Not all names will have DIDs that resolve to public keys. Names created by standard tooling will have DIDs that do.

A RESTful API is under development.

### DID Encoding for Subdomains

Every name and subdomain in BNS has a DID. Encoding differs so software can determine which code-path to take.

* For on-chain BNS names, the `{address}` is the same as the Bitcoin address that owns the name. Currently, both version byte 0 and version byte 5 addresses are supported (addresses starting with `1` or `3`, meaning `p2pkh` and `p2sh` addresses).
* For off-chain BNS subdomains, the `{address}` has version byte 63 for subdomains owned by a single private key, and version byte 50 for subdomains owned by an m-of-n set of private keys. That is, subdomain DID addresses start with `S` or `M`, respectively.

The `{index}` field for a subdomain's DID is distinct from the `{index}` field for a BNS name's DID, even if the same address created both names and subdomains. Example:

* The name `abcdefgh123456.id` → `did:stack:v0:16EMaNw3pkn3v6f2BgnSSs53zAKH4Q8YJg-0` (first name created by that address)
* The subdomain `jude.statism.id` created by the same address → `did:stack:v0:SSXMcDiCZ7yFSQSUj7mWzmDcdwYhq97p2i-0`

Note: The address `SSXMcDiCZ7yFSQSUj7mWzmDcdwYhq97p2i` encodes the same public key hash as `16EMaNw3pkn3v6f2BgnSSs53zAKH4Q8YJg`—the difference is base58check version byte (63 vs 0).


# SIPs

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-572743764da9de034230b5391cab0ddf4ef89337%2Fimage.png?alt=media" alt=""><figcaption><p>source: <a href="https://www.hiro.so/blog/announcing-hiros-token-metadata-api">Hiro blog</a></p></figcaption></figure>

### Stacks Improvement Proposals (SIPs)

Stacks improvement proposals (SIPs) are aimed at describing the implementation of the Stacks blockchain, as well as proposing improvements.

The SIP process [(SIP-000)](https://github.com/stacksgov/sips/blob/main/sips/sip-000/sip-000-stacks-improvement-proposal-process.md) describes how to make a SIP and get it ratified.

They should contain concise technical specifications of features or standards and the rationale behind it. SIPs are intended to be the primary medium for proposing new features, for collecting community input on a system-wide issue, and for documenting design decisions.

The SIPs are located in the [stacksgov/sips](https://github.com/stacksgov/sips) repository as part of the [Stacks Community Governance organization](https://github.com/stacksgov).

Anyone in the Stacks community can submit a SIP.

{% hint style="info" %}
Stacks Improvement Proposals Community Calls Add the [weekly community SIP call](https://www.addevent.com/event/wS15955379) to your calendar.

SIP Meeting calls are recorded and available [here](https://www.youtube.com/playlist?list=PLg717Ri_rTnx5kuaWqp3cUAtwQk_yzslT)

More details of the meetings are available [here](https://github.com/stacksgov/sips/issues/79)
{% endhint %}

### Ratified SIPSs

* [x] [SIP 000: Improvement Proposal Process](https://github.com/stacksgov/sips/blob/main/sips/sip-000/sip-000-stacks-improvement-proposal-process.md)
* [x] [SIP 001: Burn Election](https://github.com/stacksgov/sips/blob/main/sips/sip-001/sip-001-burn-election.md)
* [x] [SIP 002: Clarity, a language for predictable smart contracts](https://github.com/stacksgov/sips/blob/main/sips/sip-002/sip-002-smart-contract-language.md)
* [x] [SIP 003: Peer Network](https://github.com/stacksgov/sips/blob/main/sips/sip-003/sip-003-peer-network.md)
* [x] [SIP 004: Cryptographic Commitment to Materialized Views](https://github.com/stacksgov/sips/blob/main/sips/sip-004/sip-004-materialized-view.md)
* [x] [SIP 005: Blocks, Transactions, and Accounts](https://github.com/stacksgov/sips/blob/main/sips/sip-005/sip-005-blocks-and-transactions.md)
* [x] [SIP 006: Clarity Execution Cost Assessment](https://github.com/stacksgov/sips/blob/main/sips/sip-006/sip-006-runtime-cost-assessment.md)
* [x] [SIP 007: Stacking Consensus](https://github.com/stacksgov/sips/blob/main/sips/sip-007/sip-007-stacking-consensus.md)
* [x] [SIP 008: Clarity Parsing and Analysis Cost Assessment](https://github.com/stacksgov/sips/blob/main/sips/sip-008/sip-008-analysis-cost-assessment.md)
* [x] [SIP 009: Standard Trait Definition for Non-Fungible Tokens](https://github.com/stacksgov/sips/blob/main/sips/sip-009/sip-009-nft-standard.md)
* [x] [SIP 010: Standard Trait Definition for Fungible Tokens](https://github.com/stacksgov/sips/blob/main/sips/sip-010/sip-010-fungible-token-standard.md)
* [x] [SIP 012: Burn Height Selection for a Network Upgrade to Introduce New Cost-Limits](https://github.com/stacksgov/sips/blob/main/sips/sip-012/sip-012-cost-limits-network-upgrade.md)
* [x] [SIP 013: Standard Trait Definition for Semi-Fungible Tokens](https://github.com/stacksgov/sips/blob/main/sips/sip-013/sip-013-semi-fungible-token-standard.md)
* [x] [SIP-015: Stacks Upgrade of Proof-of-Transfer and Clarity](https://github.com/stacksgov/sips/blob/main/sips/sip-015/sip-015-network-upgrade.md)
* [x] [SIP-016: Metadata for Tokens](https://github.com/stacksgov/sips/blob/main/sips/sip-016/sip-016-token-metadata.md)
* [x] [SIP-018: Signed Structured Data](https://github.com/stacksgov/sips/blob/main/sips/sip-018/sip-018-signed-structured-data.md)
* [x] [SIP-019: Notifications for Token Metadata Updates](https://github.com/stacksgov/sips/blob/main/sips/sip-019/sip-019-token-metadata-update-notifications.md)
* [x] [SIP-020: Bitwise Operations in Clarity](https://github.com/stacksgov/sips/blob/main/sips/sip-020/sip-020-bitwise-ops.md)
* [x] [SIP-022: Emergency Fix to PoX Stacking Increases](https://github.com/stacksgov/sips/blob/main/sips/sip-022/sip-022-emergency-pox-fix.md)
* [x] [SIP-023: Emergency Fix to Trait Invocation Behavior](https://github.com/stacksgov/sips/blob/main/sips/sip-023/sip-023-emergency-fix-traits.md)
* [x] [SIP-024: Emergency Fix to Data Validation and Serialization Behavior](https://github.com/stacksgov/sips/blob/main/sips/sip-024/sip-024-least-supertype-fix.md)

### How to Get Involved

There are several ways you can get involved with the SIP process:

* **Join the weekly SIP Meeting call** listed [here](https://community.stacks.org/events).
* **SIP Editor**. SIP editors help SIP authors make sure their SIPs are well-formed and follow the right process. They help get SIPs ready for deep review by advancing it them from Draft to Accepted status. If you want to become a SIP editor, open an issue with your name and email to ask to be added to the list of SIP editors.
* **Join a CAB** (Consideration Advisory Board). SIPs fall under the purview of one or more considerations. A full list is in [this github](https://github.com/stacksgov/sips/tree/main/considerations) directory. Currently they are: Diversity, Economics, Ethics, Governance and Technical. Members of SIP consideration advisory boards use their domain expertise to give Accepted SIPs a deep read, and give the authors any/all feedback to help make the SIP workable. If you want to join a board, reach out to the board's chairperson via the listed contact information.
* **Steering Committee**. The Steering Committee organizes the consideration advisory boards and votes to advance Recommended SIPs to Activation-in-Progress status, and then to either Ratified or Rejected status. Once they are in the process of being activated, they use a SIP's Activation section to determine whether or not the Stacks ecosystem has ratified or rejected the SIP. Joining this committee requires the consent of the Stacks Foundation board.


# Technical Specifications

### Consensus

* Proof of Transfer (PoX) as described in [SIP-007](https://github.com/stacksgov/sips/blob/main/sips/sip-007/sip-007-stacking-consensus.md)
* Network will transition to Proof of Burn (PoB) as described in [SIP-001](https://github.com/stacksgov/sips/blob/main/sips/sip-001/sip-001-burn-election.md) after 10 years. [Learn more about Proof-of-Burn in SIP-001](https://github.com/stacksgov/sips/blob/main/sips/sip-001/sip-001-burn-election.md).
* Threat model
  * 51% of malicious Bitcoin mining power can reorg the Stacks chain or perform a double-spend attack
  * Chain can halt if Stackers cannot meet 70% consensus on block validity
* Different actors and their roles
  * Stacks Miners package transactions into blocks and propose them to stackers
  * Stacks Holders may alter the calculation of block limits (subject to a miner veto) and may vote to disable Proof-of-Transfer rewards for a reward cycle.
  * Stackers validate and append blocks to the chain and validate sBTC deposit and withdrawal transactions

### Proof of Transfer Mining

* Coinbase reward schedule:
  * 1000 STX/block for first 4 years
  * 500 STX/block for following 4 years
  * 250 STX/block for subsequent 4 years
  * 125 STX/block in perpetuity after that
* Coinbase rewards accumulate for "missed sortitions": If a Bitcoin block has no sortition (at height N), then any Stacks block mined in a subsequent sortition that builds off of any Stacks chain tip that existed at the penultimate sortition (at height N-1) may claim its coinbase. This encourages miners to keep mining even if Bitcoin fees are high.
* Initial mining bonus: This is a special case of the above to incentivize early miners. Coinbase for all burnchain blocks between the first burn block height (to be chosen by independent miners as part of the Stacks 2.0 launch) and the first sortition winner accumulate and are distributed to miners over a fixed window (to be determined). For instance, say burn block height is 10,000 and first sortition is at block 10500 and distribution window is 100 blocks, then coinbase for the first 500 blocks (10,500 - 10,000) will be distributed evenly to miners who win sortition over the subsequent 100 blocks.
* Reward maturity window: 100 blocks, meaning leaders will earn the coinbase reward 100 blocks after the block they successfully mine.
* Block interval: Stacks blockchain produces fast blocks roughly every 10 seconds with a miner tenure change occurring every Bitcoin block
* BTC commitment: Miners must commit at least 11,000 satoshis (5,500 sats / [UTXO output](https://learnmeabitcoin.com/technical/utxo)); 2 outputs / block) to avoid "dust."
* For more details, see Block Production.

### Stacking

{% stepper %}
{% step %}
**Prepare phase**

An "anchor block" is chosen. The qualifying set of addresses ("reward set") is determined based on the snapshot of the chain at the anchor block. Length of prepare phase is 100 blocks. Stacking commitments need to be confirmed before this phase starts.
{% endstep %}

{% step %}
**Reward phase**

Miner BTC commitments are distributed amongst the reward set. Reward cycle length is 2000 BTC blocks (\~2 weeks).
{% endstep %}
{% endstepper %}

* Two reward addresses / block, for a total of 4000 addresses every reward cycle. The addresses are chosen using a VRF (verifiable random function), so each node can deterministically arrive at the same reward addresses for a given block.
* Stacking threshold: 0.025% of the participating amount of STX when participation is between 25% and 100% and when participation is below 25%, the threshold level is always 0.00625 of the liquid supply of STX.
* Delegation: An STX address can designate another address to participate in Stacking on its behalf. [Relevant section in SIP-007](https://github.com/stacksgov/sips/blob/main/sips/sip-007/sip-007-stacking-consensus.md#stacker-delegation).
* Pooling: STX holders that individually do not meet the Stacking threshold can pool together their holdings to participate in Stacking. To do this, STX holders must set the (optional) reward address to the "delegate address." For more details, see [this reference](https://docs.stacks.co/references/stacking-contract#delegate-stx).
* Legacy, SegWit, Native Segwit, and Taproot addresses are supported

### Accounts and Addresses

* Transactions in the Stacks blockchain originate from, are paid for by, and execute under the authority of accounts
* An account is fully specified by its address + nonce + assets
* Address contains 2 or 3 fields: 1 byte version, 20 byte public key hash (RIPEMD160(SHA256(input))), optional name (variable length, max 128 bytes)
* Two types of accounts: standard accounts are owned by one or more private keys; contract accounts are materialized when a smart-contract is instantiated (specified by the optional name field above)
* Nonce counts number of times an account has authorized a transaction. Starts at 0, valid authorization must include the *next* nonce value.
* Assets are a map of all asset types -- STX, any on-chain assets specified by a Clarity contract (for example NFTs) -- to quantities owned by that account.
* Accounts need not be explicit "created" or registered; all accounts implicitly exist and are instantiated on first-use.

### Transactions

* Transaction types: coinbase, token-transfer, contract-deploy, contract-call, tenure-change.
* Only standard accounts (not contracts) can pay transaction fees.
* Transaction execution is governed by:

{% stepper %}
{% step %}
**Originating account**

The account that creates, authorizes and sends the transaction.
{% endstep %}

{% step %}
**Paying account**

The account that is billed by the leader for the cost of validating and executing the transaction.
{% endstep %}

{% step %}
**Sending account**

The account that identifies who is currently executing the transaction: this can change as a transaction executes via the `as-contract` Clarity function.
{% endstep %}
{% endstepper %}

* Transactions can be batched or streamed into blocks. The behavior can be controlled by the anchor mode of a transaction. With streaming (microblocks), a faster confirmation time is possible.
* Two types of authorizations: standard authorization is where originating account is the same as paying account. *Sponsored* authorization is where originating account and paying account are distinct. For instance, developers or service providers could pay for users to call their smart-contracts.
* For sponsored authorization, first a user signs with the originating account and then a sponsor signs with the paying account.
* Mempool limit for concurrent pending transactions is 25 per account
* Pending mempool transactions will be garbage-collected [256 blocks after receipt](https://github.com/stacks-network/stacks-blockchain/blob/master/src/core/mempool.rs#L62). With 10 minutes target block time, this would equal \~42 hours
* [Learn more about transaction encoding in SIP-005](https://github.com/stacksgov/sips/blob/main/sips/sip-005/sip-005-blocks-and-transactions.md#transaction-encoding)
* [Transaction signing and verification are described in SIP-005](https://github.com/stacksgov/sips/blob/main/sips/sip-005/sip-005-blocks-and-transactions.md#transaction-signing-and-verifying)
* All transactions impacting account balance are atomic, a transfer operation can not increment one account’s balance without decrementing another’s. However, transactions that perform multiple account actions (for example, transferring from multiple accounts) may partially complete.
* Transactions can include a memo string (max 34 bytes)


# Audits

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-5e2e14ea3986509bfcb836fe9be357ca3b56106b%2Fimage.png?alt=media" alt=""><figcaption><p>source: <a href="https://www.hiro.so/blog/smart-contracts-cant-afford-to-fail-and-with-clarity-language-they-wont">Hiro blog</a></p></figcaption></figure>

#### Audits are just part of the story

For any project, layers of security are crucial. Audits represent one layer, while core developers and contributors collaborate to provide many more. Notable security programs, designs, and partners beyond audits include:

* Embedded security researchers [via Asymmetric Research](https://stacks.org/asymmetric-joins-stacks-ecosystem)
* Attackathon programs in partnership with Immunefi
* sBTC’s decentralized [network of validators/signers](https://www.stacks.co/sbtc) (removing the need to entrust a single entity and mitigating counterparty risk)
* Stacks’ underlying design that offers 100% Bitcoin finality, securing sBTC at the consensus level of a $2.5 billion network.
* Support at the app layer via [Hypernative](https://hackernoon.com/hypernative-bolsters-bitcoin-l2-security-as-stacks-ecosystem-gets-real-time-protection)
* Bitcoin L2 Labs' [whitehat security program](https://bitcoinl2-labs.github.io/2024/06/04/orange-hats.html)
* Stacks Foundation's partnership with Staking Defense League
* Stacks Founation's ongoing [Immunefi bug bounty program](https://immunefi.com/bug-bounty/stacks/information/)
* Dedicated Stacks Foundation Residents focused exclusively on fuzz and penetration testing (created [Rendezvous](https://stacks-network.github.io/rendezvous/))

{% hint style="warning" %}
*All 'high' or 'critical' issues listed in audits have either been mitigated or otherwise made obsolete, even if the report states otherwise.*
{% endhint %}

#### Stacks Core

Audits on Stacks Core

{% file src="<https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-150723b09151584d6e0acf37bae5cf3abbaac3f1%2FQuantstamp_Network%20State%20Machine.pdf?alt=media>" %}

{% file src="<https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-4a733d4e4ff9eb8f4d9e6f09f6f4c644796ff82c%2FCoinFabrik%20-%20Stacks%20Signer%20Audit.pdf?alt=media>" %}

{% file src="<https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-e9678769eadb5de09cc9a02c006f1fa9109657ad%2FCoinfabrik%20-%20Stacks%20PoX.pdf?alt=media>" %}

{% file src="<https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-6e1a11c2727047c85a12cc0df3730e665cd3f0e4%2FCoinFabrik%20-%20Stacks%20LibSigner.pdf?alt=media>" %}

{% file src="<https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-b0e846fba315845bd8e276bdf347ad90a119f9a0%2FCoinFabrik_StackerDB.pdf?alt=media>" %}

{% file src="<https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-dc059e72dc60cebf121d5e76e2eb926e11d0342d%2FCoinFabrik_Signer%20Binary.pdf?alt=media>" %}

#### Other audits

{% file src="<https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-cd00d448fac4fb740a472d0ae8264b46395e2afb%2FNCC_Group_Stacks_Wallet_Report_2020-11-17_v1.0.pdf?alt=media>" %}

{% file src="<https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-bed4f3bd8be8417603de69557d56f833c76466b0%2FNCC_Group_Stacks_Blockchain_Audit_Report_2020-11-23_v1.0.pdf?alt=media>" %}

{% file src="<https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-72b6b717bf79ab81a1223330095de6807ed63efe%2FBlockstack_Desktop_Wallet_Pentest_Report_11-12-2020.pdf?alt=media>" %}

Trail of Bits Report, Stacks Blockchain (No PDF, [Github Issues List provided](https://github.com/diwakergupta/stacks-blockchain-tob-audit/issues))


# Block Production

Block production is a key concept to understand how Stacks operates under the hood. This section walks through the three main actions that need to happen for the Stacks chain to operate.

{% stepper %}
{% step %}
**Mining**

Miners are responsible for building and proposing new blocks on the Stacks chain.
{% endstep %}

{% step %}
**Signing**

Signing is the process used to validate blocks and sign sBTC deposits and withdrawals. Stackers participate in signing once they meet stacking prerequisites.
{% endstep %}

{% step %}
**Stacking**

Stacking is an action performed by stackers that is a necessary prerequisite to signing. It enables participation in validation and earning rewards.
{% endstep %}
{% endstepper %}

There are two primary parties in Stacks block production: miners and stackers. Miners build and propose new blocks, while stackers validate those blocks and sign sBTC deposits and withdrawals. Stacking enables stackers to participate in signing.

{% hint style="info" %}
For an in-depth technical overview of block production after the Nakamoto Upgrade, see SIP-021:

<https://github.com/stacksgov/sips/blob/feat/sip-021-nakamoto/sips/sip-021/sip-021-nakamoto.md>
{% endhint %}

Here's a diagram outlining the block production process under Nakamoto rules. The following docs dig into each part in detail.

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-26036ee1fa63afce21d6b4a96771bbc4f8477c08%2Fimage.png?alt=media" alt=""><figcaption></figcaption></figure>


# Mining

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-27ae573accf25c7fed3398c1cce7321d3788c9eb%2Fimage.png?alt=media" alt=""><figcaption><p>source: <a href="https://www.hiro.so/blog">Hiro blog</a></p></figcaption></figure>

{% hint style="info" %}
This is conceptual guide that covers how mining works. For practical steps on how to setup your own miner please refer to the guides to running a miner on [mainnet](https://app.gitbook.com/s/4cpTb2lbw0LAOuMHrvhA/run-a-miner/mine-mainnet-stacks-tokens) and [testnet](https://app.gitbook.com/s/4cpTb2lbw0LAOuMHrvhA/run-a-miner/mine-testnet-stacks-tokens).
{% endhint %}

### Miner Tenures

In previous version of Stacks (before the Nakamoto Upgrade), Stacks miners would mine new Stacks blocks at a one-to-one cadence with Bitcoin blocks.

After Nakamoto, this is no longer the case. Under Nakamoto rules, miners are instead selected for a tenure that corresponds to a Bitcoin block. During this tenure, miners build and propose several Stacks blocks (roughly every 10 seconds) and stackers will approve and append them (next section).

To be considered for a tenure, a miner must have a block commit included in a Bitcoin block. If a miner wishes to update their commitment after submission, they may use Bitcoin Replace-By-Fee.

### Coinbase rewards

Miners receive coinbase rewards for tenures they win.

The reward amounts are:

* 1000 STX per tenure are released in the first 4 years of mining
* 500 STX per tenure are released during the following 4 years
* 250 STX per tenure are released during the following 4 years
* 125 STX per tenure are released from then on indefinitely.

These "halvings" are synchronized with Bitcoin halvings.

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-1df8dcc9ca886e6b787bc34ae896c1f7fae0a600%2Fimage.png?alt=media" alt=""><figcaption></figcaption></figure>

### Transaction fees

Miners receive Stacks fees for transactions mined in any block they produce.

### Reward maturity

Block rewards and transaction fees take 100 blocks on the Bitcoin blockchain to mature. After successfully mining a block your rewards appear in your Stacks account after \~24 hours.

### Mining with proof-of-transfer

Miners commit Bitcoin to **two** addresses in every leader block commit. The amount committed to each address must be the same. The addresses are chosen from the current reward set of stacking participants. Addresses are chosen using a verifiable-random-function, and determining the correct two addresses for a given block requires monitoring the Stacks chain.

For more detailed information on this process, read [SIP-007](https://github.com/stacksgov/sips/blob/main/sips/sip-007/sip-007-stacking-consensus.md), which describes proof of transfer in detail.

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-26b4e9ac6cc7d7af044042d0a9ddfedb6ce4bc4f%2Fimage.png?alt=media" alt=""><figcaption></figcaption></figure>

PoX mining is a modification of Proof-of-Burn (PoB) mining, where instead of sending the committed Bitcoin to a burn address, it's transferred to eligible STX holders that participate in the stacking protocol.

{% hint style="info" %}
A PoX miner can only receive newly minted STX tokens when they transfer Bitcoin to eligible owners of STX tokens
{% endhint %}

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-462a9ff6b7460b7059f20c863c0037f769972760%2Fimage.png?alt=media" alt=""><figcaption></figcaption></figure>

Miners run Stacks nodes with mining enabled to participate in the PoX mechanism. The node implements the PoX mechanism, which ensures proper handling and incentives through four key phases:

* Registration: miners register for a future election by sending consensus data to the network
* Commitment: registered miners transfer Bitcoin to participate in the election. Committed BTC are sent to a set participating STX token holders
* Election: a verifiable random function chooses one miner for a new tenure to write blocks on the Stacks blockchain
* Assembly: the elected miner writes the new blocks by pulling transactions from the mempool and collects rewards in form of new STX tokens

### Probability to mine next block

The miner who is selected to mine the next block is chosen depending on the amount of BTC the miners sent, that is, transferred or burnt.

The probability for a miner to mine the next block is determined using a variation of the Assumed Total Commitment with Carryforward (ATC-C) MEV mitigation strategy described in [this document](https://github.com/stacksgov/sips/blob/feat/sip-021-nakamoto/sips/sip-021/MEV-Report.pdf) to allocate block rewards to miners. The probability a miner will win the sortition and be granted the current tenure will be based on a function that accounts for the total block commit spend on the blocks leading up to the current sortition.

You can read more about this in the [MEV section of SIP-021](https://github.com/stacksgov/sips/blob/feat/sip-021-nakamoto/sips/sip-021/sip-021-nakamoto.md#block-reward-distribution-and-mev).

While there is no minimum BTC commitment enforced by the protocol, in practice, there's a floor constrained by [dust](https://unchained-capital.com/blog/dust-thermodynamics/): basically, if the fees for a transaction exceed the value of the spent output, it's considered dust. How dust is [calculated](https://github.com/bitcoin/bitcoin/blob/master/src/policy/policy.cpp#L14) depends on a number of factors, we've found 5,500 satoshis to be good lower bound per [output](https://learnmeabitcoin.com/technical/output). Bitcoin transactions from Stacks miners contain two outputs (for Proof-of-Transfer), so a commitment of at least 11,000 satoshis / block is recommended.

To calculate the amount of BTC to send miners should:

* Guess the price BTC/STX for the next day (100 blocks later)
* Guess the total amount of BTCs committed by all miners

Stackers are in charge of both validating and appending new blocks and conducting miner tenure changes. The next section will explain how that works, and then we'll see how this process results in Bitcoin finality.

### Stacks mining in practice

If you take a look at [SIgnal21's mining dashboard](https://app.signal21.io/stacks/mining), you can view some interesting data about mining on the Stacks network, including BTC spent per block, STX earned per block, the total number of miners over the course of the chain's history, and the number of miners for any given block.

Many people notice the seemingly small number of miners on Stacks. Without context, this can sometimes raise eyebrows. Let's dig into how mining works on Stacks so we can understand why this isn't an issue for decentralization.

Stacks miners function similarly to sequencers in L2 systems in that they are only responsible for constructing and proposing new blocks, not appending them to the chain. But unlike most Ethereum L2s that operate with just a single centralized sequencer, Stacks consistently has at least 4-5 miners with open membership allowing anyone to join.

It's important to note that there are two primary parties involved in the block production process on Stacks: miners and stackers.

These two roles serve complementary relationships in the block production process, and stackers drastically reduce any potential destructive power miners have over the chain.

Miners cannot reorganize the chain. In the worst case, all miners can do is omit (some kinds of) transactions, and all that is required to address this is to run your own miner.

Furthermore, more miners on the network would mean fewer BTC rewards for Stackers, as miners would have to spend more of their funds on Bitcoin L1 fees rather than sending it to the Stackers.

{% hint style="info" %}
**Wouldn't more miners mean more competition, meaning more rewards?**

The reason more miners means fewer rewards is because miners act economically rationally, and they don't have an unlimited amount of BTC to work with.

Miners are paying their PoX commitments plus their Bitcoin fees for a chance to win the coinbase (1,000 STX) plus fees for a tenure. If there are more miners, they will each pay less, because they will have a lower chance of winning. They can't pay ever-increasing amounts of BTC because at some point they will never be profitable, so there is a limit to how much BTC they can spend in order to try and win a tenure.

As they pay less, the Bitcoin fee becomes a more significant portion of their expenses, and that also decreases their odds of winning the tenure.

Here's a concrete example:

Let's say Stacks is trading at 1,000 Sats per STX.

The total spend from all miners, if everyone is acting logically and we ignore Stacks fees, would be less than 1,000,000 Sats (1,000 STX coinbase \* 1000 Sats/STX).

If that is from 5 miners, then it could be 10,000 Sats (2,000 Sats for each transaction) going to Bitcoin fees and 990,000 Sats going to PoX.

If there are 100 miners, then it would be 200,000 Sats going to Bitcoin fees, and 800,000 Sats going to PoX.
{% endhint %}

This creates a natural economic equilibrium where:

{% stepper %}
{% step %}
**Enough miners participate to ensure blocks are produced reliably**

Content as above describing reliability.
{% endstep %}

{% step %}
**Stackers receive optimal BTC rewards**

Content as above describing rewards optimization.
{% endstep %}

{% step %}
**The network maintains censorship resistance without unnecessary mining competition**

Content as above describing censorship resistance.
{% endstep %}
{% endstepper %}

This design is intentional - by having stackers as complimentary security guarantors who receive BTC rewards via PoX, Stacks achieves security without requiring an excessive number of miners competing solely to win block production rights.

Unlike other chains where miners alone determine the canonical chain, Stacks' two-party system provides stronger guarantees:

* Miners cannot force invalid transactions or blocks (stackers won't sign them, and even if they did, the nodes would not accept them)
* No miner can unilaterally reorg the chain (stackers control chain finality)
* The 70% stacker threshold signature requirement ensures broad consensus before blocks are accepted

This separation of concerns between miners and stackers is what makes Stacks uniquely secure despite having a small number of miners.

### What About Microblocks?

Microblocks are a legacy feature of the previous version of Stacks that no longer exist. They were originally created as a way to improve transaction throughput, but without the functionality of Nakamoto, they never worked in practice.

Instead of microblocks, Nakamoto instead utilizes a block production structure that creates Stacks blocks at a rapid cadence as described here.


# Signing

Stackers play an essential role in the Nakamoto system that had previously been the responsibility of miners. Before, miners both decided the contents of blocks, and decided whether or not to include them in the chain (i.e. by deciding whether or not to confirm them). In this system each actor has the following responsibilities necessary to make the system function reliably without forks:

* **Miners** decide the contents of blocks.
* **Stackers** decide whether or not the block is included in the chain.

The bulk of the complexity of the Nakamoto changes is in separating these two concerns while ensuring that both mining and Stacking remain open-membership processes. **Crucially, anyone can become a miner and anyone can become a Stacker, just as before.** The most substantial changes are in getting miners and Stackers to work together in their new roles to achieve this proposal's goals.

The key idea is that Stackers are required to acknowledge and validate a miner's block before it can be appended to the chain. To do so, Stackers must first agree on the canonical chain tip, and then apply (and roll back) the block on this chain tip to determine its validity. Once Stackers agree that the block is both canonical and valid, they collectively sign it and replicate it to the rest of the Stacks peer network. Only at this point do nodes append the block to their chain histories.

This new behavior prevents forks from arising. If a miner builds a block atop a stale tip, Stackers will refuse to sign the block. If Stackers cannot agree on the canonical Stacks tip, then no block will be appended in the first place. While this behavior creates a new failure mode for Stacks -- namely, the chain can halt indefinitely if Stackers cannot agree on the chain tip -- this is mitigated by having a large and diverse body of Stackers such that enough of them are online at all times to meet quorum and incentivizing them via PoX rewards to act as such.

### Stacker Signing

{% hint style="info" %}
You can view a list of all of the [active signers](https://explorer.hiro.so/signers?chain=mainnet) on Hiro's block explorer.
{% endhint %}

We'll cover how stacking works in the Stacking section and the sBTC signing in the sBTC section; here we'll cover the signing process as it relates to Stacks block production.

The means by which Stackers agree on the canonical chain tip and agree to append blocks is tied to PoX. In each reward cycle, a Stacker clinches one or more reward slots; there are at most 4,000 reward slots per reward cycle. Stackers vote to accept blocks by producing a weighted threshold signature over the block. The signature must represent a substantial fraction of the total STX locked in PoX (the threshold), and each Stacker's share of the signature (its weight) is proportional to the fraction of locked STX it owns.

The weighted threshold signature is a Schnorr signature generated through a variation of the [FROST protocol](https://eprint.iacr.org/2020/852.pdf). Each Stacker generates a signing key pair, and they collectively generate an aggregate public key for nodes to use to verify signatures computed through a distributed signing protocol. This signing protocol allocates shares of the associated aggregate private key to Stackers proportional to the number of reward slots they clinch. No Stacker learns the aggregate private key; Stackers instead compute shares of the private key and use them to compute shares of a signature, which can be combined into a single Schnorr signature.

When a miner produces a block, Stackers execute a distributed signing protocol to collectively generate a single Schnorr signature for the block. Crucially, the signing protocol will succeed only if at least X% of the reward slots are accounted for in the aggregate signature. Nakamoto is currently set to use a 70% signing threshold -- at least 70% of the reward slots (by proxy, 70% of the stacked STX) must sign a block in order to append it to the Stacks blockchain.

Nakamoto uses the [WSTS protocol with the FIRE extension](https://trust-machines.github.io/wsts/wsts.pdf), which admits a distributed key generation and signature generation algorithm pair whose CPU and network bandwidth complexity grows with the number of distinct Stackers. The FIRE extension enables WSTS to tolerate byzantine Stackers.

Here is a diagram outlining the relationship between signing and stacking.

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-afa91fa7dd99707993d314e58aec9c4aec5c98d7%2Fimage.png?alt=media" alt=""><figcaption></figcaption></figure>

### Validating and Appending New Blocks

When miners are selected for a new tenure, they begin building new blocks from transactions in the mempool. They then send those blocks to stackers for approval. Stackers must approve the blocks with a quorum of at least 70% for them to be appended to the chain.

Stackers will approve a block based on several properties:

* The block is well-formed
  * It has the correct version and mainnet/testnet flag
  * Its header contains the right number of Stacks blocks preceding this one.
  * Its header contains the correct total Bitcoin spent in the sortition that elected the current tenure.
  * Its header contains the same Bitcoin block hash as the Bitcoin block that contains its tenure's block-commit transaction\*
  * Its header contains the correct parent block ID of the immediate parent of this block.\*
  * The transaction Merkle tree root is consistent with the transactions
  * The state root hash matches the MARF tip root hash once all transactions are applied
  * The block header has a valid ECDSA signature from the miner.
  * The block header has a valid WSTS Schnorr signature from the set of Stackers.
* All Bitcoin transactions since the last valid sortition up to (but not including) this tenure's block-commit’s Bitcoin block have been applied to the Stacks chain state\*
* In the case of a tenure start block:
  * The first transaction is the `TenureChange` transaction.
  * The first transaction after the `TenureChange` transaction is a `Coinbase`.

The properties marked with \* are collectively how Stacks ensures Bitcoin finality. By adhering to these properties, it ensures that miners are only able to append blocks if they build atop the correct chain tip, which also anchors the history to Bitcoin.

Stackers, by validating these rules, ensure Bitcoin finality. We'll talk about this more in the next section.

### Conducting Miner Tenure Changes

The other primary signing responsibility in block production involves conducting tenure change transactions. As discussed in the mining section, miners will submit a `block-commit` transaction on the Bitcoin chain to initiate mining. If they are selected, stackers will detect that and create a `tenure-change` transaction.

This tenure change transaction includes:

| Name                           | Description                                                                                                                                                                                                                                                                                                                                           | Representation      |
| ------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------- |
| tenure consensus hash          | Consensus hash of this tenure. Corresponds to the sortition in which the miner of this block was chosen. It may be the case that this miner's tenure gets extended across subsequent sortitions; if this happens, then this `consensus hash` value remains the same as the sortition in which the winning block-commit was mined.                     | 20 bytes            |
| previous tenure consensus hash | Consensus hash of the previous tenure. Corresponds to the sortition of the previous winning block-commit.                                                                                                                                                                                                                                             | 20 bytes            |
| burn view consensus hash       | Current consensus hash on the underlying burnchain. Corresponds to the last-seen sortition.                                                                                                                                                                                                                                                           | 20 bytes            |
| previous tenure end            | The index block hash of the last Stacks block from the previous tenure.                                                                                                                                                                                                                                                                               | 32 bytes            |
| previous tenure blocks         | The number of blocks produced since the last sortition-linked tenure.                                                                                                                                                                                                                                                                                 | 4 bytes, big-endian |
| cause                          | <p>A flag to indicate the cause of this tenure change<br>- <code>0x00</code> indicates that a sortition occurred, and a new miner should begin producing blocks.<br>- <code>0x01</code> indicates that the current miner should continue producing blocks. The current miner’s tenure execution budget is reset upon processing this transaction.</p> | 1 byte              |
| pubkey hash                    | The ECDSA public key hash of the current tenure.                                                                                                                                                                                                                                                                                                      | 20 bytes            |

This tenure change transaction is then sent to the newly elected miner and they must include it as the first transaction in their first block, otherwise stackers will not approve it.

This process is then repeated over and over as new miners are elected for tenures.

Be sure to take a look at [SIP-021](https://github.com/stacksgov/sips/blob/feat/sip-021-nakamoto/sips/sip-021/sip-021-nakamoto.md) to get a detailed description of exactly what happens under the hood during these processes.

Next up, let's dig a little deeper into this idea of Bitcoin finality and how the Stacks block production mechanism achieves it.


# Bitcoin Finality

The concept of 100% Bitcoin finality is crucial to the design of Stacks. This is what turns Stacks into a true Bitcoin L2 and allows it to leverage all of the security inherent in Bitcoin.

Finality refers to the point at which transactions are irreversible. Once a blockchain reaches finality, it is nearly impossible to change the ledger's history without undertaking extraordinary measures that are often computationally and economically prohibitive.

When we talk about Stacks blocks having 100% Bitcoin finality, we mean that they are as hard to reverse as Bitcoin transactions themselves.

That's a bold claim, so how does Stacks accomplish that?

As discussed above, miners are responsible for producing Stacks blocks in their tenure, which corresponds to a single Bitcoin block. As part of their block commit transaction, which is the transaction that previously committed the hash of the next Stacks block to the Bitcoin chain, miners will instead be required to add an indexed block hash.

The indexed block hash is the hash of the first block produced by the last Stacks miner in their tenure. This is the SHA512/256 hash of both the consensus hash of all previously-accepted Bitcoin transactions that Stacks recognizes, as well as the hash of the block itself.

This will anchor the Stacks chain history to Bitcoin up to the start of the previous miner's tenure, as well as all causally-dependent Bitcoin state that Stacks has processed. This ensures Bitcoin finality, resolves miner connectivity issues by putting fork prevention on stackers, and allows nodes with up-to-date copies of the Stacks chain state to identify which Stacks blocks are affected by a Bitcoin reorg and recover the affected Stacks transactions.

This relationship between Stackers, miners, Bitcoin blocks, and Stacks blocks is what maintains Bitcoin finality while allowing miners to rapidly produce Stacks blocks. Bitcoin finality is achieved because at every Bitcoin block N + 1, the state of the Stacks chain as of the start of tenure N is written to Bitcoin. Even if at a future date all of the former Stackers’ signing keys were compromised, they would be unable to rewrite Stacks history for tenure N without rewriting Bitcoin history back to tenure N + 1.

Because of this, Stacks transactions can be considered to have Bitcoin finality after the tenure they are a part of concludes, or Bitcoin block N + 1. As an example, if I initiate a Stacks transaction that gets confirmed by a Stacks miner, at the conclusion of that miner's tenure (the end of the current Bitcoin block) that transaction will be written to Bitcoin as part of the Stacks chain state and all future miners are required to build off of that chain tip, making reversing the transaction as difficult as reversing the corresponding Bitcoin transaction.

{% hint style="info" %}
Key point: At every Bitcoin block N + 1 the state of the Stacks chain as of the start of tenure N is anchored to Bitcoin. This makes reversing Stacks history for tenure N as hard as rewriting Bitcoin history back to N + 1.
{% endhint %}

## Nakamoto Transactions and Bitcoin Reorgs

If Nakamoto transactions follow Bitcoin finality, what happens if Bitcoin forks?

In order to answer this question, we need to distinguish between two types of Stacks transactions: Bitcoin-reliant and internal.

{% hint style="info" %}

* **Bitcoin-reliant** transactions are transactions that read Bitcoin state. If Bitcoin forks, these transactions will change. For these, you cannot do better than following Bitcoin finality. For example, if you moved BTC from L1 to L2, you must wait for Bitcoin finality before your L2 BTC can be used (you don’t have any L2 BTC if the L1 transaction becomes unconfirmed due to a fork).
* **Internal** transactions don't rely on Bitcoin state, and thus won't change if Bitcoin forks. These can have faster confirmations because even if Bitcoin forks, signers can ensure they are re-processed in the same order.
  {% endhint %}

The key takeaway is this:

Under Nakamoto Stacks, transactions won’t impactfully reorganize due to a Bitcoin fork. Not only is reorging relatively infrequent, but transactions on Stacks that got reorganized due to a Bitcoin fork behave just as reorganized Bitcoin transactions do. With some future analysis, transactions purely on the L2 chain may one day be entirely unaffected.

<details>

<summary>Read more about Bitcoin reorg behavior</summary>

If you are interested in learning more about how this works, see the [Bitcoin Reorgs](https://docs.stacks.co/learn/block-production/bitcoin-reorgs) page of the docs.

</details>


# Bitcoin Reorgs

Under Nakamoto Stacks transactions don’t impactfully reorganize due to a Bitcoin fork. Not only is reorging relatively infrequent, but transactions on Stacks that got reorganized due to a Bitcoin fork behave just as reorganized Bitcoin transactions do. With some future analysis, transactions purely on the L2 chain may one day be entirely unaffected.

Understanding this concept fundamentally comes down to understanding finality on post-Nakamoto Stacks.

{% hint style="info" %}
Under Nakamoto the Stacks chain won’t fork on its own. It is designed not to fork with only special exceptions, and it’s entirely infeasible for Stacks to fork on its own if even 31% of Stackers don’t want it to fork, and even then it would likely only happen within the span of a single tenure.

The only case in which Stacks forks post-Nakamoto is if Bitcoin forks cause it to fork.
{% endhint %}

Under Nakamoto, instead of winning the right to make a single block, miners win the right to make a ton of blocks, and during that time we say they’re under “tenure”. Every single Stacks block produced in a tenure requires at least 70% of Stackers to approve (sign) it for it to be included in the Stacks blockchain. The Stackers are watching the Bitcoin blockchain and will only sign blocks from the miner that won the latest sortition.

Now, let’s imagine that Bitcoin reorganizes itself and the Stackers were watching a Bitcoin fork that is now sub-optimal. The Stackers would essentially go back in time to the latest common sortition between the fork that they were watching and the new best Bitcoin fork and start signing the blocks within the tenures from there. Note that 70% of the Stackers will be doing the same thing all at once, and the moment 70% agree to start signing from the latest tenure on the new Bitcoin fork there’s a new singularly optimal Stacks blockchain.

So what happens to the transactions that were confirmed on the tenure that got reorganized? Nothing. Still in the mempool as if the reorganized tenure didn’t happen. For anything within the Stacks blockchain everything is fine.

This is 1:1 with a Bitcoin fork reorganizing a Bitcoin transaction. You shouldn’t consider a transaction on Bitcoin final if it’s near the chain tip, and you shouldn’t consider a Stacks transaction final if it’s near the tenure tip.

<details>

<summary>Replaying Transactions</summary>

Since 70% of the signers have to sign any Stacks block included in the chain at least 70% of signers know the state of the chain before and after a Bitcoin fork causes a Stacks reorg.

There’s a catch to this that makes enforcing it difficult: if a transaction were dependent on something on the Bitcoin blockchain that also got reorganized (a peg-in, for example), that transaction would now be invalid. Taint analysis is when you attempt to answer the questions “which transaction interacted with the now-orphaned Bitcoin blockchain in a way that makes them invalid (tainted) in the new chain” and then also “which transactions interacted with the now invalid (tainted) transaction such that they are now also invalid”. There’s a cascading effect, but enforcing any kind of replay requires that the Stackers and the Miners can identify which transactions can get replayed at all.

Taint analysis, and subsequently replay enforcement, can be added in the future.

For the first release, Nakamoto explicitly ties the Stacks blockchain to the Bitcoin blockchain such that there’s only one optimal Stacks fork tied to Bitcoin at any given point. This is completely 1:1 with the Bitcoin Blockchain behavior, but on the tenure scale.

</details>


# Stacking

### Introduction

Stacking rewards Stacks (STX) token holders with bitcoin for providing a valuable service to the network by locking up their tokens for a certain time and participating as consensus-critical signers. If you aren't familiar with the concept of signers in Stacks, be sure to check out the [Signing section](https://docs.stacks.co/learn/block-production/signing). This document is a conceptual overview of stacking and how it works.

`pox-4.clar` is the stacking contract. If you are interested in experimenting with proof of transfer use cases including state changes, solo stacking, and pool stacking, all the functions you’ll need can be found at the deployed contract:

* Testnet: <https://explorer.hiro.so/txid/0xfba7f786fae1953fa56f4e56aeac053575fd48bf72360523366d739e96613da3?chain=testnet>
* Mainnet: <https://explorer.hiro.so/txid/0xc6d6e6ec82cabb2d7a9f4b85fcc298778d01186cabaee01685537aca390cdb46?chain=mainnet>

### Stacking vs Staking

While stacking on the Stacks network can be conceptually similar to staking, Stacks is not a PoS network and there are a couple key differences.

There are two primary differences between stacking in Stacks and staking in PoS networks.

#### Yield generated in burnchain token

In staking, users lock one token and earn their yield in the same token. In stacking, users lock one token (STX) and earn a yield in the "burnchain" token (BTC), rather than the same token that was locked. In PoX, the yield comes from a finite, external source (Bitcoin deposits from Stacks miners). In PoS, the yield comes from the currency's issuance schedule itself.

How are these issuance rates set? In Ethereum, issuance rates are determined by network usage. Ethereum's goal is to create a deflationary money supply, so the issuance rate is determined depending on the usage of the network. In order for an Ethereum transaction to be considered valid, it must include a base fee that is burned during transaction execution. The [issuance rate is algorithmically determined](https://ethereum.org/en/roadmap/merge/issuance/#post-merge) block-by-block depending on how much ETH is being burned by these base fees plus normal gas fees.

Stacking doesn't generate yield in the same token and therefore doesn't need to issue new STX for stacking rewards. Stacking yield requires an input of an external token (BTC). Stacks does have an issuance rate and does generate new STX tokens, but that process is separate from stacking and the stacking yield mechanism.

#### No slashing

Although stackers do fulfill a consensus-critical role in Stacks by serving as signers, there is no concept of slashing in PoX (Proof of Transfer).

Rather, if stackers do not perform their duties as signers, they simply cannot unlock their STX tokens and will not receive their BTC rewards.

Stacking is a built-in action, required by the "proof-of-transfer" (PoX) mechanism. The PoX mechanism is executed by every miner on the Stacks network.

{% hint style="info" %}
Stacking functionality is implemented as a smart contract, using Clarity. Read more about [the contract](https://app.gitbook.com/s/GVj1Z9vMuEOMe7oH7Wnq/clarity/example-contracts/stacking).
{% endhint %}

### Locking and Unlocking STX

When STX tokens are "locked", no transfer of STX tokens occurs. Locking STX tokens is non-custodial, and STX tokens remain in your wallet. When you initiate a stacking transaction those tokens are locked and unspendable at the protocol level, but they do not leave the stacker's wallet.

At the end of the lock period, they will be automatically unlocked (spendable at the protocol level). This occurs implicitly; there is no direct transaction that unlocks them.

### Stacking flow

The Stacking mechanism can be presented as a flow of actions:

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-56cb1a4122cf42076f96ff6dafc6bf1d4f01835d%2Fimage.png?alt=media" alt=""><figcaption></figcaption></figure>

{% stepper %}
{% step %}
**Make API calls to get details about the upcoming reward cycle**

Query the network to discover the upcoming cycle parameters and timing.
{% endstep %}

{% step %}
**Confirm eligibility for a specific Stacks account**

Verify the account meets the minimum requirements and is eligible to participate.
{% endstep %}

{% step %}
**Confirm the BTC reward address and lockup duration**

Specify the Bitcoin address to receive payouts and input the desired lockup period.
{% endstep %}

{% step %}
**Broadcast the stacking transaction to lock STX**

The transaction is broadcast and the STX tokens are locked. This must happen before the prepare phase of the next reward cycle (the last 100 Bitcoin blocks of the ongoing reward phase).
{% endstep %}

{% step %}
**Reward cycles execute and BTC rewards are sent**

The stacking mechanism executes reward cycles and sends out rewards to the configured BTC reward address.
{% endstep %}

{% step %}
**Monitor unlocking timing and rewards during lockup**

During the lockup period, you can obtain details about unlocking timing, expected rewards, and more.
{% endstep %}

{% step %}
**Tokens are released after the lockup period**

Once the lockup period has passed, the tokens become spendable again.
{% endstep %}

{% step %}
**Display reward history**

Show historical details like earnings for previous reward cycles.
{% endstep %}
{% endstepper %}

{% hint style="info" %}
Keep in mind that the target duration for a reward cycle is \~2 weeks. This duration is based on the target block time of the Bitcoin network (10 minutes) and can be higher at times due to [confirmation time variances](https://www.blockchain.com/charts/median-confirmation-time) of the Bitcoin network.
{% endhint %}

### Stacking delegation flow

There are two main ways you can stack: solo stacking and delegated stacking.

{% stepper %}
{% step %}
**Solo stacking**

Solo stacking follows the general stacking flow. You stack your own STX tokens and run your own signer. To operate as a solo stacker, you must have a minimum amount of STX tokens. This minimum is dynamic and can be found by viewing the [pox endpoint of the API](https://api.testnet.hiro.so/v2/pox) in the `min_threshold_ustx` field.
{% endstep %}

{% step %}
**Delegated stacking**

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-4b4b6fb18a0cb6d97d141d9bb370408575c8c49e%2Fimage.png?alt=media" alt=""><figcaption></figcaption></figure>

Delegated stacking differs:

* Before stacking on behalf of a token holder, the delegator must be granted permission by the account owner. Permission is restricted to a maximum amount the delegator may stack; the maximum can be set higher than available funds. An account can be associated with only one delegator.
* The account sets the delegation relationship. They can optionally restrict the Bitcoin reward address that must be used for payouts and specify an expiration burn block height to limit the delegation duration.
* Delegators lock STX from different accounts ("pooling phase") until they reach the minimum required to participate in stacking.
* Once the delegator locks enough STX, they can finalize and commit participation in the next reward cycle.
* Some delegation relationships may allow the STX holder to receive payouts directly from the miner.
* Delegation can terminate automatically based on expiration rules or by actively revoking delegation rights.
  {% endstep %}
  {% endstepper %}

### Token holder eligibility

Stacks (STX) token holders don't automatically receive stacking rewards. To participate, they must:

* Commit to participation before a reward cycle begins
* Commit at least the minimum amount of STX tokens to secure a reward slot, or pool with others to reach the minimum
* Lock up STX tokens for a specified period
* Provide a supported Bitcoin address to receive rewards
* Maintain their signer software (if they operate a signer)

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-a2f699bc2a05391ac67413518e9e7a44bbacce3a%2Fimage.png?alt=media" alt=""><figcaption></figcaption></figure>

Token holders have a variety of providers and tools to support their participation in stacking. The Stacks website contains a [list of pools and stacking options](https://www.stacks.co/learn/stacking#startstacking).

### Stacking in the PoX consensus algorithm

Stacking is a built-in capability of PoX and occurs through a set of actions on the Stacks blockchain. The [full proof-of-transfer implementation details](https://github.com/stacks-network/stacks-blockchain/blob/develop/sip/sip-007-stacking-consensus.md) are in SIP-007. Below is a summary of the most relevant actions of the algorithm.

{% hint style="info" %}
Note that SIP-007 describes stacking before Nakamoto. While much of the functionality remains the same, stackers now have the additional responsibility of operating as signers as outlined in [SIP-021](https://github.com/stacksgov/sips/blob/feat/sip-021-nakamoto/sips/sip-021/sip-021-nakamoto.md).
{% endhint %}

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-4b4a05513919821cd98f9325c95a55ddc4cfbccd%2Fimage.png?alt=media" alt=""><figcaption></figcaption></figure>

Stacking happens in reward cycles of 2100 Bitcoin blocks (roughly two weeks). Reward cycles are split into two phases: the prepare phase and the reward phase.

* The prepare phase lasts 100 Bitcoin blocks and is where the new stackers for the upcoming reward phase are selected by the PoX anchor block (see SIP-007 for details).
* Because Stacks does not fork after the Nakamoto upgrade, the PoX anchor block is always known 100 Bitcoin blocks before the start of the next reward cycle. It is the last tenure-start block that precedes the prepare phase.
* The PoX anchor block identifies the next stackers. They have 100 Bitcoin blocks to prepare for signing Stacks blocks, including completing a Distributed Key Generation round for signing blocks.
* The PoX contract requires stackers to register their block-signing keys when they stack or delegate-stack STX, so the entire network can validate signatures on blocks.

This process is handled by [running a signer](https://app.gitbook.com/s/4cpTb2lbw0LAOuMHrvhA/run-a-signer) and then subsequently conducting stacking operations as that signer.

### Stacking and Signing

Stacking and signing are distinct actions, but both are necessary. Signers must stack their STX tokens, and you cannot stack STX without associated signing information. The nuance depends on solo vs delegated stacking.

### Solo Stacking

If you are solo stacking, you have two options for signing.

#### Run your own signer

You can run your own signer by following the How to Run a Signer guide. This requires technical knowledge and resources for running a machine. See the guide for details.

#### Work with another signer

If you don't want to run your own signer, you can collaborate with another signer and include their signature in your stacking transactions. Details on how to do this are in the [Stack STX](https://app.gitbook.com/s/4cpTb2lbw0LAOuMHrvhA/stacking-stx) guide.

### Delegated Stacking

If you delegate your STX to a pool operator, you do not need to run a signer. The pool operator conducts the actual stacking transaction and is responsible for running the signer.

If you are a pool operator, see the [operate-a-pool guide](https://app.gitbook.com/s/4cpTb2lbw0LAOuMHrvhA/stacking-stx/operate-a-stacking-pool).

### How and Where to Stack

Options for stacking include solo stacking, participating in a pool, using an exchange, and liquid stacking. The Stacks website has a [stacking page](https://www.stacks.co/learn/stacking) describing these options.

For detailed instructions on how to stack, see the [Stack STX guides](https://app.gitbook.com/s/4cpTb2lbw0LAOuMHrvhA/stacking-stx).

Tools and explorers for stacking data and statistics:

* <https://app.signal21.io/>
* <https://www.stacking-tracker.com/>
* <https://www.stakingrewards.com/calculator?asset=stacks>
* <https://stacking.tools/>


# Transactions

Transactions are a key component of the Stacks chain and are the primary way users will interact with it. In this section, we'll cover how transactions work and give an introduction to post conditions, an additional security feature of Stacks that allows client-side developers to enforce certain conditions to protect users from interacting with malicious contracts.


# How Transactions Work

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-47111d002c520e55941486d8efa9eb9b330864dd%2Fimage.png?alt=media" alt=""><figcaption><p>source: <a href="https://www.hiro.so/blog/dissecting-a-transaction-signature-on-stacks">Hiro blog</a></p></figcaption></figure>

### Introduction

Transactions are the fundamental unit of execution in the Stacks blockchain. Each transaction is originated from a Stacks account, and is retained in the Stacks blockchain history for eternity. This guide helps you understand Stacks transactions.

### Lifecycle

Transactions go through phases before being finally confirmed, and available for all, on the Stacks 2.0 network.

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-0f140b843bc4816542284a80c67e350f505dae57%2Fimage.png?alt=media" alt=""><figcaption></figcaption></figure>

{% stepper %}
{% step %}
**Generate**

Transactions are assembled according to the encoding specification.
{% endstep %}

{% step %}
**Validate and sign**

Transactions are validated to confirm they are well-formed. Required signatures are filled in.
{% endstep %}

{% step %}
**Broadcast**

Transactions are sent to a node.
{% endstep %}

{% step %}
**Register**

A miner receives transactions, verifies, and adds them to the ["mempool,"](https://academy.binance.com/en/glossary/mempool) a holding area for all the pending transactions.
{% endstep %}

{% step %}
**Process**

Miners review the mempool and select transactions for the next block to be mined. Depending on the transaction type, different actions can happen during this step. For example, post-conditions could be verified for a token transfer, smart-contract defined tokens could be minted, or an attempt to call an existing smart contract method could be made.
{% endstep %}

{% step %}
**Confirm**

Miners successfully propose blocks with a set of transactions. The transactions inside are successfully propagated to the network when the stackers approve them.
{% endstep %}
{% endstepper %}

{% hint style="info" %}
A transaction can have one of three states once it is registered: `pending`, `success`, or `failed`.
{% endhint %}

### Types

Stacks supports a set of different transaction types:

| **Type**                  | **Value**                 | **Description**                                                                                                                                                                                                                                                             |
| ------------------------- | ------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Tenure change             | `TenureChange`            | A tenure change is an event in the existing Stacks blockchain when one miner assumes responsibility for creating new stacks blocks from another miner. A change in tenure occurs when a Stacks block is discovered from a cryptographic sortition. Carried out by stackers. |
| Tenure change block found | `TenureChange-BlockFound` | A `TenureChange-BlockFound` transaction is induced by a winning sortition. This causes the new miner to start producing blocks, and stops the current miner from producing more blocks.                                                                                     |
| Tenure change extend      | `TenureChange-Extend`     | A `TenureChange-Extend`, which is induced by Stackers, resets the current tenure's ongoing execution budget, thereby allowing the miner to continue producing blocks.                                                                                                       |
| Token transfer            | `token_transfer`          | Asset transfer from a sender to a recipient                                                                                                                                                                                                                                 |
| Contract deploy           | `smart_contract`          | Contract instantiation                                                                                                                                                                                                                                                      |
| Contract call             | `contract_call`           | Contract call for a public, non read-only function                                                                                                                                                                                                                          |

A sample of each transaction type can be found in the [Stacks Blockchain API response definition for transactions](https://docs.hiro.so/stacks/api/transactions/get-transaction).

{% hint style="info" %}
Read-only contract call calls do **not** require transactions. Read more about it in the network guide.
{% endhint %}


# Post Conditions

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-3716767855649150a8a31e6cedc4c9d4139a7500%2Fimage.png?alt=media" alt=""><figcaption><p>source: <a href="https://www.hiro.so/blog/a-developers-guide-to-post-conditions">Hiro blog</a></p></figcaption></figure>

Post conditions are one of the most interesting and unique aspects of Stacks.

From the beginning, safety and security has been at the heart of the Stacks ethos and formed the foundation of architecture decisions when building it.

Like Clarity, Stacks' smart contract programming language, post conditions were specifically built and designed to solve the problem of user safety when interacting with blockchain applications.

So what are they and how do they work?

### How Post Conditions Work

Post conditions are conditions that are set on the client side to ensure that a smart contract does not perform any unexpected behavior.

Let's look at an example to make this more concrete.

Let's say a user is on an NFT marketplace and is expecting to purchase an NFT for 100 STX. Using post conditions, the developer who is building the frontend of the application can add in post conditions to ensure that this is in fact what happens when the user initiates the transaction.

If it does not, the transaction will abort and the user won't be out anything except the transaction fee.

It's important to note that post conditions do not live in smart contracts. They are designed to be an extra layer of security on top of smart contracts.

The problem they help address is a user interacting with a malicious smart contract that attempts to do something the user does not expect.

But rather than simply being a UI feature of a wallet, these post conditions are built into the Stacks blockchain itself and are enforced at the protocol level.

When you use a Stacks wallet like the Hiro web wallet and initiate a transaction, the wallet will display the post conditions set by the developer and tell the user exactly what is going to happen. If the action taken by the smart contract matches, the transaction goes through fine, otherwise it aborts.

Here's what that looks like:

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-5b26b1c9eb08397ee84db2af8b95bf04ded839bb%2Fimage.png?alt=media" alt=""><figcaption></figcaption></figure>

In this example, if the smart contract does not transfer one fabulous-frog NFT and and take 50 STX from the user, the transaction will abort.

You can learn more about how post conditions work in [SIP-005](https://github.com/stacksgov/sips/blob/main/sips/sip-005/sip-005-blocks-and-transactions.md#transaction-post-conditions) and how to utilize them in your applications in Hiro's excellent [post conditions tutorial](https://docs.hiro.so/stacks/stacks.js/guides/post-conditions).


# Clarity

A smart contract language built to be readable and predictable.

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-287069d054107785b86964fac1af4aab57d82728%2Fimage.png?alt=media" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
Head to the [Clarity Crash Course](https://app.gitbook.com/s/Zz9BLmTU9oydDpL3qiUh/get-started/clarity-crash-course) to build your first Clarity smart contract.
{% endhint %}

Clarity is a **decidable** smart contract language that optimizes for predictability and security, designed for the Stacks blockchain. It has been built from the ground up to make it easier for developers to write safe, secure smart contracts. Clarity has several unique features that make it an ideal choice for writing smart contracts.

The design decisions behind Clarity were based heavily on taking lessons learned in common Solidity exploits and creating a language that has been purpose-built for safety and security in mind.

### What makes Clarity different

The following section is an excerpt from the Clarity book, [Clarity of Mind](https://book.clarity-lang.org/ch00-00-introduction.html):

The number of smart contract languages grows by the year. Choosing a first language can be challenging, especially for a beginner. The choice is largely dictated by the ecosystem you are interested in, although some languages are applicable to more than just one platform. Each language has its own upsides and downsides and it is out of the scope of this book to look at all of them. Instead, we will focus on what sets Clarity apart and why it is a prime choice if you require the utmost security and transparency.

One of the core precepts of Clarity is that it is secure by design. The design process was guided by examining common pitfalls, mistakes, and vulnerabilities in the field of smart contract engineering as a whole. There are countless real world examples of where developer failure led to the loss or theft of vast amounts of tokens. To name two big ones: an issue that has become known as the Parity bug led to the irreparable loss of millions of dollars worth of Ethereum. Second, the hacking of The DAO (a "Decentralized Autonomous Organization") caused financial damage so great that the Ethereum Foundation decided to issue a contentious hard fork that undid the theft. These and many other mistakes could have been prevented in the design of the language itself.

#### Clarity is interpreted, not compiled

Clarity code is interpreted and committed to the chain exactly as written. Solidity and other languages are compiled to byte-code before it is submitted to the chain. The danger of compiled smart contract languages is two-fold: first, a compiler adds a layer of complexity. A bug in the compiler may lead to different byte-code than was intended and thus carries the risk of introducing a vulnerability. Second, byte-code is not human-readable, which makes it very hard to verify what the smart contract is actually doing. Ask yourself, would you sign a contract you cannot read? If your answer is no, then why should it be any different for smart contracts? With Clarity, what you see is what you get.

#### Clarity is decidable

A decidable language has the property that from the code itself, you can know with certainty what the program will do. This avoids issues like the halting problem. With Clarity you know for sure that given any input, the program will halt in a finite number of steps. In simple terms: it is guaranteed that program execution will end. Decidability also allows for complete static analysis of the call graph so you get an accurate picture of the exact cost before execution. There is no way for a Clarity call to "run out of gas" in the middle of the call. We explore this idea more, along with a discussion on Turing completeness, in the security deep dive on decidability.

#### Clarity does not permit reentrancy

Reentrancy is a situation where one smart contract calls into another, which then calls back into the first contract—the call "re-enters" the same logic. It may allow an attacker to trigger multiple token withdrawals before the contract has had a chance to update its internal balance sheet. Clarity's design considers reentrancy an anti-feature and disallows it on the language level.

#### Clarity guards against overflow and underflows

Overflows and underflows happen when a calculation results in a number that is either too large or too small to be stored, respectively. These events throw smart contracts into disarray and may intentionally be triggered in poorly written contracts by attackers. Usually this leads to a situation where the contract is either frozen or drained of tokens. Overflows and underflows of any kind automatically cause a transaction to be aborted in Clarity.

#### Support for custom tokens is built-in

Issuance of custom fungible and non-fungible tokens is a popular use-case for smart contracts. Custom token features are built into the Clarity language. Developers do not need to worry about creating an internal balance sheet, managing supply, and emitting token events. Creating custom tokens is covered in depth in later chapters.

#### On Stacks, transactions are secured by post conditions

In order to further safeguard user tokens, post conditions can be attached to transactions to assert the chain state has changed in a certain way once the transaction has completed. For example, a user calling into a smart contract may attach a post condition that states that after the call completes, exactly 500 STX should have been transferred from one address to another. If the post condition check fails, then the entire transaction is reverted. Since custom token support is built right into Clarity, post conditions can also be used to guard any other token in the same way.

#### Returned responses cannot be left unchecked

Public contract calls must return a so-called response that indicates success or failure. Any contract that calls another contract is required to properly handle the response. Clarity contracts that fail to do so are invalid and cannot be deployed on the network. Other languages like Solidity permit the use of low level calls without requiring the return value to be checked. For example, a token transfer can fail silently if the developer forgets to check the result. In Clarity it is not possible to ignore errors, although that obviously does prevent buggy error handling on behalf of the developer. Responses and error handling are covered extensively in the chapters on functions and control flow.

#### Composition over inheritance

Clarity adopts a composition over inheritance. It means that Clarity smart contracts do not inherit from one another like you see in languages like Solidity. Developers instead define traits which are then implemented by different smart contracts. It allows contracts to conform to different interfaces with greater flexibility. There is no need to worry about complex class trees and contracts with implicit inherited behavior.

#### Access to the base chain: Bitcoin

Clarity smart contracts can read the state of the Bitcoin base chain. It means you can use Bitcoin transactions as a trigger in your smart contracts! Clarity also features a number of built-in functions to verify secp256k1 signatures and recover keys.


# Decidability

### What does it mean for a language to be Non-Turing Complete or Decidable?

Non-Turing complete and decidable are two terms you will often hear about the security advantages of Clarity, but what do they mean?

While related, they are not quite interchangeable, since there are a few differences.

#### Non-Turing Complete

A system or language is non-Turing complete if it cannot simulate a Turing machine, which is an abstract model of computation. Non-Turing complete systems have limited computational power compared to Turing complete systems. A Turing-complete system or language can simulate any Turing machine. Examples of non-Turing complete systems include finite state machines and some domain-specific languages (like Clarity).

Non-Turing complete languages typically cannot express all possible algorithms. Specifically, some problems whose solutions require unbounded loops or recursion cannot be expressed using non-Turing complete languages. This last property is especially important in the context of Clarity, as it makes it so that features like unbounded loops and reentrancy are disallowed at a language level.

#### Decidable

A problem is decidable if there exists an algorithm that can always determine whether a given input has a particular property or not in a finite amount of time. In other words, a decidable problem can be solved by a Turing machine that is guaranteed to halt for all input instances. Decidability is a property of problems, whereas Turing completeness is a property of languages or computational systems.

The fact that Clarity is decidable means that developers (and tooling) can more easily reason about and predict with certainty the behavior of Clarity contracts, regardless of the input.

### Mindset of a Smart Contract Developer

Before we dive into specifics, let's first set the context and viewpoint we should hold as smart contract developers who want to write secure code.

As you explore further into the security properties of Solidity and Clarity, you'll see that there are always mitigation steps that *can* be taken by developers to help address some of these security issues.

The main issue, with this line of thinking, is it increases the odds of human error in smart contract security. If we can preserve functionality while mitigating the chance of human error as much as possible, we should do so.

### Should smart contracts be Turing complete?

We will discover new applications for smart contracts. These applications will go beyond current smart contracts, traditional contracts, and may even open new economic opportunities. Given these possibilities, how should we build our smart contracts? What characteristics should our smart contract languages have?

It is good practice to separate data from programs. Should smart contracts be data, or programs, or something in between? If smart contracts are data, then should the programs that execute them be Turing complete or perhaps less powerful? If smart contracts are programs, then what language should smart contracts be written in? What characteristics should this programming language have?

The Church–Turing thesis is the hypothesis that all formal notions of computation are captured by Turing machines or modern computers. A programming language is Turing complete if it captures all formal notions of computation. Many programming languages are Turing complete. For example, Python, C++, Rust, Java, Lisp, and Solidity are all Turing complete.

Consider a program and its input. In the worst case, determining this program’s output is impossible. Validating a program, on a particular input, is done by generating a proof-of-correctness.

Proofs-of-correctness are logical proofs that can be mechanically validated. Finding proofs-of-correctness for programs and their input is undecidable. Kurt Gödel showed there are undecidable logical statements.

This indicates all programs in Turing complete languages cannot be validated in the worst case. Thus, Turing complete smart contract languages must allow contracts that cannot be validated.

Alonzo Church and Alan Turing showed there are problems that are uncomputable. Uncomputable problems cannot be solved by any Turing machine. Hence, assuming the Church–Turing thesis, these uncomputable problems cannot be solved by any computer.

We'll explore this idea further later in this section.

Turing complete languages are very expressive. In fact, assuming the Church–Turing thesis, Turing complete languages are as expressive as possible in some sense.

Is there a trade-off? What types of problems can occur with uncomputable problems and programs whose validity may be undecidable?

As smart contracts subsume parts of contract law, consider the large body of laws and regulations for tax law.

For instance, US tax law and regulations take up several million words. International tax law and regulations pushes these numbers much higher.

Are these laws and regulations programs or are they data? If tax law were to be written in a Turing complete language, then the law may codify uncomputable problems. It is an accountant’s nightmare for their advice to be undecidable.

Clarity is non-Turing complete, yet very expressive. This makes it so that Clarity is decidable and cannot encode uncomputable problems. There are discussions and papers on smart contract languages such as Solidity that propose subsets of Solidity that are non-Turing complete. These subsets are decidable and cannot encode uncomputable problems. However, there is no consensus on which subsets to work with and they are not widely used.

### Advantages of Decidability in Smart Contracts

Why is decidability important in the context of smart contracts?

First, it is not possible for a Clarity call to run out of gas in the middle of a call. Because of its decidability, it is possible to get a complete static analysis of the call graph to get an accurate picture of the cost before execution.

Solidity allows for unbounded loops, recursion, and dynamic function calls, which makes it difficult to accurately predict the execution cost or gas usage beforehand. As a result, Solidity contracts may run out of gas during execution if the gas limit is not set appropriately or if the contract encounters a scenario with unexpectedly high computational requirements.

One practical example is the issue of a specific kind of DoS attack in Solidity, where the contract is rendered inoperable because of unbounded execution constraints. An example of this is the GovernMental attack, where a mapping that needed to be deleted for a payout became so large that working with it exceeded the block gas limit.

There are a few different properties of Clarity's language design that prevents such DoS attacks.

The reason that the analysis system can accurately estimate the execution cost is because certain functionality is intentionally limited in Clarity.

For example, there is no recursion in Clarity, so we can't infinitely call into a function over and over.

Data types in Clarity are also restricted. Any data types that don't require a hard length limit are not iterable.

Maps and tuples, for example, do not require you to enter a maximum length when defining them, but you also can't iterate over them.

Lists, on the other hand, which are iterable, do require the developer to define an upper limit when defining them. This is a large part of what allows an accurate static analysis of Clarity contracts.

So how would we implement a mapping of an undefined size in Clarity? We wouldn't, because it's an anti-pattern in smart contract design.

Instead, Clarity forces us to think of a better solution to our problem. For example, implementing a way for users to handle mapping/list element operations themselves, instead of mass operations handled at the contract level.

If you [analyze the GovernMental attack](https://hackernoon.com/smart-contract-attacks-part-2-ponzi-games-gone-wrong-d5a8b1a98dd8#h-attack-2-call-stack-attack), you'll see that it took advantage of multiple security issues, all of which are mitigated in Clarity. You'll also see that a fix was added to make it economically infeasible to carry out this type of attack again.

This brings up another crucial point when setting appropriate mental models for smart contracts and blockchain systems: complexity means more potential bugs, which means adding more complexity to address those bugs.

When this happens over and over again, we are trapping ourselves into creating an evermore complex system. Addressing these issues at the language level prevents this ever-growing complexity.

For a deep dive into how Clarity was designed, check out [SIP-002](https://github.com/stacksgov/sips/blob/main/sips/sip-002/sip-002-smart-contract-language.md).

{% hint style="info" %}
You can view some more common smart contract vulnerabilities and how they are mitigated in [this article](https://stacks.org/bringing-clarity-to-8-dangerous-smart-contract-vulnerabilities/).
{% endhint %}

This has second-order effects as well when we look at security testing and auditing. One of the common tools for testing smart contracts is formal verification, where we mathematically prove that certain properties of smart contracts will or will not remain true in all cases.

This can lead to the path explosion problem, where there are so many paths available that formal verification becomes incredibly difficult. This problem is mitigated in Clarity, since there is not chance of a program encountering an unbounded loop.

This leads us to a more general mental model for thinking about decidability as smart contracts continue to become a larger part of our economy. Remember that the goal with blockchain systems is to create an open, transparent, fair financial system.

This means that smart contracts will be responsible for managing large amounts of wealth for ever-growing amounts of people. As smart contracts encompass more financial structures, their complexity and usage will grow.

Complexity is the enemy of security. The more complex a system is, the more danger there is in creating uncomputable problems when there are no hard restrictions on the execution steps that can be taken.

This is deadly in financial infrastructure that is not only open and transparent, but immutable. Let's explore this idea of uncomputability a bit more.

### Intuition on Uncomputability

Intuitively, uncomputability is an algorithmic view of undecidability. Uncomputability has the same foundations as undecidability. Undecidable questions are framed as logic statements or statements about integers. Of course, programs are logic statements and may even be viewed as integers, though we view programs differently. We often view programs with additional details of memory models, implementation details, and execution semantics.

The [Halting problem](https://en.wikipedia.org/wiki/Halting_problem): As an example, given any program `P` and any finite input `I` for `P`, then the Halting Problem is the challenge of determining if `P` halts on input `I`.

Alonzo Church and Alan Turing showed the Halting Problem is unsolvable.

Christopher Strachey gave an intuitive proof-by-contradiction showing the Halting problem is uncomputable. This is set up by supposing there is a program `H` that can solve the Halting problem for any program `P`. `H(P)` returns true if `P` halts and false otherwise. Then build a program `P` that does not halt when `H(P)` is true, giving a contradiction. Similarly, this program `P` halts when `H(P)` is false, also a contradiction.

Uncomputable problems are problems that cannot be solved by an algorithm or a computer, no matter how much time or resources are provided. These problems exist in various forms, and one such example is the Post correspondence problem, which was proposed by Emil Post.

The Post correspondence problem can be described using pairs of strings and an integer. Imagine you have n pairs of strings, called P. These strings are made up of characters from a character set, such as UTF-8 or any other alphabet with at least two symbols. The pairs of strings look like this:

```
P = { (x1, y1), (x2, y2), … , (xn, yn) }
```

Now, you also have an integer m that is greater than 0. The Post correspondence problem asks whether there is a way to create a list of indices (i1, i2, …, im) using the given pairs of strings. You can repeat these indices if needed, with one condition: when you combine the x strings from the pairs using the indices, the resulting string must be equal to the combined y strings from the same pairs using the same indices. In other words:

```
x(i1) x(i2) … x(im) = y(i1) y(i2) … y(im)
```

When developers try to solve the Post correspondence problem, they often attempt to use indeterminate loops (loops without a fixed number of iterations) rather than recursion. This is because the problem seems to require searching through different combinations of indices until a solution is found or it's proven that no solution exists.

In simple terms, the Post correspondence problem involves trying to find a sequence of indices that, when applied to the given pairs of strings, produces equal concatenated strings from both the x and y components. This problem is considered uncomputable because there is no general algorithm that can solve it for all possible input pairs of strings and integers.

It turns out, many questions about how programs behave are uncomputable. This has a number of consequences for smart contracts that are built in Turing complete languages, many of which we are not aware of yet but will surely become aware of as we encounter them in the future.

### Raymond Smullyan’s Intuition on Undecidability

This is a part of Raymond Smullyan’s approach to understanding undecidability in propositional logic. It uses meta-information to show something must be true, though it cannot be proved in propositional logic. This is based on a paradox.

In propositional logic, a logical statement is undecidable if we cannot prove it true or false. Given a propositional logic statement S, a proof is a sequence of formal logical deductions, starting from basic facts and ending by indicating if S is true or false.

Smullyan starts with an island of Knights and Knaves. Knights always tell the truth. Knaves always lie. We cannot distinguish islanders otherwise.

There is a great logician named Ray. Whatever Ray proves is true. This is just like a good theorem prover.

An islander Jack proclaims: “You cannot prove I am a Knight” to the logician Ray.

The next reasoning is based on meta-knowledge of this situation. This meta-knowledge shows that some problems are undecidable in propositional logic.

If Ray can prove Jack is a Knight, then Jack must be a Knave, since Jack must have lied. That is because Ray proved Jack is a Knight. Since Jack is a Knave, Ray’s proof contradicts the assumption that Ray only proves true things. So, this case cannot hold.

If Ray cannot prove Jack is a Knight, then Jack must be a Knight, since Jack stated the truth. But Ray cannot prove the fact that Jack is a Knight.

In the context of smart contracts and programming languages, Turing complete languages like Solidity come with the possibility of undecidable problems.

These undecidable problems are similar to the paradox presented in the Knights and Knaves story, where it's impossible to determine whether Jack is a Knight or a Knave based on the given information.

In the Knights and Knaves story, Ray is analogous to a theorem prover or a smart contract in a Turing complete language. Ray is faced with a statement that is undecidable within the constraints of the system (Knights and Knaves), which leads to a paradox.

Similarly, a Turing complete smart contract language might face undecidable problems that can't be resolved, leading to unexpected behavior, vulnerabilities, or resource consumption issues (like running out of gas in Ethereum).

On the other hand, non-Turing complete languages like Clarity are designed to avoid undecidable problems by limiting their expressiveness.

In the context of the Knights and Knaves story, a non-Turing complete language would simply not allow Jack to make a statement that could lead to a paradox. By disallowing certain features like unbounded loops and recursion, non-Turing complete languages can provide stronger guarantees about the behavior and resource usage of smart contracts.

This predictability is desirable in many cases, especially when dealing with high-value transactions or critical systems.

### Reference

The Mathematics of Various Entertaining Subjects: Research in Recreational Math Illustrated Edition, Jennifer Beineke (Editor), Jason Rosenhouse (Editor), Raymond M. Smullyan (Foreword), Princeton University Press, 2016.


# sBTC

Design of a Trustless Two-way Peg for Bitcoin

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-4ecdf4182030ceb46a4ac036ea938a92a0013602%2Fimage.png?alt=media" alt=""><figcaption></figcaption></figure></div>

{% hint style="info" %}
For builders and developers, head to the [sBTC guides](https://app.gitbook.com/s/Zz9BLmTU9oydDpL3qiUh/more-guides/sbtc) under the Build section to start integrating sBTC into your Clarity smart contracts and front-end application.
{% endhint %}

### Introduction

sBTC is a SIP-010 token on the Stacks blockchain that represents Bitcoin (BTC) in a 1:1 ratio. It enables Bitcoin holders to participate in DeFi applications and other smart contract functionalities while maintaining a peg to the underlying Bitcoin.

#### Purpose

The primary purpose of sBTC is to bridge Bitcoin to DeFi via the Stacks blockchain, providing Bitcoin holders with access to the rich functionality of smart contracts without sacrificing the security and value of their BTC holdings.

> *Unlocking Bitcoin to be a fully programmable, productive asset would allow Bitcoin to be the*\
> \&#xNAN;*backbone of DeFi and a more secure web3. The ability to move Bitcoin assets in and out of*\
> \&#xNAN;*smart contracts freely and for these contracts to trustlessly write to the Bitcoin blockchain can*\
> \&#xNAN;*unlock hundreds of billions of dollars of passive BTC for web3.*\
> \
> \- sBTC: Design of a Trustless Two-way Peg for Bitcoin

#### Key Benefits

1. **Bitcoin Compatibility**: Allows Bitcoin holders to participate in the Stacks ecosystem without selling their BTC.
2. **Quick Conversions**: Facilitates rapid movement between BTC and sBTC (within 3 Bitcoin blocks for deposit, 6 for withdrawal).
3. **Decentralized Management**: Initially utilizes a set of 15 community-chosen signers for maintaining the peg wallet.
4. **Community Governance**: Involves the community in key decisions, such as selecting the initial signing set.

### Key Concepts

Understanding sBTC requires familiarity with several key concepts:

**sBTC**

sBTC is a [SIP-010](https://github.com/stacksgov/sips/blob/main/sips/sip-010/sip-010-fungible-token-standard.md) token on the Stacks Blockchain that can be converted back to BTC on the Bitcoin Blockchain. The key property of sBTC is its 1:1 peg to Bitcoin, meaning 1 sBTC is always equivalent to 1 BTC.

**sBTC UTXO**

The sBTC UTXO is the single unspent transaction output (UTXO) on the Bitcoin blockchain that holds the entire BTC balance pegged into sBTC. This UTXO is managed and maintained by the set of sBTC Signers.

This UTXO resides in a secure multi-signature taproot address controlled by the sBTC Signers:\
[bc1prcs82tvrz70jk8u79uekwdfjhd0qhs2mva6e526arycu7fu25zsqhyztuy](https://mempool.space/address/bc1prcs82tvrz70jk8u79uekwdfjhd0qhs2mva6e526arycu7fu25zsqhyztuy)

**sBTC Signer**

In sBTC, the sBTC Signer is a signer entity separate from the Stacks Nakamoto signer. sBTC signer responsibilities include:

* Signing sBTC operations
* Communicating with the sBTC contracts on the Stacks chain
* Managing the sBTC UTXO

**sBTC Signer Set**

The sBTC Signer Set is the group of all sBTC signers. This set has full democratic access to the sBTC UTXO and is responsible for maintaining the security of the peg wallet. The signers also have the ability to rotate their private keys for enhanced security.

For more info on who the sBTC Signers are, check out this section on the Bitcoin L2 Labs website [here](https://bitcoinl2labs.com/sbtc-rollout#sbtc-signers).

**Emily API**

Emily is an API that helps facilitate and supervise the sBTC Bridge in addition to serving as a programmatic liaison between sBTC users and signers.

**SIP-010 Token**

sBTC adheres to the [SIP-010](https://github.com/stacksgov/sips/blob/main/sips/sip-010/sip-010-fungible-token-standard.md) standard for fungible tokens on the Stacks blockchain. This ensures compatibility with wallets and applications that support the SIP-010 standard.

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-6dbb8304c63d2bde407f714cb5cb94ea14661ed5%2FGroup%20316124848.png?alt=media" alt=""><figcaption></figcaption></figure>

Understanding these concepts is crucial for grasping the overall architecture and functionality of sBTC. In the following sections, we'll explore how these concepts come together to create sBTC.

***

#### Additional Resources

* \[[sBTC Whitepaper](https://stacks-network.github.io/stacks/sbtc.pdf)] The official sBTC whitepaper
* \[[Stacks Foundation](https://stacks.org/sbtc-on-mainnet)] Official sBTC launch announcement (December 2024)
* \[[Bitcoin Writes](https://www.bitcoinwrites.com/)] Weekly sBTC Updates (last update: August 2024)
* \[[Hiro Blog](https://www.hiro.so/blog/who-are-the-sbtc-signers-breaking-down-sip-028)] Who Are the sBTC Signers: Breaking Down SIP-028


# Core Features

sBTC offers several core features that make it a powerful trust-minimized Bitcoin bridge between Stacks and Bitcoin:

{% stepper %}
{% step %}
**1:1 Bitcoin Backing**

Each sBTC token is backed by an equivalent amount of Bitcoin in the peg wallet. This ensures that sBTC maintains a stable value relative to BTC.
{% endstep %}

{% step %}
**Decentralized Management**

The sBTC peg wallet is maintained and managed by a set of sBTC signers. This decentralized approach enhances security and reduces single points of failure.
{% endstep %}

{% step %}
**Quick Conversions**

sBTC facilitates rapid movement between BTC and sBTC:

* BTC to sBTC conversion can be completed within 3 Bitcoin blocks
* sBTC to BTC conversion can be completed within 6 Bitcoin blocks
  {% endstep %}

{% step %}
**SIP-010 Compatibility**

sBTC adheres to the SIP-010 fungible token standard on the Stacks blockchain. This ensures wide compatibility with Stacks wallets and applications.
{% endstep %}

{% step %}
**Community Governance**

The initial sBTC signing set is determined by a community vote, weighted by STX holdings. This approach ensures that the community has a say in the management of the sBTC system.
{% endstep %}

{% step %}
**Signer Key Rotation**

sBTC signers have the ability to rotate their private keys, enhancing long-term security of the system.
{% endstep %}

{% step %}
**Transaction Fee Sponsorship**

sBTC transactions on Stacks can be sponsored, allowing users to pay transaction fees in sBTC instead of STX.
{% endstep %}
{% endstepper %}


# sBTC Operations

This section covers the main operations in the sBTC system. These operations form the core functionality of sBTC, allowing users to permissionlessly move value between the Bitcoin and Stacks ecosystems.

{% stepper %}
{% step %}
**Deposit**

Converting BTC to sBTC.

* **Increased Utility**: Users can leverage their Bitcoin on the Stacks network by converting BTC to sBTC, providing access to smart contracts and decentralized applications (dApps) that are not natively possible on the Bitcoin network.
* **DeFi Opportunities**: By utilizing sBTC, users can participate in decentralized finance (DeFi) activities such as lending, borrowing, and earning yield on their assets.
* **Cost Efficiency**: Operating on the Stacks network might offer lower transaction fees compared to the Bitcoin network, making it cost-effective for conducting transactions and executing smart contracts.
* **Interoperability**: sBTC allows users to enjoy the benefits of blockchain interoperability, moving their value seamlessly between the Bitcoin and Stacks ecosystems.
* **Network Security**: Stacks enhance security by building on Bitcoin's robustness, providing an added layer of trust and reliability when using sBTC.
  {% endstep %}

{% step %}
**Withdrawal**

Converting sBTC back to BTC.

* **Liquidity Needs**: Users might want to convert sBTC back to BTC to access the deep liquidity available on the Bitcoin network, facilitating easier and potentially faster transactions.
* **Off-Ramping**: Converting sBTC to BTC can allow users to withdraw their funds from the cryptocurrency ecosystem into fiat currency through exchanges that primarily support Bitcoin.
* **Security Preferences**: Some users might prefer holding their assets directly on the Bitcoin network due to its reputation for security and decentralization.
* **Network Preference**: Individuals may choose to operate exclusively within the Bitcoin network for its simplicity and widespread acceptance as a method of payment.
  {% endstep %}
  {% endstepper %}


# Deposit

Converting BTC to sBTC.

The deposit operation enables users to mint sBTC, anchored to the BTC they have placed in the threshold wallet on the Bitcoin chain. This process can be completed within a single Bitcoin block, streamlining the user experience.

## Process Overview

<div data-with-frame="true"><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2FFRo9Sa9MGCHhlOSqT1XF%2FStacks_graphic%20-%2064.png?alt=media&#x26;token=e6d1fc78-05f4-4080-b725-b29da62e8f27" alt="deposit diagram"></div>

The deposit process begins when a user initiates a specific Bitcoin transaction that has two outputs. The depositor (usually through the application they are using to deposit) then initiates an API call referencing that Bitcoin transaction. This call triggers the Emily API, which relays deposit information to the sBTC Signers. These signers verify and process the deposit. Once verified, an equivalent amount of sBTC is minted on the Stacks blockchain.

{% stepper %}
{% step %}
**Script output**

A script that lets the signers spend the funds.
{% endstep %}

{% step %}
**Time-locked output**

A time lock that allows the depositor to reclaim the funds if necessary.
{% endstep %}
{% endstepper %}

The deposit is usually completed within a single Bitcoin block, but is guaranteed to be completed within 3. For more information on deposit and withdrawal confirmation times and why deposits can be so fast, check out the [Deposit and Withdrawal Times](https://docs.stacks.co/learn/sbtc/sbtc-operations/deposit-vs-withdrawal-times) doc.

## Bitcoin Deposit Requirements

For a deposit to be considered valid, it must adhere to specific requirements:

* The deposit must be made to a taproot address.
* The output must be spendable by a consensus threshold of signers.
* The deposit must follow a format that prevents short-term clawbacks, ensuring the security and integrity of the system.

## User Experience

From a user's perspective, the deposit process is straightforward:

1. Initiate a BTC transaction to the specified address.
2. Wait for the transaction to be confirmed on the Bitcoin blockchain.
3. Receive the equivalent amount of sBTC in the Stacks wallet once the deposit is verified and processed.

To enhance the user experience, an sBTC bridge web application is currently in development which will provide an intuitive interface for users to track the status of their deposit operations, allowing users to stay informed throughout the process from initiation to completion.


# Withdrawal

Converting sBTC back to BTC.

The sBTC withdrawal operation enables users to convert their sBTC back to BTC. This process involves burning sBTC on the Stacks blockchain and releasing an equivalent amount of BTC on the Bitcoin blockchain.

## Process Overview

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2FD1Aj5Shr7N4dAFa8FpCP%2FStacks_graphic%20-%2065.png?alt=media&#x26;token=acfa516e-72e9-42d1-97d5-5786129c4e02" alt=""><figcaption></figcaption></figure></div>

<figure><img src="https://lh7-rt.googleusercontent.com/docsz/AD_4nXeNx03RFtUIZTzKCbSnakHtStQl69RWZ7TWRYsW4KvIS2HS-93ghvu3s2U-g5PXbdeCvV_PZUZv1JL3CdPo3Zkm2ZHHmW8BDJIvMoZMFBf256K0fVH07TEazw7EPu7Wixex-inhIAwIzy4WCHwzoUbzpPph_?key=LMMtMf3zwOdkwel07ZrRiw" alt=""><figcaption></figcaption></figure>

{% stepper %}
{% step %}
**Initiate withdrawal**

A user initiates a Clarity contract call (via a Stacks wallet or dApp) specifying:

* the amount of sBTC to withdraw
* the destination Bitcoin address
  {% endstep %}

{% step %}
**Stacks transaction finality**

The Stacks transaction must reach finality. The protocol requires six Bitcoin block confirmations before proceeding to the next step.
{% endstep %}

{% step %}
**Signer verification and BTC release**

After confirmations, sBTC Signers verify the withdrawal request and create the withdrawal transaction on the Bitcoin network, releasing the equivalent BTC to the specified Bitcoin address.
{% endstep %}
{% endstepper %}

The withdrawal process requires six Bitcoin block confirmations to complete. After these confirmations, sBTC Signers create the withdrawal transaction on the Bitcoin network.

## Withdrawal Confirmation

The six-block confirmation requirement serves multiple purposes:

* Ensures finality of the Stacks transaction and prevents potential reversals or conflicts.
* Mitigates issues from potential Bitcoin forks by allowing time for network stability.
* Gives sBTC Signers sufficient time to verify and process the withdrawal request accurately.

For more information on deposit and withdrawal confirmation times and why deposits can be faster than withdrawals, see the [Deposit and Withdrawal Times](https://docs.stacks.co/learn/sbtc/sbtc-operations/deposit-vs-withdrawal-times) doc.

## Failure Cases

Some withdrawal failures can be identified and resolved before the six confirmations are complete. Other failures may only become apparent after the sBTC Bootstrap Signer attempts to create the withdrawal transaction on the Bitcoin network. These delays stem from the complexity of cross-chain operations and the need for thorough verification at each step.

<details>

<summary>More about failure detection timing</summary>

Because cross-chain operations involve verification on both Stacks and Bitcoin, certain issues (for example: insufficient signer consensus, malformed Bitcoin transaction construction, or Bitcoin network conditions) may only be detectable when the signer attempts to broadcast the Bitcoin transaction. This can cause failure detection to occur after confirmations on Stacks are already complete.

</details>

## Security Considerations

{% hint style="info" %}
The multi-block confirmation process is a critical security measure to help prevent double-spending attempts. Requiring multiple block confirmations ensures the withdrawal request is valid and final before processing on the Bitcoin network. Additionally, sBTC Signers perform verification of each withdrawal request prior to creating the Bitcoin transaction, providing an extra security layer.
{% endhint %}

## User Experience

From a user's perspective:

* Initiate a withdrawal through a Stacks wallet or dApp.
* Specify the sBTC amount and destination Bitcoin address.
* Wait for the required six Bitcoin blocks to confirm.
* Once confirmations complete and signers process the request, BTC is sent to the specified Bitcoin address.

The sBTC bridge web application offers a user-friendly interface that lets users track the status of their withdrawal operations in real time, providing updates at each stage so users can understand progress and estimate when they will receive BTC.


# Deposit vs Withdrawal Times

Understanding why the time is takes to deposit BTC to sBTC is different than withdrawing sBTC back into BTC.

### Why are Deposits So Fast and Withdrawals So Slow?

sBTC allows users to use their BTC on the Stacks L2 by using a wrapped token called sBTC. Moving sBTC onto the Stacks L2 can take as little time as 1 Bitcoin block, but moving sBTC off the Stacks L2 into the native Bitcoin blockchain takes 6 Bitcoin blocks. Why is that?

> To understand why moving onto the Stacks layer can be so fast and yet moving off must be so slow, we need to first understand the consensus mechanism of the Stacks blockchain.

The Stacks blockchain uses a consensus mechanism called Proof of Transfer, or PoX, in order to mint new blocks. On each Bitcoin block, miners, on the Stacks blockchain, each sacrifice some amount of Bitcoin in a bid to win the right to make the next few Stacks blocks, where they retain the right to keep making Stacks blocks until the next Bitcoin block occurs and the latest bidding round elects a new Stacks miner.

#### Determining which Stacks blocks should be tied to which Bitcoin block

Signers (validators equivalents for the Stacks Blockchain) look at the Bitcoin blocks and approve new Stacks blocks based on which miner currently has the right to make Stacks blocks, and they only approve new blocks from the miner that won the most recent bid on the Bitcoin block within the fork that they collectively consider to be the “best”. The Stacks blockchain can only have new blocks added if the Signers agree that the miner who proposed it is the winner of the bid on the Bitcoin blockchain, and all the Signers are voting on which block should be added, effectively collectively deciding which Bitcoin fork is the best one.

**Here’s an important part**: if the Signers believe that there’s a new and better Bitcoin fork that differs from the one that the last several Stacks blocks had been mined on, they’ll then only approve new Stacks blocks that build off of existing Stacks blocks that are tied to that new Bitcoin fork. As in, every Stacks block that was built on Bitcoin blocks in the other Bitcoin fork that aren’t in this new canonical fork are considered invalid; thus the Stacks blockchain forks too.

> “The Stacks blockchain forks with the Bitcoin blockchain.”

Now that we understand this forking mechanism, let's take a look at why moving off the Stacks layer must be so slow.

#### **Why moving from sBTC to BTC takes more time**

sBTC exists on the Stacks layer as a token that smart contracts can interact with. To move sBTC over from the Stacks layer to the Bitcoin layer, the owner of the sBTC calls a smart contract to initiate what we call the “withdrawal” sequence. This lets the “sBTC Signers” (these are different from the earlier Signers mentioned) know that they need to create a transaction on the Bitcoin blockchain to distribute the BTC back to the user.

If the sBTC Signers create a Bitcoin transaction to enact the withdrawal, they can’t take it back, and it will be valid on every fork of the Bitcoin blockchain. So what happens if, say, the Bitcoin blockchain forks and the withdrawal on the Stacks layer got reorganized out? Then there’s an irretrievable withdrawal transaction on the Bitcoin blockchain giving precious BTC to a user who never withdrew their sBTC on the Stacks layer.

<details>

<summary>Can the Signers that maintain the original chain force miners to replay all previously confirmed transactions?</summary>

The Stacks blockchain is a true Layer 2 on top of Bitcoin, and you can write a smart contract to have different behavior based on observations of the Bitcoin blockchain underneath. You can, for example, write a Stacks contract that says “Pay to Jeff if the latest Bitcoin block hash ends in an even hex digit, and pay to Abigail if it’s an odd hex digit.” Now when there’s a reorg of the Bitcoin blockchain you can replay this transaction which originally paid to Jeff, but it now pays to Abigail, and what happens if this contract was giving out sBTC, and further what happens if Jeff then immediately executed a withdrawal?

</details>

So in the end, to process a withdrawal safely you need to be sufficiently sure it won’t get reorganized out. That means it can only be processed 6 Bitcoin blocks (the finality criteria the sBTC Signers are comfortable with) after the sBTC withdrawal transaction was made on the Stacks blockchain.

#### But then, why can deposits be done in one Bitcoin block at its fastest?

Remember how Stacks forks with Bitcoin? Let's say someone makes a deposit on the Bitcoin blockchain in an attempt to mint sBTC, and then lets say the sBTC Signers immediately mint sBTC. What happens if the Bitcoin chain forks causing the Stacks blockchain to fork? The mint gets reorganized out! Sure, the deposit is no longer on the Bitcoin blockchain, but it’s not on the Stacks blockchain either. If that deposit doesn’t ever arrive on the Bitcoin blockchain the sBTC signers will never mint sBTC, so there’s nothing to take back!

#### The Bitcoin chain gets the final say

So all in all, for movements of sBTC from the Stacks layer into the Bitcoin layer the protocol needs to wait for Bitcoin to be sufficiently final, but movements from the Bitcoin layer to the Stacks layer don’t need to wait for finality to mint because the Stacks layer will just reorganize itself if the Bitcoin layer reorganizes too.

But then conceptually remember, the mint call on the Stacks blockchain is just as final as the Bitcoin block that contains the deposit of BTC onto the Stacks layer. If you’re minting sBTC on the Stacks layer and you want to wait for it to be final you’ll need to wait a suitable number of Bitcoin blocks to consider it finally minted, but that’s up to you and not the sBTC Signers.


# Emily API

[Emily](https://github.com/stacks-network/sbtc/tree/main/emily) is an API that helps facilitate and supervise the sBTC Bridge, serving as a programmatic liaison between sBTC users and signers.

## Overview

The Emily API is designed to track deposits and withdrawals, providing information about the status of in-flight sBTC operations. It serves two primary user groups: sBTC users and sBTC app developers.

### Why Call it Emily?

The Emily API is given an indirect name because it handles more than just Deposits and Withdrawals; it can detect the health of the system and will likely be extended to handle more as user requirements mature. It was once called the “Revealer API”, which stopped making sense after a few design changes, and then “Deposit API” which also stopped making sense after a few changes. The most obvious choice “sBTC API” gives the wrong impression of what the API is responsible for as well, since the API itself isn’t managing the entirety of the protocol.

Large companies name their APIs after something loosely related but ambiguous enough that extensions of the API don’t make the original name of the API misleading. Following this, we chose “Emily” after Emily Warren Roebling who was the liaison between the builders and chief engineer, her husband, of the Brooklyn bridge. She was, in effect, the supervisor of the bridge’s construction; similarly, the Emily API supervises the sBTC bridge and liaises between the users of the protocol and the sBTC signers.

### Key Features

* Track Deposits: Monitor the process of converting BTC to sBTC.
* Track Withdrawals: Monitor the process of converting sBTC back to BTC.
* Provide Operation Status: Offer real-time status updates for ongoing sBTC operations.
* Retrieve Historical Data: Allow querying of past sBTC operations.

## Core Concepts

#### sBTC Operations

sBTC operations are the fundamental processes tracked by Emily:

* Deposits: Converting BTC to sBTC
* Withdrawals: Converting sBTC back to BTC

#### Operation States

Each sBTC operation goes through several states:

* PENDING: The operation has been initiated.
* ACCEPTED: The operation has been approved by the signers.
* CONFIRMED: The operation has been completed and confirmed on the blockchain.
* FAILED: The operation could not be completed.

### Where Emily is involved in the sBTC flows

In each of the deposit and withdrawal flows for sBTC, Emily plays a vital role. Here's where Emily sits in both the Deposit and Withdrawal flows.

#### **During the Deposit Flow**

1. User creates a deposit transaction on Bitcoin
2. User submits proof of deposit to the Deposit API
3. **Emily records the deposit as PENDING**
4. Signers validate and vote on the deposit
5. **If accepted, Emily updates status to ACCEPTED**
6. Signers process the Bitcoin transaction
7. Signers mint sBTC on Stacks
8. **Emily updates the deposit status to CONFIRMED**

#### **During the Withdrawal Flow**

1. User initiates withdrawal through the sBTC Clarity contract
2. **Emily records the withdrawal as PENDING**
3. Signers decide to accept or reject the withdrawal
4. **If accepted, Emily updates status to ACCEPTED**
5. Signers process the Bitcoin transaction
6. Signers burn sBTC on Stacks
7. **Emily updates the withdrawal status to CONFIRMED**


# Peg Wallet UTXO

The Peg Wallet UTXO is a fundamental element of the sBTC system, serving as the Bitcoin backing for all sBTC tokens in circulation. The system uses a Single UTXO Model: the sBTC peg wallet is consistently represented as a single Unspent Transaction Output (UTXO) on the Bitcoin blockchain. This design offers simplicity and improved efficiency in managing the peg wallet.

{% hint style="info" %}
This UTXO resides in a secure multi-signature taproot address controlled by the sBTC Signers:\
[bc1prcs82tvrz70jk8u79uekwdfjhd0qhs2mva6e526arycu7fu25zsqhyztuy](https://mempool.space/address/bc1prcs82tvrz70jk8u79uekwdfjhd0qhs2mva6e526arycu7fu25zsqhyztuy)
{% endhint %}

## Overview

* Single UTXO Model: the peg wallet is always a single UTXO.
* Responsibility: UTXO management is performed by the Signer set.
* Purpose: simplify tracking and management, reduce Bitcoin transactions required for sBTC operations, and centralize funds in a single, well-secured output.

## How the Single UTXO is maintained

{% stepper %}
{% step %}
**Constructing the new UTXO**

A Signer coordinator constructs the UTXO by creating a new Bitcoin output that will represent the peg wallet going forward.
{% endstep %}

{% step %}
**Consolidating requests into a batch**

The Signer set collectively consolidates all deposit and withdrawal requests and creates optimized batches that can be processed within a single UTXO.
{% endstep %}

{% step %}
**Creating the new UTXO from the previous UTXO**

The new UTXO is created by:

* spending the amount from the previous UTXO,
* adding confirmed deposits,
* subtracting confirmed withdrawals.
  {% endstep %}

{% step %}
**Optimizing batching with approval sets**

When multiple sBTC operation requests are present, the Signer coordinator groups them by approval sets. If differing approval sets exist across active operations, the coordinator batches deposit UTXOs into groups with the maximum size per approval set to preserve the single UTXO invariant while maximizing batch efficiency.
{% endstep %}
{% endstepper %}

## Benefits

* Simplified tracking and management of peg funds.
* Fewer Bitcoin transactions for sBTC operations.
* Centralized funds in a single, well-secured output improves operational efficiency.

{% hint style="info" %}
The Single UTXO Model is designed to balance simplicity and operational efficiency for the sBTC peg wallet.
{% endhint %}

## Security considerations

* The single UTXO is managed by the sBTC Bootstrap Signer Set, which requires a threshold of signers to approve any spending (multi-signature).
* Regular audits and continuous monitoring are essential to ensure the UTXO accurately represents the total sBTC in circulation at all times.

{% hint style="warning" %}
Security is paramount: multi-signature approval, audits, and monitoring are core controls to protect the peg wallet.
{% endhint %}


# Clarity Contracts

The Clarity contracts responsible for sBTC's logic and interactions on Stacks.

### Deployed Mainnet Contracts

* [sbtc-token](https://explorer.hiro.so/txid/SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-token?chain=mainnet)
* [sbtc-registry](https://explorer.hiro.so/txid/SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-registry?chain=mainnet)
* [sbtc-deposit](https://explorer.hiro.so/txid/SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-deposit?chain=mainnet)
* [sbtc-withdrawal](https://explorer.hiro.so/txid/SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-withdrawal?chain=mainnet)
* [sbtc-bootstrap-signers](https://explorer.hiro.so/txid/SM3VDXK3WZZSA84XXFKAFAF15NNZX32CTSG82JFQ4.sbtc-bootstrap-signers?chain=mainnet)

This graph summarizes the Clarity portion of the sBTC protocol.

<figure><img src="https://lh7-rt.googleusercontent.com/docsz/AD_4nXe6LEEESrk6Az-iRR5ZeEuqOQvBESKtFvBIjSYPhAjLZ2LpEwM-UOnSWn4b6hFFv0uFnysxL6wO-BVgJaPTAdYUkbvBenJrY8rY-YrGT9CSwqdCl2kuS5ZhNheumR-yBPAOHtccAt1eOD4dU5Zi-14gBgwv?key=uPKXlfIDnNUlnyka_NtgIw" alt=""><figcaption></figcaption></figure>

### sBTC Clarity Contracts

At a high level, the sBTC Clarity contracts are responsible for the following:

#### sbtc-bootstrap signers

Core contract for meta signer functionality such as registration & the rotation process.

#### sbtc-deposit

Processing contract called by the signers to record a consumed Bitcoin transaction & mint some amount of sBTC to a principal contained in the payload.

#### sbtc-registry

State storage for maintaining upgradability across protocol.

#### sbtc-withdrawal

Interaction points for users and signers to update withdrawal request state.

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-6dbb8304c63d2bde407f714cb5cb94ea14661ed5%2FGroup%20316124848.png?alt=media" alt=""><figcaption></figcaption></figure>

### User Types

In addition to the contracts themselves, there are two main user types that will interact with these contracts.

#### Signer

A signer that is part of the current sBTC signer set. More information on signers and their role in sBTC can be found in the [Signer Process Walkthrough](https://docs.stacks.co/learn/sbtc/walkthroughs/signer-process-walkthrough).

#### Wallet

A participant in the Stacks/Bitcoin ecosystem that wants to deposit/withdraw/use sbtc.


# sBTC Signers

### Overview

The [sBTC Signers contract](https://github.com/stacks-network/sbtc/blob/main/contracts/contracts/sbtc-bootstrap-signers.clar) (`sbtc-bootstrap-signers.clar`) manages the signer set for the sBTC system. It handles rotation of signer keys and provides utilities for generating multisig addresses.

**Constants**

* `key-size`: The required length of public keys (33 bytes).

**Error Constants**

* `ERR_KEY_SIZE_PREFIX`: Prefix for key size errors in batch processing.
* `ERR_KEY_SIZE` (u200): Indicates that a provided key is not the correct length.
* `ERR_INVALID_CALLER` (u201): Signifies that the function caller is not the current signer principal.
* `ERR_SIGNATURE_THRESHOLD` (u202): Indicates an invalid signature threshold (must be >50% and ≤100% of total signer keys).

#### Public Functions

**`rotate-keys-wrapper`**

Rotates the keys of the signers. Called when the signer set is updated.

* Parameters:
  * `new-keys`: `(list 128 (buff 33))` - List of new signer public keys
  * `new-aggregate-pubkey`: `(buff 33)` - New aggregate public key
  * `new-signature-threshold`: `uint` - New signature threshold
* Returns: `(response (buff 33) uint)`

Function flow:

{% stepper %}
{% step %}
**Validate signature threshold**

Ensure the new signature threshold is valid (must be >50% and ≤100% of total signer keys).
{% endstep %}

{% step %}
**Verify caller**

Verify that the caller is the current signer principal.
{% endstep %}

{% step %}
**Validate keys**

Check the length of each new key and the aggregate public key (must be 33 bytes).
{% endstep %}

{% step %}
**Update registry**

Call the sBTC Registry contract to update the keys and address.
{% endstep %}
{% endstepper %}

#### Read-only Functions

**`pubkeys-to-spend-script`**

Generates the p2sh redeem script for a multisig.

* Parameters:
  * `pubkeys`: `(list 128 (buff 33))` - List of public keys
  * `m`: `uint` - Number of required signatures
* Returns: `(buff 1024)` - The p2sh redeem script

**`pubkeys-to-hash`**

Computes the hash160 of the p2sh redeem script.

* Parameters:
  * `pubkeys`: `(list 128 (buff 33))` - List of public keys
  * `m`: `uint` - Number of required signatures
* Returns: `(buff 20)` - The hash160 of the redeem script

**`pubkeys-to-principal`**

Generates a principal (Stacks address) from a set of pubkeys and an m-of-n threshold.

* Parameters:
  * `pubkeys`: `(list 128 (buff 33))` - List of public keys
  * `m`: `uint` - Number of required signatures
* Returns: `principal` - The generated Stacks address

**`pubkeys-to-bytes`**

Concatenates a list of pubkeys into a buffer with length prefixes.

* Parameters:
  * `pubkeys`: `(list 128 (buff 33))` - List of public keys
* Returns: `(buff 510)` - Concatenated pubkeys with length prefixes

**`concat-pubkeys-fold`**

Concatenates a pubkey buffer with a length prefix.

* Parameters:
  * `pubkey`: `(buff 33)` - A single public key
  * `iterator`: `(buff 510)` - Accumulator for concatenation
* Returns: `(buff 510)` - Updated concatenated buffer

**`bytes-len`**

Returns the length of a byte buffer as a single byte.

* Parameters:
  * `bytes`: `(buff 33)` - Input byte buffer
* Returns: `(buff 1)` - Length as a single byte

**`uint-to-byte`**

Converts a uint to a single byte.

* Parameters:
  * `n`: `uint` - Input number
* Returns: `(buff 1)` - Number as a single byte

#### Private Functions

**`signer-key-length-check`**

Checks that the length of each key is exactly 33 bytes.

* Parameters:
  * `current-key`: `(buff 33)` - Public key to check
  * `helper-response`: `(response uint uint)` - Accumulator for error handling
* Returns: `(response uint uint)` - Updated accumulator or error

#### Constants

**`BUFF_TO_BYTE`**

A constant list mapping uint values (0-255) to their corresponding byte representations.

Interactions with Other Contracts

* `.sbtc-registry`: Calls `get-current-signer-data` and `rotate-keys` to manage signer data.

Security Considerations

{% hint style="warning" %}

* Access Control: Only the current signer principal can call the key rotation function.
* Key Validation: Ensures all provided keys are the correct length.
* Signature Threshold: Enforces a minimum threshold of over 50% of signers and a maximum of 100%.
* Multisig Generation: Provides utilities for secure generation of multisig addresses.
  {% endhint %}


# sBTC Token

## Overview

The [sBTC Token contract](https://github.com/stacks-network/sbtc/blob/main/contracts/contracts/sbtc-token.clar) (`sbtc-token.clar`) implements the fungible token functionality for sBTC. It manages both unlocked and locked sBTC tokens and provides functions for minting, burning, transferring, and querying token information. sBTC is a SIP-010 standard fungible token.

## Constants

* `ERR_NOT_OWNER` (u4): Error when the sender tries to move a token they don't own.
* `ERR_NOT_AUTH` (u5): Error when the caller is not an authorized protocol caller.
* `token-decimals` (u8): The number of decimal places for the token.

## Fungible Tokens

* `sbtc-token`: The main sBTC fungible token.
* `sbtc-token-locked`: Represents locked sBTC tokens.

## Data Variables

* `token-name`: The name of the token (default: "sBTC").
* `token-symbol`: The symbol of the token (default: "sBTC").
* `token-uri`: An optional URI for token metadata.

## Protocol Functions

These functions can only be called by authorized protocol contracts:

### protocol-transfer

* Parameters: `amount: uint`, `sender: principal`, `recipient: principal`
* Returns: `(response bool uint)`

### protocol-lock

* Parameters: `amount: uint`, `owner: principal`
* Returns: `(response bool uint)`

### protocol-unlock

* Parameters: `amount: uint`, `owner: principal`
* Returns: `(response bool uint)`

### protocol-mint

* Parameters: `amount: uint`, `recipient: principal`
* Returns: `(response bool uint)`

### protocol-burn

* Parameters: `amount: uint`, `owner: principal`
* Returns: `(response bool uint)`

### protocol-burn-locked

* Parameters: `amount: uint`, `owner: principal`
* Returns: `(response bool uint)`

### protocol-set-name

* Parameters: `new-name: (string-ascii 32)`
* Returns: `(response bool uint)`

### protocol-set-symbol

* Parameters: `new-symbol: (string-ascii 10)`
* Returns: `(response bool uint)`

### protocol-set-token-uri

* Parameters: `new-uri: (optional (string-utf8 256))`
* Returns: `(response bool uint)`

### protocol-mint-many

* Parameters: `recipients: (list 200 {amount: uint, recipient: principal})`
* Returns: `(response (list 200 (response bool uint)) uint)`

## Public Functions (SIP-010 Trait)

### transfer

* Parameters: `amount: uint`, `sender: principal`, `recipient: principal`, `memo: (optional (buff 34))`
* Returns: `(response bool uint)`

### get-name

* Returns: `(response (string-ascii 32) uint)`

### get-symbol

* Returns: `(response (string-ascii 10) uint)`

### get-decimals

* Returns: `(response uint uint)`

### get-balance

Returns the total balance (locked + unlocked) for a principal.

* Parameters: `who: principal`
* Returns: `(response uint uint)`

### get-balance-available

Returns the available (unlocked) balance for a principal.

* Parameters: `who: principal`
* Returns: `(response uint uint)`

### get-balance-locked

Returns the locked balance for a principal.

* Parameters: `who: principal`
* Returns: `(response uint uint)`

### get-total-supply

* Returns: `(response uint uint)`

### get-token-uri

* Returns: `(response (optional (string-utf8 256)) uint)`

## Private Functions

### protocol-mint-many-iter

* Helper function for minting tokens to multiple recipients.
* Parameters: `item: {amount: uint, recipient: principal}`
* Returns: `(response bool uint)`

## Security Considerations

{% stepper %}
{% step %}
**Access Control**

Protocol functions can only be called by authorized contracts, enforced through the `sbtc-registry` contract.
{% endstep %}

{% step %}
**Ownership Verification**

The `transfer` function checks that the sender owns the tokens being transferred.
{% endstep %}

{% step %}
**Separate Token Tracking**

The contract maintains separate tracking for locked and unlocked tokens, ensuring proper accounting.
{% endstep %}
{% endstepper %}

## Interactions with Other Contracts

* `.sbtc-registry`: Used to validate protocol callers for privileged operations.


# sBTC Registry

## Overview

The [sBTC Registry contract](https://github.com/stacks-network/sbtc/blob/main/contracts/contracts/sbtc-registry.clar) (`sbtc-registry.clar`) serves as the central registry for the sBTC system. It manages withdrawal requests, completed deposits, and the current signer set. This contract is crucial for maintaining the state and coordinating operations within the sBTC ecosystem.

## Error Constants

* `ERR_UNAUTHORIZED` (u400): Indicates unauthorized access.
* `ERR_INVALID_REQUEST_ID` (u401): Signifies an invalid withdrawal request ID.
* `ERR_AGG_PUBKEY_REPLAY` (u402): Indicates an attempt to replay an aggregate public key.
* `ERR_MULTI_SIG_REPLAY` (u403): Signifies an attempt to replay a multi-signature address.

## State Variables

* `last-withdrawal-request-id`: Tracks the latest withdrawal request ID.
* `current-signature-threshold`: Stores the current threshold for required signatures.
* `current-signer-set`: Maintains a list of current signer public keys.
* `current-aggregate-pubkey`: Holds the current aggregate public key.
* `current-signer-principal`: Stores the current signer's principal address.

## Data Maps

### withdrawal-requests

Stores withdrawal request details indexed by request ID.

* Fields:
  * `amount`: Amount of sBTC being withdrawn (in sats)
  * `max-fee`: Maximum fee for the withdrawal
  * `sender`: Principal of the sender
  * `recipient`: BTC recipient address (version and hashbytes)
  * `block-height`: Burn block height where the request was created

### withdrawal-status

Tracks the status of withdrawal requests indexed by request ID.

* Value: `bool` (true if accepted, false if rejected, none if pending)

### completed-deposits

Records completed deposit transactions to prevent replay attacks.

* Key: `{txid: (buff 32), vout-index: uint}`
* Value: `{amount: uint, recipient: principal}`

### aggregate-pubkeys

Tracks used aggregate public keys to prevent replay attacks.

* Key: `(buff 33)` (aggregate public key)
* Value: `bool`

### multi-sig-address

Tracks used multi-signature addresses to prevent replay attacks.

* Key: `principal` (multi-sig address)
* Value: `bool`

### protocol-contracts

Stores authorized protocol contract addresses.

* Key: `principal` (contract address)
* Value: `bool`

## Read-only Functions

### get-withdrawal-request

Retrieves a withdrawal request by its ID.

* Parameters:
  * `id`: `uint`
* Returns: `(optional {amount: uint, max-fee: uint, sender: principal, recipient: {version: (buff 1), hashbytes: (buff 32)}, block-height: uint, status: (optional bool)})`

### get-completed-deposit

Fetches a completed deposit by transaction ID and output index.

* Parameters:
  * `txid`: `(buff 32)`
  * `vout-index`: `uint`
* Returns: `(optional {amount: uint, recipient: principal})`

### get-current-signer-data

Returns current signer set information.

* Returns: `{current-signer-set: (list 128 (buff 33)), current-aggregate-pubkey: (buff 33), current-signer-principal: principal, current-signature-threshold: uint}`

### get-current-aggregate-pubkey

Returns the current aggregate public key.

* Returns: `(buff 33)`

### get-current-signer-principal

Returns the current signer's principal.

* Returns: `principal`

### get-current-signer-set

Returns the current set of signer public keys.

* Returns: `(list 128 (buff 33))`

## Public Functions

### create-withdrawal-request

Creates a new withdrawal request. Only callable by protocol contracts.

* Parameters:
  * `amount`: `uint`
  * `max-fee`: `uint`
  * `sender`: `principal`
  * `recipient`: `{version: (buff 1), hashbytes: (buff 32)}`
  * `height`: `uint`
* Returns: `(response uint uint)`

### complete-withdrawal-accept

Marks a withdrawal request as accepted.

* Parameters:
  * `request-id`: `uint`
  * `bitcoin-txid`: `(buff 32)`
  * `output-index`: `uint`
  * `signer-bitmap`: `uint`
  * `fee`: `uint`
* Returns: `(response bool uint)`

### complete-withdrawal-reject

Marks a withdrawal request as rejected.

* Parameters:
  * `request-id`: `uint`
  * `signer-bitmap`: `uint`
* Returns: `(response bool uint)`

### complete-deposit

Records a completed deposit transaction.

* Parameters:
  * `txid`: `(buff 32)`
  * `vout-index`: `uint`
  * `amount`: `uint`
  * `recipient`: `principal`
* Returns: `(response bool uint)`

### rotate-keys

Updates the signer set, multi-sig principal, and aggregate public key.

* Parameters:
  * `new-keys`: `(list 128 (buff 33))`
  * `new-address`: `principal`
  * `new-aggregate-pubkey`: `(buff 33)`
  * `new-signature-threshold`: `uint`
* Returns: `(response (buff 33) uint)`

## Private Functions

### increment-last-withdrawal-request-id

Increments and returns the next withdrawal request ID.

* Returns: `uint`

### is-protocol-caller

Checks if the caller is an authorized protocol contract.

* Returns: `(response bool uint)`

### validate-protocol-caller

Validates if a given principal is an authorized protocol contract.

* Parameters:
  * `caller`: `principal`
* Returns: `(response bool uint)`

## Events

The contract emits events (via `print`) for important actions:

* Withdrawal request creation: "withdrawal-create"
* Withdrawal acceptance: "withdrawal-accept"
* Withdrawal rejection: "withdrawal-reject"
* Deposit completion: "completed-deposit"

{% hint style="info" %}
Events are emitted via `print` statements in the contract for the actions listed above.
{% endhint %}

## Security Considerations

{% stepper %}
{% step %}
**Access Control**

Only authorized protocol contracts can call certain functions.
{% endstep %}

{% step %}
**Replay Prevention**

The contract prevents replay attacks on deposits, aggregate public keys, and multi-signature addresses.
{% endstep %}

{% step %}
**State Management**

The contract carefully manages the state of withdrawals and the current signer set.
{% endstep %}
{% endstepper %}


# sBTC Withdrawal

## Overview

The [sBTC Withdrawal contract](https://github.com/stacks-network/sbtc/blob/main/contracts/contracts/sbtc-withdrawal.clar) (`sbtc-withdrawal.clar`) manages the withdrawal process for the sBTC system. It handles the initiation, acceptance, and rejection of withdrawal requests, ensuring proper validation and interaction with other sBTC contracts.

## Constants

### Error Codes

* `ERR_INVALID_ADDR_VERSION` (u500): Invalid address version.
* `ERR_INVALID_ADDR_HASHBYTES` (u501): Invalid address hashbytes.
* `ERR_DUST_LIMIT` (u502): Withdrawal amount below dust limit.
* `ERR_INVALID_REQUEST` (u503): Invalid withdrawal request ID.
* `ERR_INVALID_CALLER` (u504): Caller is not the current signer principal.
* `ERR_ALREADY_PROCESSED` (u505): Withdrawal request already processed.
* `ERR_FEE_TOO_HIGH` (u505): Paid fee higher than requested.
* `ERR_WITHDRAWAL_INDEX_PREFIX`: Prefix for withdrawal index errors.
* `ERR_WITHDRAWAL_INDEX` (u506): General withdrawal index error.

### Other Constants

* `MAX_ADDRESS_VERSION` (u6): Maximum value of an address version.
* `MAX_ADDRESS_VERSION_BUFF_20` (u4): Maximum version for 20-byte hashbytes.
* `MAX_ADDRESS_VERSION_BUFF_32` (u6): Maximum version for 32-byte hashbytes.
* `DUST_LIMIT` (u546): Minimum amount of sBTC for withdrawal.

## Public Functions

### initiate-withdrawal-request

Initiates a new withdrawal request.

* Parameters:
  * `amount`: `uint` - Amount of sBTC to withdraw
  * `recipient`: `{ version: (buff 1), hashbytes: (buff 32) }` - Bitcoin address details
  * `max-fee`: `uint` - Maximum fee for the withdrawal
* Returns: `(response uint uint)`

### accept-withdrawal-request

Accepts a withdrawal request.

* Parameters:
  * `request-id`: `uint` - Withdrawal request ID
  * `bitcoin-txid`: `(buff 32)` - Bitcoin transaction ID
  * `signer-bitmap`: `uint` - Bitmap of signers
  * `output-index`: `uint` - Output index in the Bitcoin transaction
  * `fee`: `uint` - Actual fee paid
* Returns: `(response bool uint)`

### reject-withdrawal-request

Rejects a withdrawal request.

* Parameters:
  * `request-id`: `uint` - Withdrawal request ID
  * `signer-bitmap`: `uint` - Bitmap of signers
* Returns: `(response bool uint)`

### complete-withdrawals

Processes multiple withdrawal requests (accept or reject).

* Parameters:
  * `withdrawals`: `(list 600 {...})` - List of withdrawal details
* Returns: `(response uint uint)`

## Read-only Functions

### validate-recipient

Validates the recipient's Bitcoin address format.

* Parameters:
  * `recipient`: `{ version: (buff 1), hashbytes: (buff 32) }` - Bitcoin address details
* Returns: `(response bool uint)`

## Private Functions

### complete-individual-withdrawal-helper

Helper function to process individual withdrawals in the batch operation.

* Parameters:
  * `withdrawal`: `{...}` - Individual withdrawal details
  * `helper-response`: `(response uint uint)` - Accumulator for processing
* Returns: `(response uint uint)`

## Interactions with Other Contracts

* `.sbtc-token`: Calls `protocol-lock`, `protocol-burn-locked`, `protocol-mint`, and `protocol-unlock` for token operations.
* `.sbtc-registry`: Calls `create-withdrawal-request`, `get-withdrawal-request`, `get-current-signer-data`, `complete-withdrawal-accept`, and `complete-withdrawal-reject` for managing withdrawal requests and signer data.

## Security Considerations

{% stepper %}
{% step %}
**Access Control**

Only the current signer principal can accept or reject withdrawal requests.
{% endstep %}

{% step %}
**Dust Limit**

Enforces a minimum withdrawal amount to prevent spam and ensure economic viability.
{% endstep %}

{% step %}
**Fee Management**

Ensures that the actual fee doesn't exceed the maximum fee set by the user.
{% endstep %}

{% step %}
**Address Validation**

Implements thorough validation of Bitcoin address formats.
{% endstep %}

{% step %}
**State Management**

Prevents double-processing of withdrawal requests.
{% endstep %}
{% endstepper %}

## Bitcoin Address Types

The contract supports various Bitcoin address types, including:

* P2PKH (Pay-to-Public-Key-Hash)
* P2SH (Pay-to-Script-Hash)
* P2SH-P2WPKH (P2SH nested P2WPKH)
* P2SH-P2WSH (P2SH nested P2WSH)
* P2WPKH (Pay-to-Witness-Public-Key-Hash)
* P2WSH (Pay-to-Witness-Script-Hash)
* P2TR (Pay-to-Taproot)

Each address type is represented by a specific version byte and hashbytes format in the recipient structure.


# sBTC Deposit

## Overview

The [sBTC Deposit contract](https://github.com/stacks-network/sbtc/blob/main/contracts/contracts/sbtc-deposit.clar) (`sbtc-deposit.clar`) manages the deposit process for the sBTC system. It handles the validation and minting of sBTC tokens when users deposit Bitcoin, and interacts with the sBTC Registry contract to update the protocol state.

## Constants

* `txid-length`: The required length of a transaction ID (32 bytes).
* `dust-limit`: The minimum amount for a valid deposit (546 satoshis).

## Error Constants

* `ERR_TXID_LEN` (u300): Indicates that the provided transaction ID is not the correct length.
* `ERR_DEPOSIT_REPLAY` (u301): Signifies an attempt to replay a deposit that has already been completed.
* `ERR_LOWER_THAN_DUST` (u302): Indicates that the deposit amount is below the dust limit.
* `ERR_DEPOSIT_INDEX_PREFIX`: Used as a prefix for deposit-related errors in batch processing.
* `ERR_DEPOSIT` (u303): General deposit error.
* `ERR_INVALID_CALLER` (u304): Indicates that the caller is not authorized to perform the operation.

***

## Public Functions

### complete-deposit-wrapper

Processes a single deposit request.

* Parameters:
  * `txid`: `(buff 32)` - The Bitcoin transaction ID
  * `vout-index`: `uint` - The output index of the deposit transaction
  * `amount`: `uint` - The amount of sBTC to mint (in satoshis)
  * `recipient`: `principal` - The Stacks address to receive the minted sBTC
* Returns: `(response bool uint)`

{% stepper %}
{% step %}
**Validation and authorization**

1. Verifies that the caller is the current signer principal.
2. Checks that the deposit amount is above the dust limit.
3. Validates the transaction ID length.
   {% endstep %}

{% step %}
**Replay protection**

4. Ensures the deposit hasn't been processed before (prevents replay).
   {% endstep %}

{% step %}
**Execution**

5. Mints sBTC tokens to the recipient via `.sbtc-token`'s `protocol-mint`.
6. Updates the deposit state in the sBTC Registry contract via `.sbtc-registry`'s `complete-deposit`.
   {% endstep %}
   {% endstepper %}

***

### complete-deposits-wrapper

Processes multiple deposit requests in a single transaction.

* Parameters:
  * `deposits`: `(list 650 {txid: (buff 32), vout-index: uint, amount: uint, recipient: principal})` - List of deposit data
* Returns: `(response uint uint)`

{% stepper %}
{% step %}
**Authorization**

1. Verifies that the caller is the current signer principal.
   {% endstep %}

{% step %}
**Batch processing**

2. Iterates through the list of deposits, processing each one using the `complete-individual-deposits-helper` function.
   {% endstep %}
   {% endstepper %}

***

## Private Functions

### complete-individual-deposits-helper

Helper function to process individual deposits within the batch operation.

* Parameters:
  * `deposit`: `{txid: (buff 32), vout-index: uint, amount: uint, recipient: principal}` - Single deposit data
  * `helper-response`: `(response uint uint)` - Accumulator for tracking processed deposits
* Returns: `(response uint uint)`

{% stepper %}
{% step %}
**Call deposit wrapper**

1. Calls `complete-deposit-wrapper` for the individual deposit.
   {% endstep %}

{% step %}
**Success handling**

2. If successful, increments the processed deposit count.
   {% endstep %}

{% step %}
**Error handling**

3. If an error occurs, it's propagated with additional index information (using `ERR_DEPOSIT_INDEX_PREFIX` or related error constants).
   {% endstep %}
   {% endstepper %}

***

## Interactions with Other Contracts

* `.sbtc-registry`: Calls `get-current-signer-data`, `get-completed-deposit`, and `complete-deposit` to manage deposit state.
* `.sbtc-token`: Calls `protocol-mint` to create new sBTC tokens.

***

## Security Considerations

1. Access Control: Only the current signer principal can call the deposit completion functions.
2. Replay Prevention: The contract checks for previously processed deposits to prevent replay attacks.
3. Dust Limit: Enforces a minimum deposit amount to prevent spam and ensure economic viability.
4. Transaction ID Validation: Ensures the provided transaction ID is the correct length.


# Auxiliary Features

This section covers additional features that enhance the functionality and security of the sBTC system. These auxiliary features contribute to the overall robustness and user-friendliness of the sBTC ecosystem.

{% stepper %}
{% step %}
**Transaction Fee Sponsorship**

Allowing sBTC transactions to be sponsored.
{% endstep %}

{% step %}
**Signer Wallet Rotation**

Enabling secure key rotation for sBTC Signers.
{% endstep %}
{% endstepper %}


# Transaction Fee Sponsorship

Transaction Fee Sponsorship is a feature in sBTC that allows users to pay for Stacks transaction fees using sBTC instead of STX.

## Overview

* sBTC transactions on Stacks can be sponsored in return for some sBTC.
* This feature improves user experience by allowing sBTC holders to use their tokens for gas fees.

## Implementation

The fee sponsorship system is implemented using the approach suggested in [stacks-network/stacks-core#4235](https://github.com/stacks-network/stacks-core/issues/4235).

{% stepper %}
{% step %}
**Sponsor support for fees**

sBTC users can get support from existing STX holders for transaction fees.
{% endstep %}

{% step %}
**Sponsor receives sBTC**

The sponsor pays the STX fee and receives sBTC in return.
{% endstep %}
{% endstepper %}

## User Experience

From a user's perspective:

{% stepper %}
{% step %}
**Opt into fee sponsorship**

When initiating an sBTC transaction, they can opt for fee sponsorship.
{% endstep %}

{% step %}
**Agree to sponsorship terms**

The user agrees to pay a small amount of sBTC for the sponsorship.
{% endstep %}

{% step %}
**Transaction processed**

The transaction is then processed with the fees paid in STX by the sponsor.
{% endstep %}
{% endstepper %}

## Benefits

* Improved UX: Users don't need to hold STX to use sBTC.
* Lower Barrier to Entry: New users can start using sBTC without first acquiring STX.
* Flexibility: Provides an additional option for handling transaction fees.


# Signer Wallet Rotation

Signer wallet rotation allows sBTC signers to update their private keys and modify the signer set composition. This mechanism is how the network maintains security over time and adapts to changing participants.

## How it works

The sBTC system uses a multi-signature wallet on Bitcoin to custody BTC deposits. When the system needs to change who controls this wallet—either by rotating keys or changing the signer set—it uses the rotation mechanism.

As of v1.1.0, the system supports:

* Adding new signers to the set
* Removing existing signers
* Replacing specific signers
* Rotating keys for current signers

When signers agree on a new configuration, the system automatically runs a Distributed Key Generation (DKG) protocol to create new signing shares for the updated group. Once complete, control of the sBTC wallet transfers to the new configuration.

## The rotation process

{% stepper %}
{% step %}
**Signers coordinate off-chain**

Signers agree on the new signer set.
{% endstep %}

{% step %}
**Update configuration**

Each signer operator updates their configuration with the newly decided set.
{% endstep %}

{% step %}
**DKG runs automatically**

Once all signers have configured the exact same set of signers, DKG occurs automatically to generate new signing shares.
{% endstep %}

{% step %}
**New signer set takes control**

The new signer set takes control of the sBTC wallet.
{% endstep %}
{% endstepper %}

The Bitcoin UTXOs remain under continuous control throughout this process—there's no moment where funds are unsecured.

## When rotation occurs

Key rotation typically happens when:

* **Signer changes**: When someone leaves the signer set or new participants join, the configuration must be updated to reflect the new membership.
* **Security events**: If a key might be compromised, an emergency rotation can be initiated to secure the system.


# Walkthroughs

These walkthroughs describe at a high level exactly how users and signers can expect to interact with the sBTC system.

Read these to get a firm understanding of what is actually happening under the hood of the sBTC system.


# Signer Process Walkthrough

## Introduction

This document provides a detailed overview of the sBTC system, focusing on the operations of an sBTC signer node. We'll explore the automated processes and software interactions that occur in the sBTC ecosystem.

A step-by-step guide for setting up and running a sBTC signer node is in the works. This is a conceptual guide to help signers understand what their role looks like in the sBTC system.

## Signer Node Setup

As an sBTC signer, your primary responsibility is to run and maintain a signer node. Here's what that entails:

{% stepper %}
{% step %}
**Hardware setup**

Ensure your node has sufficient computational power and storage.
{% endstep %}

{% step %}
**Software installation**

Install the sBTC signer node software and its dependencies.
{% endstep %}

{% step %}
**Key management**

The node software securely generates and stores the Bitcoin private key and corresponding public key.
{% endstep %}

{% step %}
**Node registration**

Upon first run, the node automatically registers its public key with the sBTC Registry contract on the Stacks blockchain.
{% endstep %}
{% endstepper %}

## Day-to-Day Operations

Once set up, your signer node operates autonomously, performing the following tasks:

{% stepper %}
{% step %}
**Monitoring Deposit Requests**

Your node continuously monitors for sBTC minting requests:

* The node connects to the Bitcoin network and the Stacks blockchain.
* It watches for Bitcoin transactions sent to the sBTC UTXO address.
* When a deposit is detected, the node verifies the transaction details.
  {% endstep %}

{% step %}
**Processing Mint Requests**

Upon confirming a deposit:

* The node automatically prepares a signature for the mint operation using its private key.
* It submits this signature to the sBTC Deposit contract on the Stacks blockchain.
* The contract verifies the signature and combines it with signatures from other signer nodes.
* Once enough valid signatures are collected, the contract mints the corresponding amount of sBTC.
  {% endstep %}

{% step %}
**Handling Withdrawal Requests**

For sBTC withdrawal requests:

* The node monitors the sBTC Withdrawal contract for new requests.
* Upon detecting a request, it verifies the user's sBTC balance and the request's validity.
* The node automatically signs the withdrawal operation and submits its signature.
* Once enough signatures are collected and the sBTC is burned, the node participates in creating and signing a Bitcoin transaction to fulfill the withdrawal.
* The signed Bitcoin transaction is broadcast to the Bitcoin network.
  {% endstep %}
  {% endstepper %}


# sBTC Transaction Walkthrough

Let's follow the journey of 1 BTC as it moves through the sBTC system, from initial deposit to final withdrawal.

## Part 1: Deposit (BTC → sBTC)

{% stepper %}
{% step %}
**Initiation**

* Alice decides to convert 1 BTC to sBTC to participate in Stacks DeFi.
* Alice creates a deposit transaction on the Bitcoin network (typically via a UI such as the sBTC bridge or a DeFi application).
* The transaction enters the Bitcoin mempool.
  {% endstep %}

{% step %}
**Proof Submission**

* Alice submits proof of her deposit to the Deposit API (usually via the application's UI).
* The Deposit API sets the deposit status to PENDING.
  {% endstep %}

{% step %}
**Signer Validation**

The sBTC Signer Set:

* Detects the deposit.
* Validates the UTXO format.
* Votes on the deposit.

If the deposit is rejected:

* Signers notify the API of the rejection.
* The Deposit API updates the status to FAILED.

If the deposit is accepted:

* The Deposit API updates the status to ACCEPTED.
  {% endstep %}

{% step %}
**Bitcoin Transaction**

If accepted, the sBTC Signer Set:

* Creates a new Bitcoin transaction consuming Alice's deposited BTC.
* Broadcasts this transaction to the Bitcoin network.

If this transaction fails:

* Signers notify the API of the failure.
* The Deposit API updates the status to FAILED.
  {% endstep %}

{% step %}
**sBTC Minting**

Upon successful Bitcoin transaction:

* The sBTC Signer Set interacts with the Stacks blockchain.
* They fulfill the deposit by minting 1 sBTC to Alice's Stacks address.
  {% endstep %}

{% step %}
**Confirmation**

* The Deposit API updates the deposit status to CONFIRMED.
* Alice now has 1 sBTC in her Stacks wallet.
  {% endstep %}
  {% endstepper %}

***

## Part 2: sBTC Usage

Alice can now use her 1 sBTC in the Stacks ecosystem:

* Transfer it to other users via the `sbtc-token` contract (typically via an application UI).
* Participate in DeFi applications.
* Use it in any application that supports SIP-010 tokens.

***

## Part 3: Withdrawal (sBTC → BTC)

{% stepper %}
{% step %}
**Initiation**

* Alice initiates a withdrawal by interacting with the Clarity contract on the Stacks blockchain.
* She specifies her Bitcoin address for the withdrawal.
* If successful, the contract locks her sBTC and the withdrawal status is set to PENDING.
* If the transaction fails, no withdrawal occurs.
  {% endstep %}

{% step %}
**Signer Validation**

The sBTC Signer Set:

* Detects the withdrawal request.
* Decides whether to accept or reject the withdrawal.

If the withdrawal is rejected:

* Signers unlock the sBTC.
* The withdrawal status is updated to FAILED.

If the withdrawal is accepted:

* The withdrawal status is updated to ACCEPTED.
* Signers wait for 6 Bitcoin block confirmations (for security purposes).
  {% endstep %}

{% step %}
**Bitcoin Transaction**

After the waiting period, if accepted:

* The sBTC Signer Set creates a new Bitcoin transaction fulfilling Alice's withdrawal.
* They broadcast this transaction to the Bitcoin network.

If this transaction fails:

* Signers unlock the sBTC.
* The withdrawal status is updated to FAILED.
  {% endstep %}

{% step %}
**sBTC Burning and Confirmation**

Upon successful Bitcoin transaction:

* The sBTC Signer Set burns the locked 1 sBTC on the Stacks blockchain.
* The withdrawal status is updated to CONFIRMED.
  {% endstep %}

{% step %}
**Completion**

* Alice now has her 1 BTC back in her specified Bitcoin address.
* The withdrawn sBTC has been permanently removed from circulation.
  {% endstep %}
  {% endstepper %}


# Using the sBTC Bridge App

Start bridging over your BTC into sBTC on Stacks with the official sBTC Bridge app.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-559c3cfed55c4e4d757873ef67050886cb27b878%2Fimage.png?alt=media" alt=""><figcaption><p><a href="https://sbtc.stacks.co/">https://sbtc.stacks.co/</a></p></figcaption></figure></div>

The purpose of the user-facing sBTC Bridge app is to facilitate seamless and secure conversion between BTC and sBTC. You can deposit (peg-in) your BTC into sBTC. Or you can withdraw (peg-out) your sBTC back into BTC. The app also provides an intuitive interface for safely managing the history of your transactions.

{% hint style="info" %}
The official sBTC Bridge app is found at <https://sbtc.stacks.co/>
{% endhint %}

Refer to the following guides below to learn how you can securely convert your BTC into sBTC.

* [How to Use the sBTC Bridge with Xverse/Leather](https://docs.stacks.co/learn/sbtc/using-the-sbtc-bridge-app/how-to-use-the-sbtc-bridge)
* [How to Use the sBTC Bridge with Fordefi](https://docs.stacks.co/learn/sbtc/using-the-sbtc-bridge-app/how-to-use-the-sbtc-bridge-with-fordefi)
* [How to Use the sBTC Bridge with Asigna](https://docs.stacks.co/learn/sbtc/using-the-sbtc-bridge-app/how-to-use-the-sbtc-bridge-with-asigna)


# How to Use the sBTC Bridge with Xverse/Leather

The sBTC bridge is a web application allowing you to convert your BTC into sBTC on the Stacks chain.

{% hint style="danger" %}
Ensure that you are using the bridge located at [sbtc.stacks.co](https://sbtc.stacks.co/). This is the only official sBTC bridge.
{% endhint %}

If you aren't familiar with sBTC, be sure to check out the [sBTC Conceptual Guide](https://docs.stacks.co/learn/sbtc) to understand how it works.

The bridge has been designed to be as simple as possible to use. In order to utilize sBTC, all you need to do is send a Bitcoin transaction using a supported wallet (like [Leather](https://leather.io/) or [Xverse](https://www.xverse.app/)). This guide will show screenshots of Xverse but the flow is the same if using Leather as well.

Below you'll find both a video and written walkthrough of using the bridge.

### Video Walkthrough

{% embed url="<https://youtu.be/XZruuDgTo4k>" %}

### Written Walkthrough

There are 5 simple steps to convert your BTC to sBTC.

{% stepper %}
{% step %}
**Connect your wallet**

First, you'll need to connect your wallet to the bridge UI. Currently Leather and Xverse are supported, with more on the way.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-8f6083d420c2ef0d94f229b5a179f5cebff75632%2Fimage%20(9)-sbtc-bridge.png?alt=media" alt=""><figcaption></figcaption></figure></div>
{% endstep %}

{% step %}
**Choose the amount to deposit**

After your wallet is connected, choose how much BTC you would like to convert to sBTC.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-8177a768393bd7505be951136ecaf1ba70719264%2Fimage%20(10)-sbtc-bridge.png?alt=media" alt=""><figcaption></figcaption></figure></div>

{% hint style="info" %}
There are two transaction fees required to mint your sBTC. The first is set by the user manually when they initiate the deposit transaction within their wallet. The second is a fee used to consolidate the deposit UTXOs into the single signer UTXO. This separate transaction fee happens automatically and is set to a max of 80k sats. This is automatically deducted from your minted sBTC. This is not a signer fee but a regular Bitcoin transaction fee.
{% endhint %}
{% endstep %}

{% step %}
**Choose the Stacks address to mint to**

Next, enter the Stacks address you would like your sBTC minted to.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-ac78447329ceb9f3e2a07a6dc3e9c5a0dc53be3c%2Fimage%20(11)-sbtc-bridge.png?alt=media" alt=""><figcaption></figcaption></figure></div>
{% endstep %}

{% step %}
**Initiate the transaction**

After you choose your Stacks address, you'll use your connected wallet to transfer the BTC.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-9210b58c1ab51f4f105f90c0f5c96e3cb694a8e5%2Fimage%20(12)-sbtc-bridge.png?alt=media" alt=""><figcaption></figcaption></figure></div>
{% endstep %}

{% step %}
**Receive your sBTC**

In the UI, you can monitor the status of your transaction to see when it has been completed, at which point you can see the sBTC in your wallet. It will go through three stages:

* Pending - Your Bitcoin transaction is processing
* Minting - Your Bitcoin transaction has processed and the sBTC signers are minting your sBTC
* Completed - Your sBTC has been minted to your wallet

Note that you may need to enable the display of the sBTC token within your wallet by clicking on 'Manage Tokens' and enabling sBTC.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-715ec833fe1c9ef9d08f432fbc302c5e710585dc%2Fimage%20(13)-sbtc-bridge.png?alt=media" alt=""><figcaption></figcaption></figure></div>
{% endstep %}
{% endstepper %}

### Reclaiming BTC

If your sBTC mint fails, you can reclaim your sBTC. You can do this via the bridge by visiting the reclaim page at <https://sbtc.stacks.co/\\>\<TX\_ID>/reclaim and replacing the bracketed text with your transaction ID, eg. <https://sbtc.stacks.co/8f37f750b6646f0a217121201967170bd3cfef5f2ebd4f30f359b5e9308470c4/reclaim>

There is an intermediate step in between depositing BTC and the sBTC signers consolidating it into the single signer UTXO. If the transaction is not picked up by signers, you can reclaim it using this UI. Note there is a 'Lock Time' field on the Reclaim page. That indicates the amount of blocks that must have passed in order to reclaim your BTC.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-514951c8b0d9633e03d2c3aa3c95cd381b85201c%2Fimage%20(14)-sbtc-bridge.png?alt=media" alt=""><figcaption></figcaption></figure></div>

This initiates a Bitcoin transaction that will transfer your BTC back to you.


# How to Use the sBTC Bridge with Fordefi

{% hint style="warning" %}
This guide is specifically for entities or teams that use [Fordefi](https://fordefi.com/) as it will demonstrate the flow for a multi-approval transaction policy setup. This assumes you have the Fordefi wallet setup with its browser extension and with its mobile app.
{% endhint %}

The sBTC Bridge is a web application allowing you to convert your BTC into sBTC on the Stacks chain. If you aren't familiar with sBTC, be sure to check out the [sBTC Conceptual Guide](https://docs.stacks.co/learn/sbtc) to understand how it works.

{% hint style="danger" %}
Ensure that you are using the bridge located at [sbtc.stacks.co](https://sbtc.stacks.co/). This is the only official sBTC bridge.
{% endhint %}

The sBTC Bridge has been designed to be as simple as possible to use. But specifically for this guide, a **2-of-2 approval transaction policy**, targeting Bitcoin transactions, has already been setup in the Fordefi UI. It is assumed you have a similar setup as this guide will walkthrough the different steps needed to take in such a scenario where multiple parties need to approve a transaction.

If you need assistance in setting up such a transaction policy in Fordefi, check out their dedicated [docs](https://docs.fordefi.com/user-guide/policies).

### Walkthrough for minting sBTC

Here are the necessary steps to convert your BTC to sBTC using Fordefi:

{% stepper %}
{% step %}
**Confirm your BTC and STX vaults**

First, you'll need to make sure you have a vault for Bitcoin, and a separate vault for Stacks. Both of these vaults will be used later when connecting with the sBTC Bridge app.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-b9cb30d7a1b85399a22372827e8ee28734029e6f%2Fimage%202-with-fordefi.png?alt=media" alt=""><figcaption><p>A vault for native Bitcoin assets</p></figcaption></figure></div>

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-6d0423b88b96c6653c45f0e8aab4e1f506940d8a%2Fimage%203-with-fordefi.png?alt=media" alt=""><figcaption><p>A vault for native Stacks assets</p></figcaption></figure></div>
{% endstep %}

{% step %}
**Connect your Fordefi wallet extension**

First, you'll need to connect your Fordefi wallet to the sBTC Bridge app.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-3842a7c913fb40abeb1e4ca5ddb655c3d0f44c33%2Fimage%204-with-fordefi.png?alt=media" alt=""><figcaption><p>Choose the option for Fordefi in the wallet selector modal</p></figcaption></figure></div>
{% endstep %}

{% step %}
**Choose which Bitcoin and Stacks vault you want to use**

Next, the Fordefi extension will want you to select which Bitcoin vault, and then which Stacks vault you'd want to use. The reasoning for this is because you'll be needing to send a bitcoin transaction first from your Bitcoin vault, then you'll be receiving sBTC to your Stacks vault.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-6edd5519d73eaf4e3160dc8d060de615b24c70ef%2Fimage%205-with-fordefi.png?alt=media" alt=""><figcaption><p>The selected Bitcoin vault needs to have at least the minimum required amount (0.001 BTC) of bitcoin to peg-in</p></figcaption></figure></div>

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-55f9302b8362b1278bc2dcd5842bd1b802376b0a%2Fimage%206-with-fordefi.png?alt=media" alt=""><figcaption><p>When both vaults are selected, you'll be able to see both at the top of the Fordefi extension when connected</p></figcaption></figure></div>
{% endstep %}

{% step %}
**Choose the amount of BTC to deposit**

After your wallet is connected, choose how much BTC you would like to convert to sBTC.

{% hint style="info" %}
There are two transaction fees required to mint your sBTC. The first is when they initiate the bitcoin deposit transaction within their wallet. The second is a fee used to consolidate the deposit UTXOs into the single Signer's UTXO. This separate transaction fee happens automatically and is set to a max of 80k sats. This is automatically deducted from your minted sBTC. This is not a Signer fee but a regular bitcoin transaction fee.
{% endhint %}

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-26d2b2a603740e301561d5b437a6cea7f3c65f3f%2Fimage%207-with-fordefi.png?alt=media" alt=""><figcaption></figcaption></figure></div>
{% endstep %}

{% step %}
**Choose the Stacks address to mint the sBTC to**

Next, enter the Stacks address you would like your sBTC minted to. This will just be the Stacks address associated with the Stacks vault that you selected earlier when connecting your Fordefi wallet extension.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-1d60b4bce29e269849950e640f8295bd26cfb18b%2Fimage%208-with-fordefi.png?alt=media" alt=""><figcaption><p>Review the inputted STX address and then confirm</p></figcaption></figure></div>
{% endstep %}

{% step %}
**Create initial BTC transfer**

Your Fordefi wallet extension will pop up prompting you to create the BTC transaction. This transaction is the initial peg-in transfer for your BTC to the sBTC Signers. Hit 'Create' after you confirm the transaction details and necessary approval details.

{% hint style="info" %}
If you have a transaction policy setup with certain approvals required, hitting 'Create' will not initiate the bitcoin transaction, it will simply store this unsigned transaction in your Fordefi wallet until all necessary approvals are met and then finally signed.
{% endhint %}

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-01595e7d39d4b7d5873edf6c77dabfc613d3d045%2Fimage%2011-with-fordefi.png?alt=media" alt=""><figcaption><p>You'll notice near the bottom of the Create Transaction view of the Fordefi extension is the required approval details. Be certain the other approvers are available to approve the transaction in a timely manner.</p></figcaption></figure></div>

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-5bfe3c487a3806dffa2caf9efb607292224479df%2FGroup%20316124778%20(1)-with-fordefi.png?alt=media" alt=""><figcaption><p>If you ever navigate back to your Fordefi web UI or extension UI, you'll notice this transaction will be marked as 'Pending approval'.</p></figcaption></figure></div>
{% endstep %}

{% step %}
**Approve transaction by approvers**

Upon notice of transaction to approvers, each approver will need to approve transaction in their Fordefi mobile wallets before the completion of the final step, which is signing the transaction by the initiator.

Each approver will need to pull up the pending transaction in their Fordefi mobile wallet and hit 'Approve'.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-9b806f1b58f58f5052a69b1396b27299f1db8366%2FGroup%20316124778%20(2)-with-fordefi.png?alt=media" alt=""><figcaption><p>POV of approving transaction by approver</p></figcaption></figure></div>
{% endstep %}

{% step %}
**Sign approved transaction**

Once all transaction policies are satisfied and approved, the initiator will need to officially sign the transaction in their Fordefi mobile wallet.

This mobile signature action will then notify the sBTC Bridge app.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-3319d3c070cef54c71d8a2ffa23ee4e50d9d6493%2FGroup%20316124778%20(3)-with-fordefi.png?alt=media" alt=""><figcaption><p>The initiator will need to hit 'Sign' once approvals and transaction details are confirmed</p></figcaption></figure></div>
{% endstep %}

{% step %}
**Receive your sBTC**

Back in the sBTC Bridge app UI, you can monitor the status of your transaction to see when it has been completed, at which point you can see the sBTC in your Fordefi wallet. It will go through three stages:

* Pending - Your [Bitcoin transaction](https://mempool.space/tx/6b5e63fbe4e4a4835dcf096ca2d2a8c112898692e28a4c5b38cb39e3e9837604) is processing
* Minting - Your Bitcoin transaction has processed and the [sBTC signers are minting](https://explorer.hiro.so/txid/a9e232289d2c6e50150b034894182d341343e7064b27c8dccbd25ebca79b2947?chain=mainnet) your sBTC
* Completed - Your sBTC has been minted to your wallet

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-099e6b71c7f44d9ce44da3021f013d331fcf1387%2Fimage%2016-with-fordefi.png?alt=media" alt=""><figcaption><p>The bitcoin and sBTC transactions will take some time to be completely processed by the Signers</p></figcaption></figure></div>

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-ff2615e1140651852f8fae8e3b28e3ed81f0f65e%2Fimage%2022-with-fordefi.png?alt=media" alt=""><figcaption><p>Once both the bitcoin and sBTC mint transactions are confirmed, the sBTC Bridge app will show a 'Complete' status</p></figcaption></figure></div>

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-86eb052ce8d5d34a9132728d15f3cbe5a6e81888%2FGroup%20316124778%20(4)-with-fordefi.png?alt=media" alt=""><figcaption><p>You'll be able to see the results of these transactions in your Fordefi wallet</p></figcaption></figure></div>
{% endstep %}
{% endstepper %}

### Reclaiming BTC

If your sBTC mint fails, you can reclaim your sBTC. You can do this via the bridge by visiting the reclaim page at <https://sbtc.stacks.co/\\>\<TX\_ID>/reclaim and replacing the bracketed text with your transaction ID as shown below:\
<https://sbtc.stacks.co/8f37f750b6646f0a217121201967170bd3cfef5f2ebd4f30f359b5e9308470c4/reclaim>

There is an intermediate step in between depositing BTC and the sBTC signers consolidating it into the single signer UTXO. If the transaction is not picked up by signers, you can reclaim it using this UI. Note there is a 'Lock Time' field on the Reclaim page. That indicates the amount of blocks that must have passed in order to reclaim your BTC.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-514951c8b0d9633e03d2c3aa3c95cd381b85201c%2Fimage%20(14)-sbtc-bridge.png?alt=media" alt=""><figcaption></figcaption></figure></div>

This initiates a Bitcoin transaction that will transfer your BTC back to you.


# How to Use the sBTC Bridge with Asigna

{% hint style="warning" %}
This guide is specifically for entities or teams that use [Asigna](https://www.asigna.io/) as it will demonstrate the flow for a multi-signature setup. This assumes you have the Asigna web wallet setup with its browser extension.
{% endhint %}

The sBTC Bridge is a web application allowing you to convert your BTC into sBTC on the Stacks chain. If you aren't familiar with sBTC, be sure to check out the [sBTC Conceptual Guide](https://docs.stacks.co/learn/sbtc) to understand how it works.

{% hint style="danger" %}
Asigna has the sBTC Bridge as an embedded app within its web wallet. This guide will be using that embedded app.
{% endhint %}

The sBTC Bridge has been designed to be as simple as possible to use. But specifically for this guide, a **2-of-2 multi-signature setup of a Bitcoin vault AND a separate Stacks vault**. It is assumed you have a similar setup as this guide will walkthrough the different steps needed to take in such a scenario where 2 parties of this 2-of-2 multi-signature setup need to sign transactions.

### Walkthrough for minting sBTC

Here are the necessary steps to convert your BTC to sBTC using Asigna:

{% stepper %}
{% step %}
**Confirm your BTC and STX vaults**

First, you'll need to make sure you have a vault for Bitcoin, and a separate vault for Stacks. In this scenario, the same 2-of-2 signature setup are applied for both vaults. Throughout the guide, we'll refer to each party of this setup as Member\_1 and Member\_2.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-72f2b66bcc201f7fe5dfcc444b40fa92c6bdb58f%2FGroup%20316124779-with-asigna.png?alt=media" alt=""><figcaption><p>Member_2's POV of both its Bitcoin vault and Stacks vault setup.</p></figcaption></figure></div>
{% endstep %}

{% step %}
**Navigate and open the embedded sBTC Bridge app in Bitcoin vault**

Click into the Bitcoin vault and scroll down to the 'Trending Apps' section where you'll locate the sBTC Bridge embedded app. Open this embedded app and choose the 'Asigna Multisig' wallet to connect with.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-c61a905f630669f69095234fa2db6c116a5aff34%2Fimage%2033%20(1)-with-asigna.png?alt=media" alt=""><figcaption><p>Locate the sBTC Bridge embedded app and open it.</p></figcaption></figure></div>

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-e37f5211d0ed40789a7c9715e74ad31b2207e068%2Fimage%2035-with-asigna.png?alt=media" alt=""><figcaption><p>Connect with the Asigna Multisig wallet option. This app will auto connect with the Bitcoin vault that is being using in this context of the embedded app. You won't need to connect to a Stacks vault but you will need a Stacks vault address to use as the receiving address of the minted sBTC.</p></figcaption></figure></div>
{% endstep %}

{% step %}
**Choose the amount of BTC to deposit**

After your Bitcoin vault is connected, choose how much BTC you would like to convert to sBTC.

{% hint style="info" %}
There are two transaction fees required to mint your sBTC. The first is when they initiate the bitcoin deposit transaction within their wallet. The second is a fee used to consolidate the deposit UTXOs into the single Signer's UTXO. This separate transaction fee happens automatically and is set to a max of 80k sats. This is automatically deducted from your minted sBTC. This is not a Signer fee but a regular bitcoin transaction fee.
{% endhint %}

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-45a57ac76a7839329f2b20c20cd62fc907c0bc95%2Fimage%2036-with-asigna.png?alt=media" alt=""><figcaption><p>Currently the minimum to peg-in is 0.001 BTC.</p></figcaption></figure></div>
{% endstep %}

{% step %}
**Choose the Stacks address from the Stacks vault**

Next, enter the Stacks address you would like your sBTC minted to. For this guide, we'll be using the Stacks address of the Stacks vault that is assumed to be setup by both Member\_1 and Member\_2.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-748ca889959123b46f9d3662a8c84198f6f3caca%2Fimage%2037-with-asigna.png?alt=media" alt=""><figcaption><p>Copy the multi-signature Stacks address from the Stacks vault setup.</p></figcaption></figure></div>

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-b676da7c7e65c054cc3bac9c5698762de9852bcf%2Fimage%2038-with-asigna.png?alt=media" alt=""><figcaption><p>Review the inputted STX address, hit 'NEXT', and then 'CONFIRM'.</p></figcaption></figure></div>
{% endstep %}

{% step %}
**Select Fee Rate**

Depending on congestion of the Bitcoin network, choose the appropriate fee rate based on your vault's preferences for timely confirmation.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-d06a74bc72d23271c1d7e5b1ae9d015062254c88%2FGroup%20316124780-with-asigna.png?alt=media" alt=""><figcaption></figcaption></figure></div>
{% endstep %}

{% step %}
**Confirm the transaction creation**

Whomever member, of the 2-of-2 multi-signature setup, is currently acting as the context of the sBTC Bridge embedded app, a popup modal of that member's wallet will appear for confirmation. In this guide, is it Member\_1 that is acting as the context and is currently connected with the Bitcoin vault using Xverse. Therefore, the Xverse wallet popup will appear for confirmation.

Remember, this transaction is the initial peg-in transfer for your BTC to the sBTC Signers.

{% hint style="info" %}
If you have a multi-signature setup with certain signatures required, hitting 'Confirm' will not broadcast the bitcoin transaction, it will simply store this partially signed transaction in your Bitcoin vault until all required signatures are met.
{% endhint %}

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-660e9484341b9d6a54dfe0d625958696e7ce03fe%2FGroup%20316124780%20(1)-with-asigna.png?alt=media" alt=""><figcaption><p>Review the transaction and hit confirm to create the partially signed bitcoin transaction where it will be waiting for the other members to sign in their respective Asigna Bitcoin vaults.</p></figcaption></figure></div>
{% endstep %}

{% step %}
**Sign and approve transaction by other members**

Upon notice of transaction to the other members of the multi-signature setup, each necessary member will need to approve the pending transaction in their own respective Asigna Bitcoin vaults.

In our case, Member\_2 will navigate to their own Bitcoin vault and find the pending partially signed bitcoin transaction waiting for signature.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-16b82a5480bdee3f17e30a62f376c7f9af399e02%2Fimage%2042%20(1)-with-asigna.png?alt=media" alt=""><figcaption><p>Member_2 will locate the pending transaction and complete signature as their approval.</p></figcaption></figure></div>

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-8e5cfbc05ef64393bc3add29ac225f45686a9c91%2Fimage%2043%20(1)-with-asigna.png?alt=media" alt=""><figcaption><p>Member_2 will see their connected wallet, in this case Leather, popup for them to confirm transaction.</p></figcaption></figure></div>
{% endstep %}

{% step %}
**Broadcasting of transaction**

Once all transaction policies are satisfied and approved, the sBTC Bridge embedded app will appear with a prompt confirming that all signatures have been gathered successfully which will then automatically prompt the broadcasting of the transaction.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-e09c9131d47ee49ac08fb2c70e4f3fe634d46045%2Fimage%2044-with-asigna.png?alt=media" alt=""><figcaption><p>Great! All signatures have been gathered for the transaction to be broadcasted.</p></figcaption></figure></div>
{% endstep %}

{% step %}
**Receive your sBTC**

Back in the sBTC Bridge app UI, you can monitor the status of your transaction to see when it has been completed, at which point you can see the sBTC in your Fordefi wallet. It will go through three stages:

* Pending - Your [Bitcoin transaction](https://mempool.space/tx/838ebd2c78091ca805ff00c2a2182d2e9c652bd9b43ef286c3af33d1a414f587) is processing
* Minting - Your Bitcoin transaction has processed and the [sBTC signers are minting](https://explorer.hiro.so/txid/fef3dd3f6d4e6c89f3482fdec3816822261f29739ee81d1af6deb01d11e43961?chain=mainnet) your sBTC
* Completed - Your sBTC has been minted to your Asigna Stacks vault wallet

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-30ad78dfbefa746278ebd2fa02251f99c8e67cf8%2Fimage%2045%20(1)-with-asigna.png?alt=media" alt=""><figcaption><p>The bitcoin and subsequent sBTC mint transaction will take some time to be completely processed by the Signers</p></figcaption></figure></div>

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-c78859d24f4a85d936dd5733ff4b52c060a30b80%2Fimage%2046-with-asigna.png?alt=media" alt=""><figcaption><p>Once both the bitcoin and sBTC mint transactions are confirmed, the sBTC Bridge app will show a 'Completed' status</p></figcaption></figure></div>

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-186243f9cff3ae45ff9cf9e6fb58c8415644781c%2Fimage%2047-with-asigna.png?alt=media" alt=""><figcaption><p>You'll then be able to see the sBTC balance in your Asigna Stacks vault.</p></figcaption></figure></div>
{% endstep %}
{% endstepper %}

### Reclaiming BTC

If your sBTC mint fails, you can reclaim your sBTC. You can do this via the bridge by visiting the reclaim page at <https://sbtc.stacks.co/\\>\<TX\_ID>/reclaim and replacing the bracketed text with your transaction ID as shown below:\
<https://sbtc.stacks.co/8f37f750b6646f0a217121201967170bd3cfef5f2ebd4f30f359b5e9308470c4/reclaim>

There is an intermediate step in between depositing BTC and the sBTC signers consolidating it into the single signer UTXO. If the transaction is not picked up by signers, you can reclaim it using this UI. Note there is a 'Lock Time' field on the Reclaim page. That indicates the amount of blocks that must have passed in order to reclaim your BTC.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-514951c8b0d9633e03d2c3aa3c95cd381b85201c%2Fimage%20(14)-sbtc-bridge.png?alt=media" alt=""><figcaption></figcaption></figure></div>

This initiates a Bitcoin transaction that will transfer your BTC back to you.


# Security Model of sBTC

Explaining the security model of sBTC

### sBTC Security: A Multi-layered Approach

Security is the foundation of this rollout. Partnerships with top-tier security experts have been established to ensure the protocol is fortified at every level:

1. **Asymmetric Research**: Known for their rigorous research and top embedded security researchers, Asymmetric brings security expertise to sBTC to identify and mitigate potential vulnerabilities.
2. **ImmuneFi**: A robust bug bounty program incentivizes ethical hackers to uncover and address potential issues, adding an additional layer of defense. ImmuneFi is the [leading crowdsource bounty platform for DeFi](https://stacks.org/best-and-brightest-sbtc#immunefi).
3. **3rd Party Audits**: Independent audit reports have been made for additional security reviews, ensuring the protocol is thoroughly vetted by external experts.

### The components that make up the security model of sBTC

#### **sBTC Signer Network**

The sBTC Signer network is a decentralized group of entities responsible for managing the locking and unlocking of BTC during the minting and redemption of sBTC. This network operates in a distributed manner to enhance security and reduce the risks associated with centralized custodians.

Signers are responsible for approving all sBTC deposit and withdrawal operations, ensuring the integrity of the system. With a requirement of 70% consensus for transaction approval, Signers maintain the protocol's liveness and security.\
\
As approved by the Stacks community via [SIP-028](https://github.com/stacksgov/sips/blob/69d40a5f4f0ad98eb448ba44e7c31ca054820aa3/sips/sip-028/sip-028-sbtc_peg.md), the criteria for selecting signers include technical expertise, reliability, performance, and decentralization. An initial set of 15 institutional Signers will be used in Phase 1 to maintain simplicity and minimize operational risks. This group will grow as the protocol evolves.\
\
As sBTC evolves, the Signer set will transition to a fully decentralized model, further strengthening the protocol's resilience.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-3a3b31caabb095da66e2ad2811b91c397dbfab6c%2Fimage.png?alt=media" alt=""><figcaption><p>source: <a href="https://bitcoinl2labs.com/sbtc-rollout#sbtc-signers">Bitcoin L2 Labs</a></p></figcaption></figure></div>

For more info on who the sBTC Signers are, check out this section on the Bitcoin L2 Labs website [here](https://bitcoinl2labs.com/sbtc-rollout#sbtc-signers).

#### **Trust-Minimized Bridge Model**

The trust-minimized bridge model for sBTC ensures that the exchange between BTC and sBTC happens without relying on a single entity. Instead, it leverages cryptographic proofs and smart contracts on the Stacks blockchain, allowing for secure and transparent conversion processes.

The permissionless nature of the sBTC model empowers Bitcoin holders to freely peg their BTC into sBTC and vice versa. This process utilizes a decentralized network of Signers along with smart contracts, eliminating the need for centralized custody or intermediaries. Bitcoin holders initiate a peg by sending BTC to a predetermined address, automatically triggering the issuance of an equivalent amount of sBTC on the Stacks blockchain. Similarly, holders can burn their sBTC, prompting the smart contracts to release BTC back to their control. This model enhances user autonomy and aligns with the decentralized ethos of Bitcoin.

#### **Bitcoin Finality and Stacks**

Stacks' Bitcoin Finality mechanism aligns sBTC's security closely with Bitcoin itself. By anchoring blocks and transactions to the Bitcoin blockchain, this ensures that the finality and security of asset holdings on Stacks are as robust as those on the Bitcoin network. This integration helps maintain trust and stability for sBTC within the broader Bitcoin ecosystem.

### How sBTC's security contrasts with other wrapped Bitcoin alternatives

While the sBTC model leverages decentralization to minimize trust, other wrapped Bitcoin solutions often face centralization risks. Typically, these alternatives rely on a centralized custodian to hold the underlying BTC, introducing a significant point of failure. Such custodians act as the trust anchor in the conversion process, which can potentially lead to issues such as censorship, mismanagement, or even security breaches. As a result, these models may not fully align with the decentralized principles of Bitcoin, posing challenges to the security and autonomy intended for Bitcoin holders.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-d79336d2e24f391daaeef9f8814b8932d601a731%2Fimage.png?alt=media" alt=""><figcaption><p>source: <a href="https://www.stacks.co/sbtc">stacks.co</a></p></figcaption></figure></div>

***

#### Resources

* \[[Stacks Roadmap](https://stacksroadmap.com/#sbtc)] Upcoming technical advancements and security designs for sBTC
* \[[Hiro Blog](https://www.hiro.so/blog/sbtc-vs-wbtc-a-comparison-of-tokenized-bitcoin)] sBTC vs WBTC: A Comparison of Tokenized Bitcoin&#x20;


# sBTC Audits

Several third-party security audits have been conducted on the sBTC protocol and can be referenced here.

### Ottersec Audit Reports

{% file src="<https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-b3929dbb3984758aec1a4236ffb21bfe7e556e3a%2FOttersec%20-%20WSTS.pdf?alt=media>" %}

{% file src="<https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-b093ed87bffaefb052a1d8b9544a3b6cdf7cc91d%2FOttersec%20-%20sBTC%20Withdrawal.pdf?alt=media>" %}

### Immunefi Audit Reports

* <https://reports.immunefi.com/stacks-i-attackathon>
* <https://reports.immunefi.com/stacks-ii-attackathon>

### CoinFabrik Audit Reports

{% file src="<https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-1b73a0857ef6ff21bfa24cc4982fdee88313d46c%2FCoinFabrik_WSTS.pdf?alt=media>" %}

### Clarity Alliance Audit Reports

{% file src="<https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-46fb8bb7ca5e38063b45b9491b8699fc230c9e69%2FClarity%20Alliance%20-%20sBTC.pdf?alt=media>" %}


# sBTC FAQ

### sBTC Basics

<details>

<summary>What is sBTC?</summary>

sBTC is a decentralizedl 1:1 Bitcoin-backed asset on the Stacks Bitcoin Layer. Read more about Stacks [here](https://www.stacks.co/) and sBTC [here](https://www.stacks.co/sbtc).

</details>

<details>

<summary>How does sBTC work?</summary>

sBTC as a SIP-010 tokensBTC is a SIP-010 token on the Stacks blockchain that represents Bitcoin (BTC) in a 1:1 ratio. sBTC is always backed 1:1 against BTC.Peg wallet and signersThe sBTC peg wallet is maintained and managed by a set of sBTC signers. This decentralized approach enhances security and reduces single points of failure. Read more about Stacker Signing here.

</details>

<details>

<summary>What is Bitcoin Finality, and why is it important?</summary>

Stacks and sBTC state automatically fork with Bitcoin. As such, all transactions settle to Bitcoin with 100% Bitcoin Finality. This protects users against attacks to sBTC via a hard fork. This is a critical security measure that aligns sBTC security with Bitcoin. Read more in [the Stacks Documentation](https://docs.stacks.co/concepts/block-production/bitcoin-finality).

</details>

<details>

<summary>How does the Stacks Signer network improve security?</summary>

Signers are responsible for approving all sBTC deposit and withdrawal operations, ensuring the integrity of the system. With a requirement of 70% consensus for transaction approval, Signers maintain the protocol's liveness and security.

To launch sBTC, the Stacks community approved [SIP-028](https://github.com/stacksgov/sips/blob/69d40a5f4f0ad98eb448ba44e7c31ca054820aa3/sips/sip-028-sbtc_peg.md), defining the criteria for selecting signers based on factors such as technical expertise, reliability, performance, and decentralization. An initial group of 15 institutional Signers has been chosen for Phase 1 to maintain simplicity and reduce operational risks. This group will expand over time as the protocol matures.

The list of sBTC signers is public and listed [here](https://bitcoinl2labs.com/sbtc-rollout#sbtc-signers).

</details>

<details>

<summary>What security measures have been put in place to ensure sBTC is safe?</summary>

sBTC is always backed 1:1 against BTC, and it's verifiably secure through threshold cryptography. sBTC removes the need for 3rd party custodian or trusted setup. Instead, BTC is secured by a decentralized signer set.

Partnerships with top-tier security experts have been established to ensure the protocol is fortified at every level:

Asymmetric Research is a core security contributor. Known for their rigorous research and protocol audits, Asymmetric brings security expertise to sBTC to identify and mitigate potential vulnerabilities. ImmuneFiA robust bug bounty program incentivizes ethical hackers to uncover and address potential issues, adding an additional layer of defense. 3rd Party AuditsSeveral third-party security audits have been conducted on the sBTC system and can be referenced on the sBTC Audits page.

</details>

<details>

<summary>What sets sBTC apart?</summary>

Here are the main differentiating characteristics of sBTC:

* sBTC is a true Bitcoin native product
* sBTC is backed by respected leaders in the Bitcoin community (signer network)
* sBTC's security is provided by a decentralized network of validators/signers rather than a single custodian, removing the need to trust a single entity or exchange
* sBTC leverages 100% Bitcoin finality
* sBTC's technology offers optimal UX and DevEx for an L2
* sBTC is a fully transparent project/product working in the open with public code

</details>

<details>

<summary>Where can I learn more about the sBTC signers?</summary>

Read the "[Selection of sBTC Signer Set](https://github.com/stacks-network/sbtc/discussions/624)" post for more information about each signer and their qualifications.

</details>

### Using sBTC

<details>

<summary>When will sBTC be available?</summary>

sBTC deposits first went live on December 16, 2024, quickly hitting the 1,000 BTC cap. The second cap will go live on February 25th, 2025, quickly hitting the 3,000 BTC cap. Withdrawals went live on April 30, 2025.

Full decentralization of the Signer set will follow in [a subsequent phase](https://bitcoinl2labs.com/sbtc-rollout), gradually expanding beyond the initial 15 community-elected signers.

</details>

<details>

<summary>What wallets are supported for sBTC?</summary>

[Xverse](https://www.xverse.app/) and [Leather](https://leather.io/) wallets are supported — two leading wallets with seamless integrations designed for Bitcoin and Stacks users.

In addition, [Ledger](https://www.ledger.com/) and [Asigna](https://www.asigna.io/) support sBTC.

We are actively working with institutional custodians, staking providers, and other 3rd party wallets to support sBTC. More will be announced.

</details>

<details>

<summary>Why is there a .001 BTC minimum for BTC to sBTC deposits?</summary>

A .001 BTC minimum is imposed for BTC to sBTC deposits to ensure the system does not get spammed by many smaller transactions. We are exploring reducing the deposit minimum for future phases.

</details>

<details>

<summary>What are the steps to use the sBTC Bridge and earn rewards?</summary>

In the Stacks Documentation, find a [video](https://www.youtube.com/watch?v=XZruuDgTo4k\&t=1s) and a more detailed [walkthrough](https://docs.stacks.co/learn/sbtc/using-the-sbtc-bridge-app).

</details>

<details>

<summary>How long will it take for my BTC deposit to confirm?</summary>

sBTC facilitates rapid movement between BTC and sBTC.

BTC to sBTCBTC to sBTC conversion can be completed within 3 Bitcoin blocks (under an hour).sBTC to BTCsBTC to BTC conversion can be completed within 6 Bitcoin blocks (Approximately two hours)

Read more in the [Stacks Documentation](https://docs.stacks.co/concepts/sbtc/operations/deposit-withdrawal-times).

</details>

<details>

<summary>Why is there a cap on the total BTC pegged in?</summary>

A BTC cap will be implemented to ensure a smooth rollout process with a focus on security.

In addition, the BTC cap will give developers the time to focus on the sBTC user experience and integration with DeFi applications across the Stacks ecosystem prior to opening sBTC for all users.

</details>

<details>

<summary>Are there any associated fees with minting sBTC?</summary>

There are two transaction fees required to mint your sBTC. The first is set by the user manually when they initiate the deposit transaction within their wallet.

The second is a fee used to consolidate the deposit UTXOs into the single signer UTXO. This separate transaction fee happens automatically and is set to a max of 80k sats. This is automatically deducted from your minted sBTC. This is not a signer fee but a regular Bitcoin transaction fee.

</details>

<details>

<summary>Are there multi-signature solutions for sBTC?</summary>

Yes. [Asigna](https://www.asigna.io/) provides a multi-signature solution for sBTC users.

</details>

<details>

<summary>Are custodians available to support sBTC?</summary>

At the moment, there is no custodian support for sBTC. However, we are actively working with institutional custodians to support sBTC.

Copper and BitGo already support Stacks and Stacking; however, we are working to prioritize SIP-10 and sBTC integration.

</details>

### sBTC Troubleshooting

<details>

<summary>My Bitcoin transaction confirmed, but I'm not seeing the sBTC token in my wallet.</summary>

You may need to enable the display of the sBTC token within your wallet by clicking on 'Manage Tokens' and enabling sBTC.

</details>

<details>

<summary>I received an "Errors.Invalid_Transaction" error when using an Xverse Wallet</summary>

If you received a "Errors.Invalid\_Transaction" error when using an Xverse Wallet, you may be using a "Nested SegWit" wallet. To resolve the issue, change your Xverse wallet to use the "Native SegWit".

</details>

<details>

<summary>sBTC still isn't showing up in wallet after 3 Bitcoin blocks. How much longer do I have to wait?</summary>

BTC to sBTC conversions are typically completed within 3 Bitcoin blocks. Due to the speed of Bitcoin blocks, deposits can take up to two hours to see sBTC in your wallet.

However, there may be a lag with your Leather or Xverse wallet where the sBTC will take another 20 minutes to show up in the wallet.

</details>


# Dual Stacking

An overview of the BTC-denominated rewards mechanism on Stacks

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2FXdLXwkhhT6oWHaZZfeBB%2Fdual-stacking.png?alt=media&#x26;token=9384e0e6-0967-4d00-9e7b-7142ff657da4" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
Check out the official blog announcement of Dual Stacking [here](https://www.stacks.co/blog/dual-stacking-launches-on-stacks).
{% endhint %}

{% hint style="danger" %}
Dual Stacking contracts will be upgraded on Dec 15. This upgrade enables more flexible reward parameters and allows users to view their sBTC holdings and corresponding rewards within the Dual Stacking app.

1. If you enrolled in Dual Stacking you'll be moved over automatically with no action needed.
2. If you did not enroll in the web app but were receiving Dual Stacking rewards through a participating app, you need to enroll on the web app.

To check your enrollment status go to [app.stacks.co](https://app.stacks.co/).
{% endhint %}

Dual Stacking enables Bitcoin holders to earn Bitcoin-denominated rewards through Stacks' [Proof of Transfer](https://docs.stacks.co/learn/stacks-101/proof-of-transfer) consensus. Rewards are paid in [sBTC](https://docs.stacks.co/learn/sbtc).

Dual Stacking is the only way to earn Bitcoin rewards while stacking Bitcoin. Other blockchains pay rewards in their native token (ETH, SOL, etc.). They have no mechanism to generate real Bitcoin. **Stacks' Proof of Transfer (PoX)** is the architectural difference that makes Bitcoin earning Bitcoin rewards possible.\
\
As more BTC enters the Stacks network, rates will adjust. But the multiplier effect remains: pairing STX with your BTC and deploying sBTC into DeFi always amplify your returns.

***

Additional Resources

* \[[Stacks YT](https://youtu.be/bfWPr_qMQmc?si=A9R2OKRHZ-N6Uwhe)] Dual Stacking Explained: Earn Bitcoin on Your Bitcoin


# How to Start Dual Stacking

Getting starting in Dual Stacking is simple.

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-3d7305b5c385e2b734bb87b8eee5d1e7b6a422fe%2FGroup%20316124782.png?alt=media" alt=""><figcaption><p><a href="http://app.stacks.co/">app.stacks.co</a></p></figcaption></figure>

{% hint style="warning" %}
Coinciding with the Dual Stacking launch, the existing sBTC Rewards Program will sunset on October 31, 2024. Starting October 30th, enroll in the Dual Stacking Rewards Contract (specific instructions to follow).

NOTE: you will have until \~ Nov 4 (end of Cycle 121) to enroll, and you will continue to earn rewards from the current program until this date.
{% endhint %}

### **Overview of how to start Dual Stacking**

1. **Mint sBTC** → 1:1 Bitcoin-backed. Enroll in dual stacking to earn baseline reward.
2. **Stack STX** → Stack STX alongside your sBTC to multiply returns up to 10x.
3. **Use in DeFi** → Deploy sBTC across protocols while still earning rewards.
4. **Earn sBTC** → and redeem 1:1 for BTC anytime.

PS: your stacked STX continues to earn bitcoin while in dual stacking.

### Dual Stacking Web App

The [Dual Stacking Web App](https://app.stacks.co/) is the primary user interface for participating in Dual Stacking — a mechanism that allows Bitcoin holders to earn BTC-denominated rewards through sBTC, and maximize those rewards by either stacking STX or using sBTC in DeFi.

{% hint style="info" %}
The minimum to mint sBTC via the sBTC Bridge app is currently at 0.001 BTC (100,000 sats).

The minimum to enroll in Dual Stacking with your minted sBTC will be 0.0001 sBTC (10,000 sats).
{% endhint %}

Once connected to the web app, you'll see the dashboard that lays out all the metrics regarding your rewards composition and different methods for boosting rewards. Track your balances, rewards and payouts at anytime.

The 'Boost your rewards' section will layout the steps for you to enroll and boost your rewards. All rewards are distributed in sBTC, redeemable 1:1 for BTC anytime.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-55bbbe3eca556c971d18f3a93dc12c07ba6d0aa4%2Fimage%2075%20(1).png?alt=media" alt=""><figcaption><p>Track your balances, rewards and payouts at anytime on the Dual Stacking dashboard.</p></figcaption></figure></div>

Use the Dual Stacking calculator for estimated rewards based on the ratio of sBTC in your wallet and STX stacked. For more details on how your rewards are calculated and the math behind it, check out the section on the Dual Stacking [reward function](https://docs.stacks.co/learn/economic-model#reward-function-parameters).

Start Dual Stacking now with the following wallets:

* [Dual Stack with Fordefi](https://docs.stacks.co/learn/dual-stacking/how-to-start-dual-stacking/using-fordefi)
* [Dual Stacking with Asigna](https://docs.stacks.co/learn/dual-stacking/how-to-start-dual-stacking/using-asigna)
* [Dual Stack with Leather](https://docs.stacks.co/learn/dual-stacking/how-to-start-dual-stacking/using-leather)

### Who is this app for?

{% tabs %}
{% tab title="sBTC holders" %}
At the end of October, users participating in sBTC Rewards program will need to enroll in Dual Stacking in order to continue earning sBTC rewards. This web app is the main way for them to do that.
{% endtab %}

{% tab title="BTC holders" %}
There are relatively few options to earn yield on BTC. This app gives BTC holders an option to earn BTC denominated rewards in an easy, trust minimized way.
{% endtab %}

{% tab title="STX holders" %}
STX holders who have participated in regular Stacking might be intrigued about a new type of Stacking, dual stacking. This app lets them try out a new iteration of a familiar flow.
{% endtab %}
{% endtabs %}

***

It's simple: Stack bitcoin, Earn bitcoin 🟧

For more questions and help with Dual Stacking, reach out to us and the community in our [Discord](https://discord.gg/5DJaBrf) and on our official [Stacks twitter](https://twitter.com/Stacks).


# Dual Stack with Fordefi

A guide in getting started with Dual Stacking using the Fordefi MPC wallet

{% hint style="warning" %}
This guide is specifically for entities or teams that use [Fordefi](https://fordefi.com/). This assumes you have the Fordefi wallet setup with its browser extension and with its mobile app.
{% endhint %}

The Dual Stacking Web App is the primary user interface for participating in Dual Stacking — a mechanism that allows Bitcoin holders to earn BTC-denominated rewards through sBTC, and maximize those rewards by either stacking STX or using sBTC in DeFi.

{% hint style="danger" %}
Ensure that you are using the official Dual Stacking app located at [app.stacks.co](https://app.stacks.co/).
{% endhint %}

For this guide, we'll walkthrough how you can use your Fordefi wallet in enrolling Dual Stacking and participating in DeFi for boosted rewards. This guide assumes you have a dedicated Bitcoin vault and Stacks vault setup in your Fordefi wallet.

If you need assistance in setting up your vaults in Fordefi, check out their dedicated [docs](https://docs.fordefi.com/user-guide/policies).

Before enrolling in Dual Stacking, you'll need sBTC. Peg in BTC to sBTC through the [sBTC bridge](https://app.stacks.co/) (where it remains 1:1 Bitcoin-backed at all times). Check out the dedicated guide on how you can mint sBTC to your Fordefi [wallet](https://docs.stacks.co/build/sbtc/how-to-use-the-sbtc-bridge-with-fordefi).

### Walkthrough for enrolling in Dual Stacking

Here are the necessary steps to enroll your sBTC using Fordefi:

{% stepper %}
{% step %}
**Connect Fordefi to the Dual Stacking app**

Upon popup of the connect wallet modal, select the Fordefi option to connect with. As per the usual flow of connecting your Fordefi wallet with other Stacks apps, it'll prompt you to first select your Bitcoin vault, and then your Stacks vault.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-1068a1749be3d4181df736dfd958520e4a957967%2Fimage%2051.png?alt=media" alt=""><figcaption><p>Select which Bitcoin vault you want to connect with first.</p></figcaption></figure></div>

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-1e2f1817fab50f4aabfb24f1611ee73d0602cc62%2Fimage%2052.png?alt=media" alt=""><figcaption><p>Then choose which Stacks vault you want to connect with.</p></figcaption></figure></div>
{% endstep %}

{% step %}
**Enroll now for Dual Stacking**

On the dashboard, you'll be able to see stats regarding your current sBTC in wallet, sBTC in DeFi, STX currently stacked, and estimated APY you could be earning.

Let's get started by enrolling your sBTC into Dual Stacking.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-b631433dc08e5229ecc64a18e9efa8c92fe0bc22%2Fimage%2054.png?alt=media" alt=""><figcaption><p>Click on 'Enroll now' under the 'Enroll for rewards' step.</p></figcaption></figure></div>
{% endstep %}

{% step %}
**Create transaction**

Your Fordefi extension will appear with a popup asking you to review the transaction for creation. This will create the transaction which you will later sign and broadcast in your Fordefi mobile wallet.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-2f38ecdc2f78de05eaa36ee29afb6d3870e5ced9%2Fimage%2059%20(1).png?alt=media" alt=""><figcaption><p>Create the transaction to queue it up in your Fordefi wallet for signing and broadcasting.</p></figcaption></figure></div>
{% endstep %}

{% step %}
**Sign transaction in Fordefi mobile app**

If you navigate back to your Fordefi web wallet, you'll see the transaction queued up for signatures. Depending on the transaction policy that is setup with your Fordefi vaults, you may need to instruct the designated approvers to all confirm and sign the transaction in their Fordefi mobile wallets.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-511198ba4964919c8a3dcc3d7659ba785c2d8744%2Fimage%2061.png?alt=media" alt=""><figcaption><p>The 'enroll' transaction will be queued up in your Fordefi web wallet. You'll need to sign the transaction via the mobile wallet.</p></figcaption></figure></div>

Within the Fordefi mobile wallet, you'll see the same transaction waiting for signing. Go ahead and sign the transaction which will then broadcast the transaction to the network.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-ec89052ddb498a17583560f94c02babda05c044d%2FGroup%20316124781.png?alt=media" alt=""><figcaption><p>Complete all signatures in the Fordefi mobile wallet.</p></figcaption></figure></div>

Your enroll transaction will look like this [here](https://explorer.hiro.so/txid/0x3b4ea853df54825adad3ab475d93be18c6a12f04033c665d4597984786feb608?chain=mainnet).
{% endstep %}

{% step %}
**You are now enrolled in Dual Stacking**

You'll notice your sBTC now enrolled in Dual Stacking and when the rewards cycle will start for your enrolled sBTC.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-1baf7eb30e86b887beeaa961aa665b412e39d22c%2Fimage%2063.png?alt=media" alt=""><figcaption><p>You are now Dual Stacking!</p></figcaption></figure></div>

The dashboard will also provide a view of your Dual Stacking portfolio.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-bda195f724b6fbda41913982508d629f99c6329a%2Fimage%2064.png?alt=media" alt=""><figcaption><p>View when your sBTC will start earning rewards and the breakdown of rewards composition.</p></figcaption></figure></div>
{% endstep %}

{% step %}
**Boost rewards by stacking STX**

So what's next? You could then boost your rewards by stacking STX. Let's start by stacking STX via [StackingDAO](https://www.stackingdao.com/). StackingDAO is a popular stacking option in Stacks as it is a liquid stacking method.

{% hint style="info" %}
There are other options for stacking your STX that you can find [here](https://app.leather.io/stacking).
{% endhint %}

Navigate to the StackingDAO app, connect your wallet, and start stacking. There are many methods to start liquid stacking or native stacking within StackingDAO. In this example, we'll use our STX to liquid stack with sBTC yield.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-3d9caedca84c35a7b59fb7105957bc233d53e767%2Fimage%2067.png?alt=media" alt=""><figcaption><p>Liquid stacking with sBTC yield allows us to stay liquid and earn sBTC while stacking.</p></figcaption></figure></div>

You'll then notice the Dual Stacking app to detect your stacked positions and include that as part of your portfolio's reward composition for boosted rewards.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-c276c29218076f7ed8b40423d6f4a0638b939201%2Fimage%2068.png?alt=media" alt=""><figcaption><p>Notice the change in estimated APY and total portfolio value after stacking.</p></figcaption></figure></div>

Let's then boost reward with Stacks DeFi. This will help reach the maximum APY boost for your sBTC.
{% endstep %}

{% step %}
**Deploy your sBTC to Stacks DeFi protocols**

You'll notice near the bottom of the dashboard page, there is a section highlighting popular DeFi protocols in Stacks. Each one of these protocols are eligible for the boosted rewards you can realize.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-ce091cec2b9f7544f47f640f6b314c8ba35f9c53%2Fimage%2069.png?alt=media" alt=""><figcaption></figcaption></figure></div>

Let's deploy sBTC with Zest. Supplying sBTC in Zest will provide users with a supply APY. Confirm the 'Supply' transaction via the same signature flow with Fordefi.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-a9a9a34bd765b9c5a86d6836ef9e1774a3ff8d5c%2Fimage%2074.png?alt=media" alt=""><figcaption></figcaption></figure></div>

After deploying sBTC into Zest, navigate back to the Dual Stacking web app to see your current estimated APY and rewards composition.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-55bbbe3eca556c971d18f3a93dc12c07ba6d0aa4%2Fimage%2075%20(1).png?alt=media" alt=""><figcaption></figcaption></figure></div>

Check back on the Dual Stacking dashboard to stay current with your rewards and rewards composition. All rewards are distributed in sBTC, redeemable 1:1 for BTC anytime.
{% endstep %}
{% endstepper %}

***

Reach out to us on [Discord](https://discord.com/invite/stacks-621759717756370964) for any further questions regarding Dual Stacking.


# Dual Stack with Asigna

A guide in getting started with Dual Stacking using the Asigna wallet.

{% hint style="warning" %}
This guide is specifically for entities or teams that use [Asigna](https://www.asigna.io/). This assumes you have the Asigna wallet setup with its browser extension and a multi-signature setup.
{% endhint %}

The Dual Stacking Web App is the primary user interface for participating in Dual Stacking — a mechanism that allows Bitcoin holders to earn BTC-denominated rewards through sBTC, and maximize those rewards by either stacking STX or using sBTC in DeFi.

{% hint style="danger" %}
Ensure that you are using the official Dual Stacking app located at [app.stacks.co](https://app.stacks.co/).
{% endhint %}

For this guide, we'll walkthrough how you can use your Asigna wallet in enrolling Dual Stacking and participating in DeFi for boosted rewards. This guide assumes you have a dedicated Stacks vault setup with multi-signature in your Asigna wallet.

If you need assistance in setting up your vaults in Asigna, check out their dedicated [docs](https://asigna.gitbook.io/asigna).

Before enrolling in Dual Stacking, you'll need sBTC. Peg in BTC to sBTC through the [sBTC bridge](https://app.stacks.co/) (where it remains 1:1 Bitcoin-backed at all times). Check out the dedicated [guide](https://docs.stacks.co/build/sbtc/how-to-use-the-sbtc-bridge-with-asigna) on how you can mint sBTC to your Asigna wallet.

### Walkthrough for enrolling in Dual Stacking

Here are the necessary steps to enroll your sBTC using Asigna:

{% stepper %}
{% step %}
**Connect Asigna to the Dual Stacking app**

Upon popup of the connect wallet modal, select the Asigna option to connect with. As per the usual flow of connecting your Asigna wallet with other Stacks apps, you'll most likely also need to connect the Asigna web wallet view with the Asigna browser extension before connecting with the app.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-3aeef02d164de0e2239c3e3dd384e2f7b779a8f6%2Fimage%2078%20(1).png?alt=media" alt=""><figcaption><p>Select which safe (Stacks vault) you want to connect with.</p></figcaption></figure></div>
{% endstep %}

{% step %}
**Enroll now for Dual Stacking**

On the dashboard, you'll be able to see stats regarding your current sBTC in wallet, sBTC in DeFi, STX currently stacked, and estimated APY you could be earning.

Let's get started by enrolling your sBTC into Dual Stacking.

Your Asigna extension will appear with a popup asking you to review the transaction for approval. This will create the transaction which you will later sign and broadcast in your Asigna web wallet view.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-351df29025ba910e53bd60aa529177bda1cd7c29%2Fimage%2080.png?alt=media" alt=""><figcaption><p>Click on 'Enroll now' under the 'Enroll for rewards' step and approve transaction in the extension popup.</p></figcaption></figure></div>
{% endstep %}

{% step %}
**Sign transaction in Asigna web view**

If you navigate back to your Asigna web wallet view, you'll see the transaction queued up for signatures. In this scenario, we have a 2-of-2 multi-signature scheme setup so we'll need to sign the transaction by both parties involved.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-17b1bfe101456e57433d582307a194afee6e055a%2FGroup%20316124783.png?alt=media" alt=""><figcaption><p>The first signature of the 2-of-2 setup will need to be signed in the Asigna web wallet view.</p></figcaption></figure></div>

Once the first signature is completed, the second signature will also need to take place in that respective signer's Asigna web wallet view. After signing, that same signer will then need to hit 'Execute' to complete the broadcasting of the transaction.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-3dbb1bbb7046ba43b774aee277e358cf1417edff%2FGroup%20316124783%20(1).png?alt=media" alt=""><figcaption><p>The second signature of the 2-of-2 setup will need to be signed in the Asigna web wallet view. After all signatures are completed, hit 'Execute' to broadcast the transaction and navigate back to the Dual Stacking app.</p></figcaption></figure></div>

Execute the signed transaction to broadcast it to the Stacks network.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-fe418d2a94b97797942e3cf7505e5a6686a72f70%2Fimage%2085.png?alt=media" alt=""><figcaption></figcaption></figure></div>

Your enroll transaction will look like this [here](https://explorer.hiro.so/txid/0x3b4ea853df54825adad3ab475d93be18c6a12f04033c665d4597984786feb608?chain=mainnet).
{% endstep %}

{% step %}
**You are now enrolled in Dual Stacking**

You'll notice your sBTC now enrolled in Dual Stacking and when the rewards cycle will start for your enrolled sBTC.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-1baf7eb30e86b887beeaa961aa665b412e39d22c%2Fimage%2063.png?alt=media" alt=""><figcaption><p>You are now Dual Stacking!</p></figcaption></figure></div>

The dashboard will also provide a view of your Dual Stacking portfolio.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-d253139871df5d1d97eea8a413c61bf95bfc526b%2Fimage%2086.png?alt=media" alt=""><figcaption></figcaption></figure></div>

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-bda195f724b6fbda41913982508d629f99c6329a%2Fimage%2064.png?alt=media" alt=""><figcaption><p>View when your sBTC will start earning rewards and the breakdown of rewards composition.</p></figcaption></figure></div>
{% endstep %}

{% step %}
**Boost rewards by stacking STX**

So what's next? You could then boost your rewards by stacking STX. Let's start by stacking STX via [StackingDAO](https://www.stackingdao.com/). StackingDAO is a popular stacking option in Stacks as it is a liquid stacking method.

{% hint style="info" %}
There are other options for stacking your STX that you can find [here](https://app.leather.io/stacking).
{% endhint %}

Navigate to the StackingDAO embedded app within your Asigna web wallet view, connect your wallet, and start stacking. There are many methods to start liquid stacking or native stacking within StackingDAO. In this example, we'll use our STX to liquid stack with sBTC yield.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-510d2f5c99fa612e6d5759dfbd6ab06def77fc4e%2Fimage%2092.png?alt=media" alt=""><figcaption><p>Liquid stacking with sBTC yield allows us to stay liquid and earn sBTC while stacking.</p></figcaption></figure></div>

Complete the same 2-of-2 multi-signature flow in your Asigna web wallet views.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-ec171c271c508df3bb8c632f49805d3fd018b18a%2Fimage%2094.png?alt=media" alt=""><figcaption><p>After all signatures are completed, execute the transaction to broadcast it to the network.</p></figcaption></figure></div>

Navigate back to the Dual Stacking app, and you'll then notice the Dual Stacking app has instantly detect your stacked positions and include that as part of your portfolio's reward composition for boosted rewards.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-08abb6b42c2fe5a1003a04833127e83ee14a427a%2Fimage%2095.png?alt=media" alt=""><figcaption><p>Notice the change in estimated APY and total portfolio value after stacking.</p></figcaption></figure></div>

Let's then boost reward with Stacks DeFi. This will help reach the maximum APY boost for your sBTC.
{% endstep %}

{% step %}
**Deploy your sBTC to Stacks DeFi protocols**

You'll notice near the bottom of the dashboard page, there is a section highlighting popular DeFi protocols in Stacks. Each one of these protocols are eligible for the boosted rewards you can realize.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-ce091cec2b9f7544f47f640f6b314c8ba35f9c53%2Fimage%2069.png?alt=media" alt=""><figcaption></figcaption></figure></div>

Let's deploy sBTC with Zest.

{% hint style="info" %}
As with using the embedded StackingDAO app, we'll also be using the embedded Zest app found in the Asigna web wallet view.
{% endhint %}

Supplying sBTC in Zest will provide users with a supply APY. Confirm the 'Supply' transaction via the same signature flow with Asigna.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-a9a9a34bd765b9c5a86d6836ef9e1774a3ff8d5c%2Fimage%2074.png?alt=media" alt=""><figcaption></figcaption></figure></div>

After deploying sBTC into Zest, navigate back to the Dual Stacking web app to see your current estimated APY and rewards composition.

Check back on the Dual Stacking dashboard to stay current with your rewards and rewards composition. All rewards are distributed in sBTC, redeemable 1:1 for BTC anytime.
{% endstep %}
{% endstepper %}

***

Reach out to us on [Discord](https://discord.com/invite/stacks-621759717756370964) for any further questions regarding Dual Stacking.


# Dual Stack with Leather

A guide in getting started with Dual Stacking using the Leather wallet.

{% hint style="warning" %}
This guide is specifically for users that use the Leather wallet. This assumes you have the Leather wallet extension setup. The flow will also be similar for Xverse wallet users.
{% endhint %}

The Dual Stacking Web App is the primary user interface for participating in Dual Stacking — a mechanism that allows Bitcoin holders to earn BTC-denominated rewards through sBTC, and maximize those rewards by either stacking STX or using sBTC in DeFi.

{% hint style="danger" %}
Ensure that you are using the official Dual Stacking app located at [app.stacks.co](https://app.stacks.co/).
{% endhint %}

For this guide, we'll walkthrough how you can use your Leather wallet in enrolling Dual Stacking and participating in DeFi for boosted rewards. This guide assumes you have already setup a Leather wallet extension.

If you need assistance in setting up your Leather wallet extension, check out their webpage [here](https://leather.io/).

Before enrolling in Dual Stacking, you'll need sBTC. Peg in BTC to sBTC through the [sBTC bridge](https://app.stacks.co/) (where it remains 1:1 Bitcoin-backed at all times). Check out the dedicated [guide](https://docs.stacks.co/build/sbtc/how-to-use-the-sbtc-bridge) on how you can mint sBTC to your Leather wallet.

### Walkthrough for enrolling in Dual Stacking

Here are the necessary steps to enroll your sBTC using Leather:

{% stepper %}
{% step %}
**Connect Leather to the Dual Stacking app**

Upon popup of the connect wallet modal, select the Leather option to connect with.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-e697c990dd7a95a0c09ec68b85259ea4322c9536%2Fimage.png?alt=media" alt=""><figcaption><p>Confirm connecting in your Leather modal popup.</p></figcaption></figure></div>
{% endstep %}

{% step %}
**Enroll now for Dual Stacking**

On the dashboard, you'll be able to see stats regarding your current sBTC in wallet, sBTC in DeFi, STX currently stacked, and estimated APY you could be earning.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-77d893cfa58afad2c762ebb6bf4ed77913d25695%2Fimage.png?alt=media" alt=""><figcaption></figcaption></figure></div>

Let's get started by enrolling your sBTC into Dual Stacking.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-4286197b5872ade0949a41dc95cbd691b882b678%2Fimage.png?alt=media" alt=""><figcaption></figcaption></figure></div>

Your Leather extension will appear with a popup asking you to review the transaction for approval. This will create the transaction which you will sign and broadcast in your Leather web wallet view.

Your enroll transaction will look like this [here](https://explorer.hiro.so/txid/0x3b4ea853df54825adad3ab475d93be18c6a12f04033c665d4597984786feb608?chain=mainnet).
{% endstep %}

{% step %}
**You are now enrolled in Dual Stacking**

You'll notice your sBTC now enrolled in Dual Stacking and when the rewards cycle will start for your enrolled sBTC.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-1baf7eb30e86b887beeaa961aa665b412e39d22c%2Fimage%2063.png?alt=media" alt=""><figcaption><p>You are now Dual Stacking!</p></figcaption></figure></div>

The dashboard will also provide a view of your Dual Stacking portfolio. Track your balances, rewards and payouts at anytime.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-9577dcdcd093284717cfcc39c056543e461f7b31%2Fimage.png?alt=media" alt=""><figcaption></figcaption></figure></div>

Use the Dual Stacking calculator for estimated rewards based on the ratio of sBTC in your wallet and STX stacked. For more details on your rewards are calculated and the math behind it, check out the section on the [reward function](https://docs.stacks.co/learn/economic-model#reward-function-parameters).

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-983ff96f5294db640d9a76b626e5e002755dd968%2Fimage.png?alt=media" alt=""><figcaption></figcaption></figure></div>
{% endstep %}

{% step %}
**Boost rewards by stacking STX**

So what's next? You could then boost your rewards by stacking STX. Let's start by stacking STX via [StackingDAO](https://www.stackingdao.com/). StackingDAO is a popular stacking option in Stacks as it is a liquid stacking method.

{% hint style="info" %}
There are other options for stacking your STX that you can find [here](https://app.leather.io/stacking).
{% endhint %}

Navigate to the StackingDAO app, connect your wallet, and start stacking. There are many methods to start liquid stacking or native stacking within StackingDAO. In this example, we'll use our STX to liquid stack with sBTC yield.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-510d2f5c99fa612e6d5759dfbd6ab06def77fc4e%2Fimage%2092.png?alt=media" alt=""><figcaption><p>Liquid stacking with sBTC yield allows us to stay liquid and earn sBTC while stacking.</p></figcaption></figure></div>

Choose the amount in STX that you want to stack and click on 'Confirm Stack', your Leather wallet extension will then appear prompting you to approve transaction.

Navigate back to the Dual Stacking app, and you'll then notice the Dual Stacking app has instantly detect your stacked positions and include that as part of your portfolio's reward composition for boosted rewards.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-08abb6b42c2fe5a1003a04833127e83ee14a427a%2Fimage%2095.png?alt=media" alt=""><figcaption><p>Notice the change in estimated APY and total portfolio value after stacking.</p></figcaption></figure></div>

Let's then boost reward with Stacks DeFi. This will help reach the maximum APY boost for your sBTC.
{% endstep %}

{% step %}
**Deploy your sBTC to Stacks DeFi protocols**

You'll notice near the bottom of the dashboard page, there is a section highlighting popular DeFi protocols in Stacks. Each one of these protocols are eligible for the boosted rewards you can realize.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-ce091cec2b9f7544f47f640f6b314c8ba35f9c53%2Fimage%2069.png?alt=media" alt=""><figcaption></figcaption></figure></div>

Let's deploy sBTC with Zest. Supplying sBTC in Zest will provide users with a supply APY. Confirm the 'Supply' transaction via the same signature flow using Leather.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-a9a9a34bd765b9c5a86d6836ef9e1774a3ff8d5c%2Fimage%2074.png?alt=media" alt=""><figcaption></figcaption></figure></div>

After deploying sBTC into Zest, navigate back to the Dual Stacking web app to see your current estimated APY and rewards composition.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-8af2350646d52a85d13fd5c9c409546a223064d9%2Fimage.png?alt=media" alt=""><figcaption><p>View a breakdown of rewards per reward cycle.</p></figcaption></figure></div>

Check back on the Dual Stacking dashboard to stay current with your rewards and rewards composition. Depending on when your rewards cycle start for your enrollment, you'll see the rewards breakdown in the middle section. All rewards are distributed in sBTC, redeemable 1:1 for BTC anytime.
{% endstep %}
{% endstepper %}

***

Reach out to us on [Discord](https://discord.com/invite/stacks-621759717756370964) for any further questions regarding Dual Stacking.


# Economic Model

Understanding the economics behind Dual Stacking.

<figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-62a239656a550f8d9a05a8645aee1c33edab992a%2Fimage.png?alt=media" alt=""><figcaption><p>Users stake BTC, STX, or both to earn BTC-denominated rewards (via sBTC and BTC).</p></figcaption></figure>

Dual Stacking introduces an economic model in which BTC-denominated rewards scale with the participant’s ratio of sBTC to stacked STX as well as sBTC deployed in DeFi. This creates a direct link between Bitcoin capital and the growth of the Stacks ecosystem.

All participants receive a baseline BTC-denominated reward on the sBTC enrolled in Dual Stacking. They have the option of earning additional rewards by stacking STX as well as deploying sBTC into DeFi.

For Stacking STX, Bitcoin rewards grow based on an individuals STX-to-sBTC ratio relative to other participants, up to 10× the base yield. The system uses a square-root curve, meaning the first stacked STX has the greatest impact, with smaller boosts as more STX is stacked. The DeFi boost is straightforward, you automatically earn 10x multiple for any amount of sBTC deployed in DeFi.

At the same time, an individual's stacked STX continues earning standard [stacking](https://docs.stacks.co/learn/block-production/stacking) rewards.

{% hint style="info" %}
The following Reward Function Parameters section is taken directly from the [Dual Stacking litepaper](https://github.com/stx-labs/papers/blob/main/Dual%20Stacking%20Litepaper.pdf).
{% endhint %}

#### Reward Function Parameters

* **Rewards Boost Multiplier** – Defines the maximum multiple of base reward attainable by users\
  with the highest STX/BTC ratio. For example, with a 10× multiplier, a user earning 0.5%\
  base reward could reach 5% if staking the maximum effective ratio of STX to BTC.
* **Reward Function Curve** – Defines how rewards scale across intermediate STX/BTC\
  ratios. A square-root curve introduces diminishing returns, encouraging broad\
  participation rather than concentration of rewards among large holders.
* **Max Reference STX/BTC Ratio** – Set to the BTC-weighted 95th percentile of STX/BTC\
  ratios among users. That is, the value above which only 5% of total locked BTC has a\
  higher STX/BTC ratio. Under this approach, for a user to unilaterally set the max\
  reference STX/BTC ratio, the user would need both 5% of the total BTC locked and have\
  the highest STX/BTC ratio for those BTC. This design minimizes manipulation by\
  preventing outliers from disproportionately setting the maximum yield threshold.

To describe the reward function more precisely, we’ll define some terms:

* 𝑌 − 𝑇𝑜𝑡𝑎𝑙 𝐵𝑇𝐶 𝑑𝑖𝑠𝑡𝑟𝑖𝑏𝑢𝑡𝑒𝑑 𝑎𝑠 𝑟𝑒𝑤𝑎𝑟𝑑𝑠 𝑡𝑜 𝑑𝑢𝑎𝑙 𝑠𝑡𝑎𝑐𝑘𝑖𝑛𝑔 𝑑𝑢𝑟𝑖𝑛𝑔 𝑎 𝑆𝑡𝑎𝑐𝑘𝑖𝑛𝑔 𝑐𝑦𝑐𝑙𝑒
* 𝐵<sub>𝑖</sub> − 𝐴𝑚𝑜𝑢𝑛𝑡 𝑜𝑓 𝐵𝑇𝐶 𝑡ℎ𝑒 𝑖𝑡ℎ 𝑢𝑠𝑒𝑟 𝑙𝑜𝑐𝑘𝑠 𝑖𝑛 𝑎 𝑆𝑡𝑎𝑐𝑘𝑖𝑛𝑔 𝑐𝑦𝑐𝑙𝑒
* 𝑆<sub>𝑖</sub> − 𝐴𝑚𝑜𝑢𝑛𝑡 𝑜𝑓 𝑆𝑇𝑋 𝑡ℎ𝑒 𝑖𝑡ℎ 𝑢𝑠𝑒𝑟 𝑙𝑜𝑐𝑘𝑠 𝑖𝑛 𝑎 𝑆𝑡𝑎𝑐𝑘𝑖𝑛𝑔 𝑐𝑦𝑐𝑙𝑒
* 𝑑<sub>𝑖</sub> = 𝑆<sub>𝑖</sub> */* 𝐵<sub>𝑖</sub> − 𝐴𝑚𝑜𝑢𝑛𝑡 𝑜𝑓 𝑆𝑇𝑋 𝑝𝑒𝑟 𝐵𝑇𝐶 𝑡ℎ𝑒 𝑖𝑡ℎ 𝑢𝑠𝑒𝑟 𝑙𝑜𝑐𝑘𝑠 𝑖𝑛 𝑎 𝑆𝑡𝑎𝑐𝑘𝑖𝑛𝑔 𝑐𝑦𝑐𝑙𝑒
* 𝐷 − 𝑀𝑎𝑥 𝑟𝑒𝑓𝑒𝑟𝑒𝑛𝑐𝑒 𝑑<sub>𝑖</sub> , 𝑤ℎ𝑖𝑐ℎ 𝑖𝑠 𝑠𝑒𝑡 𝑡𝑜 𝑡ℎ𝑒 95𝑡ℎ 𝑝𝑒𝑟𝑐𝑒𝑛𝑡𝑖𝑙𝑒 𝑜𝑓 𝐵𝑇𝐶𝑤𝑒𝑖𝑔ℎ𝑡𝑒𝑑 𝑑<sub>𝑖</sub>
* 𝑀 − 𝑟𝑒𝑤𝑎𝑟𝑑𝑠 𝑏𝑜𝑜𝑠𝑡 𝑚𝑢𝑙𝑡𝑖𝑝𝑙𝑖𝑒𝑟 𝑚𝑖𝑛𝑢𝑠 𝑜𝑛𝑒

The first step in our reward function is to determine a normalized ratio, 𝑟<sub>𝑖</sub> , for all users:

$$
𝑟\_𝑖 = 𝑚𝑖𝑛(\frac{𝑑\_𝑖}{𝐷}, 1)
$$

With the normalized ratio, we can then determine normalized weights, *w*<sub>𝑖</sub> , for all users:

$$
𝑤\_𝑖 = 𝐵\_𝑖\cdot(1 + 𝑀\cdot \sqrt{𝑟\_𝑖})
$$

Ultimately, the rewards for each user, *y*<sub>𝑖</sub> , would be:

$$
𝑦\_𝑖 = 𝑌 \cdot \frac{𝑤\_𝑖}{\sum𝑤\_𝑗}
$$

The generalized shape of the reward function is shown in the graph below. The two lines, one\
dark orange and one light orange, show the shape of the yield curves for the expected rewards on\
one’s sBTC holdings only as a result of dual stacking rewards, and the shape of the yield curve\
for one’s combined sBTC and STX as a result of the combination of dual stacking rewards on\
one’s sBTC and the standard stacking rewards for one’s STX.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fgit-blob-2848b170669461943322c6998a08151d6678b47c%2Fimage.png?alt=media" alt=""><figcaption><p>Staking STX alongside BTC amplifies rewards based on a yield curve, up to 10x.</p></figcaption></figure></div>

***

For more detail on the Reward Function parameters and models, refer to the [Dual Stacking litepaper](https://github.com/stx-labs/papers/blob/main/Dual%20Stacking%20Litepaper.pdf).


# Dual Stacking Smart Contract

## Overview

The Dual Stacking contract enables participants to earn boosted sBTC rewards by holding sBTC and optionally stacking STX. It operates in cycles with periodic snapshots to calculate rewards based on holdings and stacking participation.

{% hint style="info" %}
For the live dual stacking contract on mainnet, check out the contract page [here](https://explorer.hiro.so/txid/SP1HFCRKEJ8BYW4D0E3FAWHFDX8A25PPAA83HWWZ9.dual-stacking-v1?chain=mainnet).

On December 15, 2025, the dual stacking contract will be upgraded to [`.dual-stacking-v2_0_2`](https://explorer.hiro.so/txid/SP1HFCRKEJ8BYW4D0E3FAWHFDX8A25PPAA83HWWZ9.dual-stacking-v2_0_2?chain=mainnet)
{% endhint %}

### Decentralized Architecture

* Permissionless operations: Anyone can execute critical cycle operations including snapshot capturing, ratio proposal/validation, weight calculation, and reward distribution.
* On-chain data only: All participant data (sBTC balances, STX stacking amounts) is read directly from the blockchain — no off-chain oracles or trusted data sources required.
* Competitive ratio discovery: Multiple participants can propose different golden ratios; the system validates based on mathematical criteria (95th percentile), not admin approval.
* Transparent execution: All operations are executed on-chain with verifiable results and public event logs.
* Self-service enrollment: Users can enroll, opt-out, and manage their participation independently.

### Main Operations

{% stepper %}
{% step %}
**Initialization**

The contract is initialized once with a Stacks block height parameter that is the first one in the Bitcoin block specified, or after it, in case there aren't any STX blocks anchored to it.
{% endstep %}

{% step %}
**Enrollment**

Users can self-enroll for participation with custom reward addresses. DeFi protocols can be enrolled by admin with custom tracking, stacking, and reward addresses. All participants can opt-out or change their addresses at any time.
{% endstep %}

{% step %}
**Snapshots and Cycles**

Anyone can trigger periodic snapshots that capture participant sBTC balances and STX stacking amounts from on-chain data based on predefined block intervals.
{% endstep %}

{% step %}
**Ratio Computation**

After snapshots are complete, anyone can propose a golden ratio (optimal STX/sBTC ratio), tally participant distributions, and validate if their proposal meets the 95th percentile criteria to determine the benchmark for maximum rewards.
{% endstep %}

{% step %}
**Weight Calculation**

Anyone can trigger participant weight calculations using the validated dual stacking formula that provides up to 10x boost (configurable) for those who meet or exceed the golden ratio.
{% endstep %}

{% step %}
**Rewards**

Anyone can trigger reward distribution every cycle based on calculated weights. Administrators can update configurations like APR, yield boost multiplier, snapshot length, and number of snapshots per cycle.
{% endstep %}

{% step %}
**Administrative Controls**

Admins maintain protocol parameters, enroll/opt-out DeFi protocols with special address configurations, manage whitelists and blacklists, and can perform emergency operations if needed.
{% endstep %}
{% endstepper %}

***

## Cycle Structure

* Each cycle consists of a fixed number of snapshots (default 14).
* Each snapshot occurs after a set number of Bitcoin blocks (default 150).
* The total cycle length is thus 2100 Bitcoin blocks by default (14 snapshots × 150 blocks).
* These defaults can be adjusted for production environments (e.g., 1 snapshot per day with appropriate block counts).

## Dual Stacking Formula

Weight Calculation:

$$
w\_i = \cfrac{\[B\_i \cdot (1 + M \cdot \sqrt{r\_i})]}{n}
$$

Where:

* *w*<sub>*i*</sub>*&#x20;= weight for user i*
* *B*<sub>*i*</sub>*&#x20;= sBTC balance of user i (sum across all snapshots)*
* *M = yield boost multiplier (default 9, meaning max boost of 10x)*
* *r*<sub>*i*</sub>*&#x20;= min(d*<sub>*i*</sub>*/D, 1), the ratio adjustment factor*
* *d*<sub>*i*</sub>*&#x20;= S*<sub>*i*</sub>*/B*<sub>*i*</sub>*, user's personal STX/sBTC ratio*
* *S*<sub>*i*</sub>*&#x20;= STX stacked by user i (sum across all snapshots)*
* *D = golden ratio (95th percentile STX/sBTC ratio across all participants)*
* *n = number of snapshots per cycle (default 14)*

Rewards Distribution:

$$
R\_i = (\frac{w\_i}{Σw}) \cdot Total Rewards
$$

Where:

* *R*<sub>*i*</sub>*&#x20;= reward for user i*
* *Σw = sum of all participant weights*
* *Total Rewards = min(pool balance, APR-based cap)*

Key Properties:

* *Participants with d*<sub>*i*</sub>*&#x20;≥ D receive maximum boost of (M+1) x (default 10x).*
* *Participants with d*<sub>*i*</sub>*&#x20;= 0 (no STX stacked) receive base rewards (1x).*
* *Boost scales with the square root of the ratio for intermediate values.*
* *Whitelisted DeFi tracking addresses automatically receive maximum boost without needing to stack STX.*
* *Weights are divided by the number of snapshots per cycle to normalize across the cycle duration.*

***

## Cycle Workflow

The Dual Stacking smart contract operates in cycles, each divided into snapshots. The process ensures accurate reward distribution through a series of permissionless operations that anyone can execute.

{% stepper %}
{% step %}
**Snapshot Phase (Anyone Can Execute)**

* capture-snapshot-balances: Anyone can capture balances for enrolled users after each snapshot.
* advance-to-next-snapshot: Anyone can transition to the next snapshot.
* finalize-snapshots: Anyone can conclude all snapshot data after the final snapshot.
  {% endstep %}

{% step %}
**Ratio Validation Phase (Competitive & Permissionless)**

* propose-golden-ratio: Anyone can propose a golden ratio.
* tally-participant-ratios: The proposer tallies participant ratios relative to their proposed ratio.
* validate-ratio: The proposer validates their proposal — succeeds only if it represents the 95th percentile.
* Multiple proposals can be submitted; the first valid one locks in for the cycle.
  {% endstep %}

{% step %}
**Weight Computation Phase (Anyone Can Execute)**

* calculate-participant-weights: Anyone can calculate participant weights using the dual stacking formula.
* finalize-weight-computation: Anyone can finalize weight computation.
  {% endstep %}

{% step %}
**Reward Distribution Phase (Anyone Can Execute)**

* set-is-distribution-enabled: Anyone can enable reward distribution by determining the available reward pool.
* distribute-rewards: Anyone can distribute rewards to enrolled users based on their weights.
* finalize-reward-distribution: Anyone can finalize reward distribution after all participants are rewarded.
  {% endstep %}

{% step %}
**Cycle Transition (Anyone Can Execute)**

* advance-to-next-cycle: Anyone can advance to the next cycle after all rewards are distributed.
  {% endstep %}
  {% endstepper %}

Note: All operations read data directly from the blockchain (sBTC balances from the sBTC token contract, STX stacking from native Stacks protocol). No off-chain data sources or trusted intermediaries are required.

***

## Public Functions

### 1. Contract Initialization

#### initialize-contract

Activates the contract with an initial cycle.

* Parameters: stx-block-height (uint)
* Assertions:
  * Current Bitcoin block height must be >= the configured cycle start Bitcoin block height.
  * The contract must not be active.
  * The Stacks block height must bracket the configured Bitcoin block height.
* Effect:
  * Initializes state variables for the first cycle and marks the contract as active.
  * Records cycle data and the first snapshot.

#### update-initialize-block

Updates the initialization Bitcoin block height before the contract is activated.

* Parameters: new-bitcoin-block-height (uint)
* Assertions:
  * Contract must not be active.
  * Caller must be the admin.
* Effect:
  * Updates the starting Bitcoin block height for the first cycle.

#### update-cycle-data-before-initialized

Updates both the snapshots per cycle and blocks per snapshot for the first cycle before initialization.

* Parameters: updated-snapshots-per-cycle (uint), updated-blocks-per-snapshot (uint)
* Assertions:
  * Contract must not be active.
  * Caller must be the admin.
* Effect:
  * Sets the cycle structure for the first cycle.

***

### 2. Enrollment

#### enroll

Enrolls the caller for rewards in future cycles.

* Parameters: rewarded-address (optional principal)
* Assertions:
  * Caller must not already be enrolled.
  * Caller must not be blacklisted.
  * Caller must hold at least the minimum required sBTC amount.
* Effect:
  * Adds the caller to the participants map with tracking, stacking, and rewarded addresses set appropriately.
  * Increments the next cycle participant count.

#### enroll-defi

Enrolls a DeFi protocol for rewards with custom addresses (admin only).

* Parameters:
  * defi-contract (principal)
  * tracking-address (principal)
  * rewarded-address (principal)
  * stacking-address (optional principal)
* Assertions:
  * Caller must be the admin.
  * DeFi contract must not already be enrolled.
  * DeFi contract must not be blacklisted.
* Effect:
  * Adds the DeFi protocol to the participants map with custom addresses.
  * Increments the next cycle participant count.

#### enroll-defi-batch

Batch enroll multiple DeFi protocols (admin only).

* Parameters: defi-contracts (list 900 {...})
* Assertions:
  * Caller must be the admin.
* Effect:
  * Enrolls multiple DeFi protocols in a single transaction.

#### opt-out

Allows the caller to opt out of participation in future cycles.

* Assertions:
  * Caller must be enrolled.
* Effect:
  * Removes the caller from the participants map.
  * Decrements the next cycle participant count.

#### opt-out-defi

Opts out a DeFi protocol from participation (admin only).

* Parameters: defi-contract (principal)
* Assertions:
  * Caller must be the admin.
  * DeFi contract must be enrolled.
* Effect:
  * Removes the DeFi protocol from the participants map.

#### opt-out-defi-batch

Batch opt out multiple DeFi protocols (admin only).

* Parameters: defi-contracts (list 200 principal)
* Assertions:
  * Caller must be the admin.
* Effect:
  * Opts out multiple DeFi protocols in a single transaction.

***

### 3. Participant Address Management

* change-reward-address
* change-reward-address-defi
* change-stacking-address-defi
* change-tracking-address-defi
* change-addresses-defi
* change-addresses-defi-batch

(Each function has parameters, admin assertions where applicable, and updates participant/DeFi addresses as described in the original spec.)

***

### 4. Snapshots and Cycles

#### capture-snapshot-balances

Captures snapshot balances for a list of participants at the current snapshot block height. Permissionless.

* Parameters: principals (list of up to 900 principals)
* Assertions:
  * The contract must be active.
  * The current snapshot Stacks block height must be available.
* Effect:
  * Reads sBTC balance from the sBTC token contract for each participant.
  * Reads STX stacked amount from native Stacks protocol (including liquid stacking if enabled).
  * Updates snapshot totals and participant holdings.
  * Tracks stacking and tracking addresses.

#### advance-to-next-snapshot

Advances the contract to the next snapshot within the current cycle. Permissionless.

* Parameters: new-stx-block-height (uint)
* Assertions:
  * The contract must be active.
  * All participants must be snapshotted.
  * Current Bitcoin block height must have reached the next snapshot block.
  * The cycle must not have ended.
  * The Stacks block height must bracket the next snapshot Bitcoin block height.
* Effect:
  * Increments snapshot index.
  * Aggregates snapshot totals into cycle totals.
  * Resets snapshot counters.
  * Records the new snapshot block heights.

#### finalize-snapshots

Finalizes all snapshots for the current cycle after the last snapshot is complete. Permissionless.

* Assertions:
  * The contract must be active.
  * Snapshots must not already be finalized.
  * Must be on the last snapshot of the cycle.
  * All participants must be snapshotted in the final snapshot.
* Effect:
  * Aggregates the final snapshot totals into cycle totals.
  * Marks snapshots as finalized.
  * Sets last operation state to "concluded".
  * Enables the ratio proposal phase.

#### advance-to-next-cycle

Advances the contract to the next cycle after all rewards are distributed. Permissionless.

* Parameters: stx-block-height (uint)
* Assertions:
  * The contract must be active.
  * Current Bitcoin block height must have reached the next cycle.
  * All participants must be rewarded.
  * Reward distribution must be finalized.
  * The Stacks block height must bracket the next cycle Bitcoin block height.
* Effect:
  * Increments cycle ID.
  * Resets state variables for the new cycle.
  * Updates cycle configuration from next-cycle settings.
  * Initializes the first snapshot of the new cycle.

***

### 5. Ratio Computation and Validation

#### propose-golden-ratio

Proposes a golden ratio for the current cycle. Permissionless.

* Parameters: ratio (uint) — proposed ratio scaled by 10^8
* Assertions:
  * Snapshots must be finalized.
  * A ratio must not already be validated for this cycle.
  * The caller must not have already proposed a ratio for this cycle.
* Effect:
  * Records the proposed ratio for the caller.
  * Initializes tracking for participant tallying.
  * Sets last operation state to "proposed-ratio".

#### change-proposed-golden-ratio

Change a previously proposed golden ratio before validation.

* Parameters: ratio (uint)
* Assertions:
  * The caller must have already proposed a ratio.
  * The ratio must not yet be validated.
* Effect:
  * Updates the proposed ratio and resets tally data.

#### tally-participant-ratios

Tallies how many participants have ratios above, below, or equal to the proposed golden ratio.

* Parameters: principals (list of up to 900 principals)
* Assertions:
  * The caller must have proposed a ratio.
  * The ratio must not yet be validated.
  * Must not have already tallied all participants.
* Effect:
  * Computes each participant's STX/sBTC ratio.
  * Tracks sBTC amounts above, below, and equal to the proposed ratio.
  * Increments participants counted.

#### validate-ratio

Validates that the proposed ratio represents the 95th percentile of participant ratios.

* Assertions:
  * The caller must have proposed a ratio.
  * All participants must be tallied.
  * The ratio must not already be validated.
  * If no STX is stacked by anyone, ratio must equal 1.0 (baseline).
  * sBTC above the ratio must be ≤ 5% of total sBTC.
  * sBTC at or above the ratio must be ≥ 5% of total sBTC.
* Effect:
  * Marks the ratio as validated.
  * Records the validated ratio for the cycle.
  * Sets last operation state to "ratio-validated".

#### set-max-percentage-above-ratio

Updates the percentage threshold for validation (admin only).

* Parameters: new-max-percentage-above-ratio (uint) — default 500 = 5%
* Assertions:
  * Caller must be the admin.
* Effect:
  * Updates the validation threshold.

***

### 6. Weight Computation

#### calculate-participant-weights

Calculates participant weights using the dual stacking formula. Permissionless.

* Parameters: principals (list of up to 900 principals)
* Assertions:
  * The ratio must be validated.
  * The current cycle Stacks block height must be available.
* Effect:
  * Retrieves validated golden ratio D.
  * Applies minimum threshold to D to prevent division by zero $$D = max(D, 10^-8)$$.
  * For each participant, computes weight using: $$w\_i = \cfrac{\[B\_i \cdot (1 + M \cdot √r\_i)]}{n}$$
  * Accumulates total weights in total-weights-sum.
  * Records individual weights per tracking address (not per enrolled address).

Notes:

* Multiple enrolled addresses sharing the same tracking address will share the same weight.
* Can be called in batches of up to 900 participants.

#### finalize-weight-computation

Finalizes the weight computation phase. Permissionless.

* Assertions:
  * The ratio must be validated.
  * Weights must not already be finalized.
  * All participants must have weights computed.
* Effect:
  * Marks weights as computed.
  * Sets last operation state to "weights-finalized".
  * Enables the reward distribution phase.

***

### 7. Reward Distribution

#### set-is-distribution-enabled

Prepares the contract to distribute rewards by determining the available reward pool. Permissionless.

* Assertions:
  * The contract must be active.
  * Distribution must not already be enabled.
  * Weights must be computed.
* Effect:
  * Reads the contract's sBTC balance.
  * Calculates rewards to distribute: min(pool balance, APR-based cap).
  * The cap is: $$(CPR × total-weights-sum) / (M + 1)$$
  * Marks rewards as ready for distribution.
  * Sets last operation state to "set-can-distribute".

#### distribute-rewards

Distributes rewards to participants based on their computed weights. Permissionless.

* Parameters: principals (list of up to 900 principals)
* Assertions:
  * Distribution must be enabled.
* Effect:
  * Calculates reward for each participant: (weight / total-weights) × total-rewards
  * Transfers sBTC rewards to rewarded addresses.
  * Marks participants as rewarded.
  * Aggregates rewards per rewarded address.

Notes:

* Can be called in batches of up to 900 participants.
* Multiple enrolled addresses sharing the same rewarded address aggregate rewards and only trigger one transfer per tracking address.

#### finalize-reward-distribution

Marks reward distribution as finalized for the current cycle. Permissionless.

* Assertions:
  * The contract must be active.
  * All participants must be rewarded.
  * Distribution must be enabled.
  * Must not already be finalized.
* Effect:
  * Records the finalization block height.
  * Sets last operation state to "finalized".
  * Enables cycle advancement.
  * Triggers external DeFi protocols to distribute their internal rewards (they monitor this finalization event).

***

### 8. Administrative Controls

* update-admin
* update-min-sbtc-hold-required-for-enrollment
* update-snapshot-length
* update-snapshots-per-cycle
* update-cycle-data
* update-bitcoin-blocks-per-year
* update-APR
* update-yield-boost-multiplier
* set-liquid-stacking
* emergency-withdraw-sbtc

(Each of the above has parameters, admin-only assertions where applicable, and effects described in the original spec. Notable constraints include APR bounds and multiplier bounds.)

***

### 9. Blacklist Management

* add-blacklisted
* add-blacklisted-batch
* remove-blacklisted
* remove-blacklisted-batch

(Admin-only operations to manage blacklist; adding an enrolled address auto opts it out.)

***

### 10. DeFi Whitelist Management

#### whitelist-defi-tracking

Adds a DeFi tracking address to the whitelist (gives maximum weight boost automatically).

* Parameters: defi-rewards-contract (principal)
* Assertions:
  * Caller must be the admin.
  * Address must not already be whitelisted.
* Effect:
  * Adds the tracking address to the whitelist.
  * Whitelisted addresses receive maximum boost (r<sub>i</sub> = 1.0) in weight calculations.
  * During snapshots, whitelisted addresses have their STX stacking recorded as 0 (they don't need to stack STX to receive max boost).

#### remove-whitelisted-defi-tracking

Removes a DeFi tracking address from the whitelist (admin only).

* Parameters: defi-rewards-contract (principal)
* Assertions:
  * Caller must be the admin.
  * Address must be whitelisted.
* Effect:
  * Removes the tracking address from the whitelist.

#### remove-whitelisted-defi-tracking-batch

Batch removes DeFi tracking addresses from the whitelist (admin only).

* Parameters: defi-rewards-contract (list 200 principal)
* Assertions:
  * Caller must be the admin.
* Effect:
  * Removes multiple tracking addresses from the whitelist.

***

## Private Functions

* update-snapshot-for-new-cycle: Resets snapshot counters and sets initial snapshot block heights.
* reset-state-for-cycle: Applies next-cycle configuration, resets flags and totals, records cycle data, updates participant count.
* capture-participant-balances: Reads sBTC and STX stacked at snapshot height, updates holdings and aggregates totals.
* calculate-participant-weight: Computes weight per tracking address using the dual stacking formula (integer math details in original spec).
* tally-user-ratio: Classifies a user's ratio relative to a proposed ratio and accumulates sBTC totals.
* distribute-reward-user: Transfers reward per tracking address and updates rewarded status.
* remove-participant: Deletes participant and decrements counts.
* enroll-defi-one / change-addresses-defi-one: helpers for batch operations.
* is-blacklisted: checks blacklist membership.

(Private functions implement the described effects and integer scaling considerations; refer to function details above for math/scaling behavior.)

***

## Read-Only Functions

### Cycle Information

* get-current-cycle-id
* cycle-data
* get-cycle-current-state
* current-overview-data
* get-yield-cycle-data
* nr-cycles-year
* cycle-percentage-rate

### Snapshot Information

* snapshot-data
* get-stacks-block-height-for-cycle-snapshot
* get-bitcoin-block-height-for-cycle-snapshot

### Reward Information

* get-reward-distribution-status
* is-distribution-ready
* reward-amount-for-cycle-and-address
* reward-amount-for-cycle-and-reward-address
* is-distribution-finalized-for-current-cycle
* get-distribution-finalized-at-height

### Ratio and Weight Information

* get-ratio-data
* get-weight-computation-status
* get-participant-weight

### Participant Information

* is-enrolled-in-next-cycle
* is-enrolled-this-cycle
* get-is-blacklisted
* get-is-blacklisted-list
* get-is-whitelisted-defi
* get-latest-reward-address
* get-participant-cycle-info

### State and Configuration

* get-last-operation-state
* get-admin
* get-is-contract-active
* get-current-bitcoin-block-height
* get-minimum-enrollment-amount
* get-next-action-bitcoin-height
* get-contract-sbtc-balance
* get-apr-data

### STX Stacking Queries

* get-amount-stx-stacked
* get-amount-stx-stacked-at-block-height
* get-amount-stacked-at-block-height
* get-amount-stacked-now


# FAQ

Clarifying some common questions and sharing external resources for Dual Stacking

#### General Dual Stacking Questions

<details>

<summary>Why can't other chains do this?</summary>

Other blockchains pay rewards in what they can mint (ETH, SOL, etc.). They have no mechanism to channel real Bitcoin.

Stacks has Proof of Transfer (PoX): Consensus mechanism that channels Bitcoin from miners to network participants. Operational since 2021. Over 4,000 BTC moved through PoX to date. This architectural difference makes Bitcoin earning Bitcoin rewards possible.

</details>

<details>

<summary>How is this different from wrapped BTC?</summary>

Rewards are paid in sBTC, redeemable for Bitcoin at any time and actual Bitcoin through PoX consensus, not platform tokens.

{% hint style="info" %}
**What is sBTC?**

sBTC is a [SIP-010](https://github.com/stacksgov/sips/blob/main/sips/sip-010/sip-010-fungible-token-standard.md) token on Stacks that can be converted back to BTC on Bitcoin. The key property of sBTC is its 1:1 peg to Bitcoin, meaning 1 sBTC is always equivalent to 1 BTC.
{% endhint %}

</details>

<details>

<summary>When is this live?</summary>

sBTC has been operational since December 2024. Dual Stacking launches November 2025.

{% hint style="info" %}
Coinciding with the Dual Stacking launch, the existing sBTC Rewards Program will sunset on October 31, 2024.
{% endhint %}

</details>

<details>

<summary>What will happen to the sBTC Rewards Program?</summary>

Coinciding with the Dual Stacking launch, the existing sBTC Rewards Program will sunset on October 31, 2024. But don’t worry, you can earn even more sBTC with Dual Stacking - a new way to stack both STX and sBTC to create stronger alignment between Bitcoin capital and the Stacks network.

**Key Dates to be aware of:**

Oct 30: Dual Stacking launches and you can enroll to start earning

Nov 4: sBTC Rewards Program ends and final rewards distributed

Nov 5: First Dual Stacking rewards cycle begins

Nov 20 (estimated): First Dual Stacking rewards cycle ends, rewards distributed\\

</details>

#### Dual Stacking Rewards

<details>

<summary>What are the minimum requirements?</summary>

The minimum to mint sBTC via the sBTC Bridge app is currently at 0.001 BTC (100,000 sats).

The minimum to enroll in Dual Stacking with your minted sBTC will be 0.0001 sBTC (10,000 sats).

Stacking STX is done normally through stacking pools, so no minimum. The Dual Stacking web app will auto-detect if a user is currently stacking STX.

</details>

<details>

<summary>Can I just stack BTC?</summary>

Yes, if you lock BTC only, you still earn base rewards. No STX required to participate.

</details>

<details>

<summary>Where does the yield come from?</summary>

Stacks is the only blockchain with Proof of Transfer—a consensus mechanism that channels BTC from miners to participants who secure the network by Stacking STX. At launch, Dual Stacking rewards will come from Stacks entities who volunteer their Stacking rewards (earned via Proof of Transfer) to Dual Stacking participants as sBTC.

</details>

<details>

<summary>How often are rewards paid out?</summary>

Rewards are paid out roughly every 2 weeks in line with PoX stacking cycles, with the first cycle beginning on November 5, 2025.

</details>

<details>

<summary>How are rewards calculated?</summary>

A Dual Stacking calculator is available in-app to help estimate your annual rewards based on the ratio of BTC/STX you are stacking. The system uses a square-root reward curve that creates diminishing returns, meaning your first STX paired with BTC has the biggest impact on your rewards, while additional STX continues to help at a decreasing rate. Review the [Dual Stacking Litepaper](https://github.com/stx-labs/papers/blob/main/Dual%20Stacking%20Litepaper.pdf) for more details.

</details>

<details>

<summary>How will this impact my existing Stacking rewards?</summary>

Dual Stacking does not modify PoX consensus, meaning there is no direct change to native Stacking rewards. No action is required to continue natively Stacking. Dual Stacking may indirectly impact stacking rewards by increasing more stacking participation overall.

</details>

#### Concerning Dual Stacking Security

<details>

<summary>What are the trust assumptions?</summary>

Dual Stacking operates as a transparent smart contract on the Stacks network. sBTC bridge operations are secured by a federation of [reputable signers](https://www.stacks.co/sbtc), with a 70% threshold of signer approval required for any transaction. No single entity can move funds unilaterally.

</details>

#### External Resources

* [\[Twitter\]](https://x.com/andrerserrano/status/1977845457226178757) Dual Stacking Litepaper Announcement from Andre Serrano
* [\[Github\]](https://github.com/stx-labs/papers/blob/main/Dual%20Stacking%20Litepaper.pdf) Official Dual Stacking Litepaper
* [\[Stacks Forum\]](https://forum.stacks.org/t/stacks-economic-model-unlocking-bitcoin-capital-long-term-growth/18035#dual-stacking-aligning-btc-and-stx-incentives-3) Initial Dual Stacking Announcement
* [\[Stacks Official\]](https://www.stacks.co/dual-stacking) Dual Stacking landing page on stacks.co
* \[[Stacks Blog](https://www.stacks.co/blog/dual-stacking-launches-on-stacks)] Official blog announcement
* \[[Stacks Twitter](https://x.com/Stacks/status/1983900168954286342)] Official twitter announcement
* \[[Dual Stacking App](https://app.stacks.co/)] Official Dual Stacking App

#### Related Technical Resources

* [\[Explorer\]](https://explorer.hiro.so/txid/SP1HFCRKEJ8BYW4D0E3FAWHFDX8A25PPAA83HWWZ9.dual-stacking-v1?chain=mainnet) `dual-stacking-v1` : Main Dual Stacking Contract


# Bridging

Exploring the plethora of ways to bridge assets to and from Stacks

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2Fq4r1out3TvVoPionEZz8%2Fbridging-cover.jpg?alt=media&#x26;token=d4b8b883-9338-48d1-ab2c-74c49c5cbd52" alt=""><figcaption><p>source: <a href="https://www.hiro.so/blog/understanding-blockchain-bridges-a-key-to-interoperability-in-web3">Hiro Blog</a></p></figcaption></figure></div>

A blockchain bridge is a protocol or mechanism that serves as a connection between different blockchains, allowing for the transfer of tokens and data between them. Bridges enable the seamless transfer of data and assets between disparate blockchain networks. They break down the silos of individual blockchains and unlock the full potential of a permissionless, borderless Web3.

#### Explore the different bridges available with Stacks

<table data-card-size="large" data-view="cards"><thead><tr><th></th><th></th><th data-hidden data-card-target data-type="content-ref"></th></tr></thead><tbody><tr><td><h4>USDCx</h4></td><td>Learn how USDC can flow to and from the bitcoin layer 2.</td><td><a href="bridging/usdcx">usdcx</a></td></tr></tbody></table>


# USDCx

USDCx is a 1:1 USDC-backed stablecoin issued through Circle xReserve and native to Stacks.

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2FthXTHTTqmeFnNdeaVEgg%2Fstacks-circle.png?alt=media&#x26;token=9089f7a1-3f5a-474d-88d3-9cb5790139fa" alt=""><figcaption></figcaption></figure></div>

{% hint style="info" %}
Developer support for integrating USDCx bridging into applications will be available via Circle’s Bridge Kit SDK in Q1 2026.
{% endhint %}

Stacks now has a fully USDC-backed stablecoin that plugs directly into Circle’s multichain ecosystem and brings stable, interoperable dollar liquidity to Bitcoin’s leading Layer 2.

### What is USDCx?

USDCx is a 1:1 USDC-backed stablecoin issued through Circle xReserve and native to Stacks. It will exist as a SIP-010 token on Stacks.&#x20;

Circle's xReserve provides cryptographic attestations for deposits and minting, while Circle Gateway and CCTP handle cross-chain movement. The result is USDC on Stacks without third-party bridges, wrapped assets, or fragmented liquidity.

{% hint style="info" %}
For more info on xReserve, check out the dedicated Circle docs [here](https://developers.circle.com/xreserve).
{% endhint %}

### Discover more of USDCx

<table data-view="cards"><thead><tr><th></th><th data-hidden data-card-target data-type="content-ref"></th></tr></thead><tbody><tr><td><h4>Operations</h4></td><td><a href="usdcx/operations">operations</a></td></tr><tr><td><h4>Contracts</h4></td><td><a href="usdcx/contracts">contracts</a></td></tr><tr><td><h4>Bridge App</h4></td><td><a href="usdcx/bridge-app">bridge-app</a></td></tr><tr><td><h4>FAQ</h4></td><td><a href="usdcx/faq">faq</a></td></tr></tbody></table>

***

### Security Audits

{% file src="<https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2FTJgP70R8gKX9FeqUMkVk%2FUSDCX%20_%20Final%20Audit.pdf?alt=media&token=9d9caa91-401b-4b93-a3cb-e9fc8ffa2515>" %}

***

### Additional Resources

* \[[Stacks Blog](https://www.stacks.co/blog/usdcx-launch-stacks-bitcoin-defi)] USDCx Launches on Stacks: Bitcoin Gets Its Top Tier Stablecoin
* \[[Circle Blog](https://www.circle.com/blog/usdcx-on-stacks-now-available-via-circle-xreserve)] USDCx on Stacks now available via Circle xReserve


# Operations

Let's walkthrough each of the operations that enable the bridging of USDC in and out of Stacks.

### Definitions

* **USDC**: Refers to native-chain USDC locked on the source chain that secures USDC-backed token at a 1-to-1 ratio.
* **xReserve smart contract**: Circle deploys and audits the xReserve contract on source blockchains such as Ethereum. It holds USDC deposited by users in reserve when a USDC-backed token is minted on Stacks
* **xReserve attestation service**: Operated by Circle. They monitor USDC deposits into the xReserve smart contract and sign deposit attestations. They also verify withdrawal attestations to release USDC.
* **Stacks attestation service**: Operated by Stacks. They monitor signed deposit attestations to trigger minting of USDCx on Stacks. In addition, they monitor burns of USDCx tokens to sign burn intents which are then forwarded to Circle's xReserve attestation service.
* **USDCx**: A SIP-010 token on Stacks fully backed by USDC.

### Deposits

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2F9p7WDRdrpyVeB4b4pBub%2Fusdc-deposit.png?alt=media&#x26;token=84d6a3d5-3bca-4638-a41f-7460a8905090" alt=""><figcaption></figcaption></figure></div>

For bridging source-chain USDC into the Stacks network.

1. A user deposits USDC from their wallet app into an xReserve smart contract, managed by Circle, on the source chain.
2. The xReserve contract emits a deposit event and locks the funds, holding them in reserve.
3. The xReserve attestation service, managed by Circle, generates and signs a deposit attestation.
4. The Stacks network's attestation service fetches the signed deposit attestation.
5. The Stacks network mints USDC-backed tokens, USDCx, and emits a mint event.
6. The Stacks' USDCx token contract deposits the newly minted USDC-backed tokens into the user’s Stacks wallet.

After completing the deposit process, the user receives an equivalent amount of USDC-backed tokens on Stacks.

### Withdrawals

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2FIinGDengKCB9IIwQggrM%2Fusdc-withdrawal.png?alt=media&#x26;token=51cbc8bc-c3fb-4dcb-9ab4-2b5c40463cb9" alt=""><figcaption></figcaption></figure></div>

For withdrawing USDC from the Stacks network.

1. A user requests to burn USDCx tokens on Stacks and to withdraw USDC on the destination network.
2. The Stacks USDCx token contract burns their USDCx tokens and emits a burn event.
3. The Stacks network's attestation service monitors the burn emitted burn event and then signs a generated burn intent message offchain.
4. The Stacks network's attestation service passes the burn intent message and signature to xReserve, managed by Circle.
5. xReserve verifies the burn and issues a withdrawal attestation.
6. xReserve releases USDC to the user’s wallet on the destination network.

After completing the withdrawal process, the user receives USDC on the destination network.


# Contracts

The USDCx smart contract is deployed on Stacks. It's role mirrors native USDC behavior and verifies Circle’s deposit attestations for minting and emits burn events for redemption.

Below are the integral contracts that make up the USDCx architecture.

### Stacks

<table><thead><tr><th width="125.3046875">Network</th><th>USDCx token contract</th><th>USDC xReserve protocol (entrypoint)</th></tr></thead><tbody><tr><td>Mainnet</td><td><a href="https://explorer.hiro.so/txid/0x07ea0a8d7262acd0cb094006969527351883281e08ebb6535843c5dbbde31ce9?chain=mainnet">SP120SBRBQJ00MCWS7TM5R8WJNTTKD5K0HFRC2CNE.usdcx</a></td><td><a href="https://explorer.hiro.so/txid/0xb5f29114ecdbaf199887433cdd4ca46d177d60875141e1dfb67304b53bf2df11?chain=mainnet">SP120SBRBQJ00MCWS7TM5R8WJNTTKD5K0HFRC2CNE.usdcx-v1</a></td></tr><tr><td>Testnet</td><td><a href="https://explorer.hiro.so/txid/ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.usdcx?chain=testnet">ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.usdcx</a></td><td><a href="https://explorer.hiro.so/txid/ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.usdcx-v1?chain=testnet">ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.usdcx-v1</a></td></tr></tbody></table>

### Ethereum

<table><thead><tr><th width="103.1875">Network</th><th>USDC token contract</th><th>xReserve contract</th></tr></thead><tbody><tr><td>Mainnet</td><td><a href="https://etherscan.io/token/0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48">0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48</a></td><td><a href="https://etherscan.io/address/0x8888888199b2Df864bf678259607d6D5EBb4e3Ce">0x8888888199b2Df864bf678259607d6D5EBb4e3Ce</a></td></tr><tr><td>Testnet</td><td><a href="https://sepolia.etherscan.io/token/0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238">0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238</a></td><td><a href="https://sepolia.etherscan.io/address/0x008888878f94C0d87defdf0B07f46B93C1934442">0x008888878f94C0d87defdf0B07f46B93C1934442</a></td></tr></tbody></table>


# usdcx-v1

{% code title=".usdcx-v1" lineNumbers="true" expandable="true" %}

```clarity
;; USDCx v1
;;
;; This contract implements the USDC xReserve protocol for bridging USDC between
;; Stacks and other chains.
;;
;; This contract is the main entry point for minting and burning USDCx.

;; An error occurred while recovering a deposit intent signature's
;; public key.
(define-constant ERR_UNABLE_TO_RECOVER_PK (err u100))
;; The length of the deposit intent is invalid.
(define-constant ERR_INVALID_DEPOSIT_BYTE_LENGTH (err u101))
;; The amount of the deposit intent is larger than u128::max.
(define-constant ERR_INVALID_DEPOSIT_AMOUNT_TOO_HIGH (err u102))
;; The max fee of the deposit intent is larger than u128::max.
(define-constant ERR_INVALID_DEPOSIT_MAX_FEE_TOO_HIGH (err u103))
;; The magic bytes of the deposit intent are invalid.
(define-constant ERR_INVALID_DEPOSIT_INTENT_MAGIC (err u104))
;; The hook data length of the deposit intent is invalid.
(define-constant ERR_INVALID_DEPOSIT_HOOK_DATA_LENGTH (err u105))
;; The signature of the deposit intent is invalid.
(define-constant ERR_INVALID_DEPOSIT_SIGNATURE (err u106))
;; The version of the deposit intent is invalid.
(define-constant ERR_INVALID_DEPOSIT_VERSION (err u107))
;; After accounting for fees, the amount of USDCx to mint is zero.
(define-constant ERR_INVALID_DEPOSIT_AMOUNT_ZERO (err u108))
;; The fee amount of the mint is larger than the max fee of the deposit intent.
(define-constant ERR_INVALID_DEPOSIT_FEE_AMOUNT_TOO_HIGH (err u109))
;; The remote domain of the deposit intent is invalid.
(define-constant ERR_INVALID_DEPOSIT_REMOTE_DOMAIN (err u110))
;; The remote token of the deposit intent is invalid.
(define-constant ERR_INVALID_DEPOSIT_REMOTE_TOKEN (err u111))
;; The remote recipient of the deposit intent is invalid.
(define-constant ERR_INVALID_DEPOSIT_REMOTE_RECIPIENT (err u112))
;; This nonce has already been used in a different deposit
(define-constant ERR_INVALID_DEPOSIT_NONCE (err u113))
;; The max fee is greater than or equal to the amount.
(define-constant ERR_INVALID_DEPOSIT_MAX_FEE_GTE_AMOUNT (err u114))
;; The remote recipient length of the deposit intent is invalid.
(define-constant ERR_INVALID_DEPOSIT_REMOTE_RECIPIENT_LENGTH (err u115))
;; The withdrawal amount is less than the minimum withdrawal amount.
(define-constant ERR_INVALID_WITHDRAWAL_AMOUNT_TOO_LOW (err u116))
;; The native domain is not the supported value (currently only 0)
(define-constant ERR_INVALID_NATIVE_DOMAIN (err u117))

;; Magic bytes for deposit encoding
(define-constant DEPOSIT_INTENT_MAGIC 0x5a2e0acd)

;; Supported version for parsing deposit intents
(define-constant DEPOSIT_INTENT_VERSION u1)

;; Supported native-domain for withdrawals
(define-constant ETHEREUM_NATIVE_DOMAIN u0)

;; Allowed `domain` for deposits
(define-constant DOMAIN u10003)

;; Map of used nonces
(define-map used-nonces
  (buff 32)
  bool
)

;; Map of Circle attestor public keys
(define-map circle-attestors
  (buff 33)
  bool
)

;; Minimum amount required to withdrawal USDCx
(define-data-var min-withdrawal-amount uint u0)

;; Helper function to parse a deposit intent from raw bytes.
;; This function takes care of parsing the deposit intent according to the Circle specification.
;; Stacks-specific logic (such as converting the remote recipient to a principal) is handled by other functions.
;;
;; For full validation, including parsing the remote recipient and preventing nonce reuse, use
;; `parse-and-validate-deposit-intent`.
(define-read-only (parse-deposit-intent (deposit-intent (buff 320)))
  (begin
    (asserts! (>= (len deposit-intent) u240) ERR_INVALID_DEPOSIT_BYTE_LENGTH)
    (let (
        (magic (unwrap-panic (as-max-len? (unwrap-panic (slice? deposit-intent u0 u4)) u4)))
        (version (buff-to-uint-be (unwrap-panic (as-max-len? (unwrap-panic (slice? deposit-intent u4 u8)) u4))))
        (amount-left-bytes (unwrap-panic (as-max-len? (unwrap-panic (slice? deposit-intent u8 u24)) u16)))
        (amount (buff-to-uint-be (unwrap-panic (as-max-len? (unwrap-panic (slice? deposit-intent u24 u40)) u16))))
        (remote-domain (buff-to-uint-be (unwrap-panic (as-max-len? (unwrap-panic (slice? deposit-intent u40 u44)) u4))))
        (remote-token (unwrap-panic (as-max-len? (unwrap-panic (slice? deposit-intent u44 u76)) u32)))
        (remote-recipient (unwrap-panic (as-max-len? (unwrap-panic (slice? deposit-intent u76 u108)) u32)))
        (local-token (unwrap-panic (as-max-len? (unwrap-panic (slice? deposit-intent u108 u140)) u32)))
        (local-depositor (unwrap-panic (as-max-len? (unwrap-panic (slice? deposit-intent u140 u172)) u32)))
        (max-fee-left-bytes (unwrap-panic (as-max-len? (unwrap-panic (slice? deposit-intent u172 u188)) u16)))
        (max-fee (buff-to-uint-be (unwrap-panic (as-max-len? (unwrap-panic (slice? deposit-intent u188 u204)) u16))))
        (nonce (unwrap-panic (as-max-len? (unwrap-panic (slice? deposit-intent u204 u236)) u32)))
        (hook-data-len (buff-to-uint-be (unwrap-panic (as-max-len? (unwrap-panic (slice? deposit-intent u236 u240)) u4))))
      )
      (asserts! (is-eq magic DEPOSIT_INTENT_MAGIC)
        ERR_INVALID_DEPOSIT_INTENT_MAGIC
      )
      (asserts! (is-eq amount-left-bytes 0x00000000000000000000000000000000)
        ERR_INVALID_DEPOSIT_AMOUNT_TOO_HIGH
      )
      (asserts! (is-eq max-fee-left-bytes 0x00000000000000000000000000000000)
        ERR_INVALID_DEPOSIT_MAX_FEE_TOO_HIGH
      )
      (asserts! (is-eq (len deposit-intent) (+ u240 hook-data-len))
        ERR_INVALID_DEPOSIT_HOOK_DATA_LENGTH
      )
      (ok {
        magic: magic,
        version: version,
        amount: amount,
        remote-domain: remote-domain,
        remote-token: remote-token,
        remote-recipient: remote-recipient,
        local-token: local-token,
        local-depositor: local-depositor,
        max-fee: max-fee,
        nonce: nonce,
        hook-data: (if (is-eq hook-data-len u0)
          0x
          (unwrap-panic (as-max-len?
            (unwrap-panic (slice? deposit-intent u240 (+ u240 hook-data-len)))
            u80
          ))
        ),
      })
    )
  )
)

;; Recover the attestor public key from a deposit intent and signature.
;; Recovery is done by hashing the deposit intent (via `keccak256`)
;; and then using the `secp256k1-recover?` function.
(define-read-only (recover-deposit-intent-pk
    (deposit-intent (buff 320))
    (signature (buff 65))
  )
  (let (
      (hash (keccak256 deposit-intent))
      (recovered-pk (unwrap! (secp256k1-recover? hash signature) ERR_UNABLE_TO_RECOVER_PK))
    )
    (ok recovered-pk)
  )
)

;; Add or remove a Circle attestor.
;;
;; Can only be called by a caller with the governance role.
(define-public (add-or-remove-circle-attestor
    (public-key (buff 33))
    (enabled bool)
  )
  (begin
    ;; #[filter(public-key, enabled)]
    (try! (contract-call? .usdcx validate-protocol-caller 0x00 contract-caller))
    (map-set circle-attestors public-key enabled)
    (ok true)
  )
)

;; Recover and verify a deposit intent signature.
;;
;; The public key is first recovered (via `recover-deposit-intent-pk`).
;; Then, the public key is checked against the `circle-attestors` map.
(define-read-only (verify-deposit-intent-signature
    (deposit-intent (buff 320))
    (signature (buff 65))
  )
  (begin
    ;; #[filter(deposit-intent, signature)]
    (let ((recovered-pk (try! (recover-deposit-intent-pk deposit-intent signature))))
      (asserts! (default-to false (map-get? circle-attestors recovered-pk))
        ERR_INVALID_DEPOSIT_SIGNATURE
      )
      (ok recovered-pk)
    )
  )
)

;; Convert 32 bytes to a standard principal. This is serialized as
;; 1 version byte, plus 20 hash bytes. This is then left-padded
;; with 11 bytes of 0x00.
;;
;; To support contracts as recipients, `hook-data` can contain a contract name.
;; To use this functionality, `hook-data` MUST be a consensus-serialized buffer
;; of the type { contract-name: (string-ascii 40) }.
;;
;; If `hook-data` is not able to be deserialized, this function falls back
;; to using a standard principal.
(define-read-only (get-remote-recipient
    (remote-recipient-bytes (buff 32))
    (hook-data (buff 80))
  )
  (let (
      (valid-len (asserts! (is-eq (len remote-recipient-bytes) u32)
        ERR_INVALID_DEPOSIT_REMOTE_RECIPIENT_LENGTH
      ))
      (version-byte (unwrap-panic (element-at? remote-recipient-bytes u11)))
      (hash-bytes (unwrap-panic (as-max-len? (unwrap-panic (slice? remote-recipient-bytes u12 u32)) u20)))
      ;; Avoid a VM runtime error when `hook-data` is empty:
      (hook-contract-name (if (is-eq (len hook-data) u0)
        none
        (from-consensus-buff? { contract-name: (string-ascii 40) } hook-data)
      ))
    )
    ;; Must have 0x00 as padding
    (asserts!
      (is-eq
        (unwrap-panic (as-max-len? (unwrap-panic (slice? remote-recipient-bytes u0 u11)) u11))
        0x0000000000000000000000
      )
      ERR_INVALID_DEPOSIT_REMOTE_RECIPIENT
    )
    (ok (unwrap!
      (match hook-contract-name
        contract-name-tup (principal-construct? version-byte hash-bytes
          (get contract-name contract-name-tup)
        )
        (principal-construct? version-byte hash-bytes)
      )
      ERR_INVALID_DEPOSIT_REMOTE_RECIPIENT
    ))
  )
)

;; 32-byte encoded version of the `.usdcx` contract address.
;; This must be used in deposit intents as the `remote-token` field.
(define-read-only (get-valid-remote-token)
  (concat 0x00000000
    (unwrap-panic (as-max-len? (unwrap-panic (to-consensus-buff? .usdcx)) u28))
  )
)

;; Helper function to parse and validate a deposit intent.
;;
;; In addition to basic parsing (done via `parse-deposit-intent`), this function
;; also validates certain Stacks-specific fields, such as the
;; remote token, remote domain, remote recipient, and version.
;;
;; Additionally, this function validates the `amount` and `max-fee` fields.
(define-read-only (parse-and-validate-deposit-intent (deposit-intent (buff 320)))
  (let (
      (parsed-intent (try! (parse-deposit-intent deposit-intent)))
      (remote-recipient (try! (get-remote-recipient (get remote-recipient parsed-intent)
        (get hook-data parsed-intent)
      )))
      (amount (get amount parsed-intent))
    )
    (asserts! (is-eq (get remote-token parsed-intent) (get-valid-remote-token))
      ERR_INVALID_DEPOSIT_REMOTE_TOKEN
    )
    (asserts! (> amount u0) ERR_INVALID_DEPOSIT_AMOUNT_ZERO)
    (asserts! (is-eq (get remote-domain parsed-intent) DOMAIN)
      ERR_INVALID_DEPOSIT_REMOTE_DOMAIN
    )
    (asserts! (is-eq (get version parsed-intent) DEPOSIT_INTENT_VERSION)
      ERR_INVALID_DEPOSIT_VERSION
    )
    (asserts! (>= amount (get max-fee parsed-intent))
      ERR_INVALID_DEPOSIT_MAX_FEE_GTE_AMOUNT
    )
    (asserts! (is-none (map-get? used-nonces (get nonce parsed-intent)))
      ;; This nonce has already been used in a different deposit
      ERR_INVALID_DEPOSIT_NONCE
    )
    (ok (merge parsed-intent { remote-recipient: remote-recipient }))
  )
)

;; Mint USDCx using a deposit intent.
;; This is the main entry point for minting USDCx.
;;
;; In addition to validation performed by `parse-and-validate-deposit-intent`, and
;; `verify-deposit-intent-signature`, this function also validates the `fee-amount`
;; provided by the caller to ensure that zero-amount mints are not possible.
;;
;; If `fee-amount` is non-zero (and less than the deposit's `max-fee`),
;; this function will mint `fee-amount` of USDCx to the caller. This allows
;; for accounts other than the deposit's recipient to cover the STX fee needed to mint.
(define-public (mint
    (deposit-intent (buff 320))
    (signature (buff 65))
    (fee-amount uint)
  )
  (let (
      (parsed-intent (try! (parse-and-validate-deposit-intent deposit-intent)))
      (recovered-pk (try! (verify-deposit-intent-signature deposit-intent signature)))
      (mint-amount (- (get amount parsed-intent) fee-amount))
    )
    (asserts! (>= (get max-fee parsed-intent) fee-amount)
      ERR_INVALID_DEPOSIT_FEE_AMOUNT_TOO_HIGH
    )
    ;; mint to the recipient
    (if (is-eq mint-amount u0)
      true
      (try! (contract-call? .usdcx protocol-mint mint-amount
        (get remote-recipient parsed-intent)
      ))
    )
    (if (is-eq fee-amount u0)
      true
      (try! (contract-call? .usdcx protocol-mint fee-amount tx-sender))
    )
    (map-set used-nonces (get nonce parsed-intent) true)
    (print {
      topic: "mint",
      parsed-intent: parsed-intent,
      attestor-pk: recovered-pk,
      mint-amount: mint-amount,
      fee-amount: fee-amount,
    })
    (ok true)
  )
)

;; Set the minimum withdrawal amount.
;;
;; Can only be called by a caller with the custom role `0x04` role.
(define-public (set-min-withdrawal-amount (new-min-withdrawal-amount uint))
  (begin
    (try! (contract-call? .usdcx validate-protocol-caller 0x04 contract-caller))
    (var-set min-withdrawal-amount new-min-withdrawal-amount)
    (ok true)
  )
)

(define-read-only (get-min-withdrawal-amount)
  (var-get min-withdrawal-amount)
)

;; Burn USDCx for the purpose of withdrawing USDCx from the protocol.
;;
;; This function burns USDCx from the caller's account and emits a `burn` event.
;;
;; The amount must be greater than or equal to the minimum withdrawal amount.
;;
;; `native-domain` must be a supported value (currently only `ETHEREUM_NATIVE_DOMAIN` (u0)).
(define-public (burn
    (amount uint)
    (native-domain uint)
    (native-recipient (buff 32))
  )
  (begin
    (asserts! (>= amount (var-get min-withdrawal-amount))
      ERR_INVALID_WITHDRAWAL_AMOUNT_TOO_LOW
    )
    (asserts! (is-eq native-domain ETHEREUM_NATIVE_DOMAIN)
      ERR_INVALID_NATIVE_DOMAIN
    )
    (try! (contract-call? .usdcx protocol-burn amount tx-sender))
    (print {
      topic: "burn",
      native-domain: native-domain,
      native-recipient: native-recipient,
      sender: tx-sender,
      amount: amount,
    })
    (ok true)
  )
)

```

{% endcode %}

## **USDCx-v1 Contract Summary**

The `usdcx-v1` contract implements the **USDC xReserve protocol** for moving USDC between Stacks and external chains. It serves as the **primary entry point for minting and burning USDCx** based on Circle-issued deposit intents.

This contract handles:

* Parsing and validating deposit intent payloads
* Recovering and verifying Circle attestor signatures
* Enforcing nonce-based replay protection
* Minting USDCx through the `usdcx` token contract
* Burning USDCx to initiate withdrawals
* Managing Circle attestor keys
* Handling Stacks-specific recipient conversions
* Applying fee logic for sponsored mints
* Managing minimum withdrawal thresholds

It works in tandem with the main `usdcx` token contract, which enforces protocol roles (`mint`, `governance`, etc.). All minting/burning occurs through `protocol-mint` and `protocol-burn`.

### Minting USDCx

The entry point for minting USDCx is via the `mint` function. The caller provides a serialized deposit intent, along with a signature, both of which are received off-chain as part of the bridging process. The deposit intent is parsed according to the xReserve specificiation.

There are a few Stacks-specific elements:

* The `remote-token` of the deposit intent MUST be the consensus-serialized bytes of the principal `.usdcx` (where the deployer address is network-dependent), with 0x left-padded.
* The `remote-domain` for Stacks is always `10003`.
* Because Stacks only supports `u128` integers, the deserialization functions throw an error if any 64-byte integers in the deposit intent are larger than `u128::max`. This is allowed according to the xReserve spec.

### **Verifying attestations**

The `.usdcx-v1` contract keeps a `circle-attestors` map to keep track of public keys of valid attestors. When a deposit intent is provided, it must be signed by a public key in this map.&#x20;

### Burning USDCx

To withdrawal USDCx to another chain, users call `burn`. The specified amount of USDCx is burned from their Stacks account. A `print` event is emitted, which is used for triggering a burn attestation off-chain.

The `.usdcx-v1` contract stores a minimum amount variable. Users must withdrawal at least this amount, or the burn fails. Accounts with the role `0x04` can update this variable.


# usdcx-token

{% code title=".usdcx" lineNumbers="true" expandable="true" %}

```clarity
;; USDCx token
;;
;; This contract implements the SIP-010 trait for fungible contracts.
;;
;; This contract utilizes a role-based access control system to manage protocol permissions.
;; There are three roles:
;;
;; - `governance`: Allowed to update the protocol contracts and add/remove roles
;; - `mint`: Allowed to mint and burn tokens
;; - `pause`: Allowed to pause and unpause the protocol
;;

(impl-trait 'SP3FBR2AGK5H9QBDH3EEN6DF8EK8JY7RX8QJ5SVTE.sip-010-trait-ft-standard.sip-010-trait)

;; `tx-sender` or `contract-caller` tried to move a token it does not own.
(define-constant ERR_NOT_OWNER (err u4))
;; `contract-caller` tried to use a function it is not authorized to use.
(define-constant ERR_UNAUTHORIZED (err u400))
;; Protocol is paused.
(define-constant ERR_PAUSED (err u401))

(define-fungible-token usdcx-token)

(define-data-var token-name (string-ascii 32) "USDCx")
(define-data-var token-symbol (string-ascii 10) "USDCx")
;; The SIP-16 URI for token metadata
(define-data-var token-uri (optional (string-utf8 256)) (some u"https://ipfs.io/ipfs/bafkreifkhq47bgrlq2z2qgtps65eawgp6xsqkwldz57y2bjpefgo5zvza4"))
(define-constant token-decimals u6)

;; Allowed to update the protocol contracts
(define-constant governance-role 0x00)
;; Allowed to mint and burn tokens
(define-constant mint-role 0x01)
;; Allowed to pause and unpause the protocol
(define-constant pause-role 0x02)

;; Allow protocol to be paused
(define-data-var paused bool false)

;; Mapping of active protocol contracts (by role)
(define-map active-protocol-contracts
  {
    caller: principal,
    role: (buff 1),
  }
  bool
)

;; The contract .usdcx-v1 automatically has the `mint` role
(map-set active-protocol-contracts {
  caller: .usdcx-v1,
  role: mint-role,
}
  true
)
;; Default the contract deployer as having the `governance` role
(map-set active-protocol-contracts {
  caller: tx-sender,
  role: governance-role,
}
  true
)

;; SIP-010 functions

(define-public (transfer
    (amount uint)
    (sender principal)
    (recipient principal)
    (memo (optional (buff 34)))
  )
  (begin
    (asserts! (or (is-eq tx-sender sender) (is-eq contract-caller sender))
      ERR_NOT_OWNER
    )
    (try! (ft-transfer? usdcx-token amount sender recipient))
    (match memo
      to-print (print to-print)
      0x
    )
    (ok true)
  )
)

(define-read-only (get-name)
  (ok (var-get token-name))
)

(define-read-only (get-symbol)
  (ok (var-get token-symbol))
)

(define-read-only (get-decimals)
  (ok token-decimals)
)

(define-read-only (get-balance (who principal))
  (ok (ft-get-balance usdcx-token who))
)

(define-read-only (get-balance-available (who principal))
  (ok (ft-get-balance usdcx-token who))
)

(define-read-only (get-balance-locked (who principal))
  (ok (ft-get-balance usdcx-token who))
)

(define-read-only (get-total-supply)
  (ok (ft-get-supply usdcx-token))
)

(define-read-only (get-token-uri)
  (ok (var-get token-uri))
)

;; Protocol caller validation

;; Checks whether the contract-caller is a protocol contract
(define-read-only (is-protocol-caller
    (contract-flag (buff 1))
    (contract principal)
  )
  (validate-protocol-caller contract-flag contract)
)

;; Validate that a given principal is a protocol contract
(define-read-only (validate-protocol-caller
    (contract-flag (buff 1))
    (contract principal)
  )
  (begin
    ;; Check that the caller has the required role
    (asserts!
      (default-to false
        (map-get? active-protocol-contracts {
          caller: contract,
          role: contract-flag,
        })
      )
      ERR_UNAUTHORIZED
    )
    (ok true)
  )
)

;; Protocol pausing

(define-read-only (is-protocol-paused)
  (var-get paused)
)

;; Validate that protocol is not paused
(define-read-only (validate-protocol-active)
  (ok (asserts! (not (is-protocol-paused)) ERR_PAUSED))
)

;; --- Protocol functions

;; Transfer tokens from one account to another.
;; Only the `mint` role is allowed to call this function.
(define-public (protocol-transfer
    (amount uint)
    (sender principal)
    (recipient principal)
  )
  (begin
    ;; #[filter(amount, sender, recipient)]
    (try! (validate-protocol-active))
    (try! (validate-protocol-caller mint-role contract-caller))
    (ft-transfer? usdcx-token amount sender recipient)
  )
)

;; Mint tokens to an account.
;; Only the `mint` role is allowed to call this function.
(define-public (protocol-mint
    (amount uint)
    (recipient principal)
  )
  (begin
    ;; #[filter(amount, recipient)]
    (try! (validate-protocol-active))
    (try! (validate-protocol-caller mint-role contract-caller))
    (ft-mint? usdcx-token amount recipient)
  )
)

;; Burn tokens from an account.
;; Only the `mint` role is allowed to call this function.
(define-public (protocol-burn
    (amount uint)
    (owner principal)
  )
  (begin
    ;; #[filter(amount, owner)]
    (try! (validate-protocol-active))
    (try! (validate-protocol-caller mint-role contract-caller))
    (ft-burn? usdcx-token amount owner)
  )
)

;; Set the name of the token.
;; Only the `governance` role is allowed to call this function.
(define-public (protocol-set-name (new-name (string-ascii 32)))
  (begin
    ;; #[filter(new-name)]
    (try! (validate-protocol-active))
    (try! (validate-protocol-caller governance-role contract-caller))
    (ok (var-set token-name new-name))
  )
)

;; Set the symbol of the token.
;; Only the `governance` role is allowed to call this function.
(define-public (protocol-set-symbol (new-symbol (string-ascii 10)))
  (begin
    ;; #[filter(new-symbol)]
    (try! (validate-protocol-active))
    (try! (validate-protocol-caller governance-role contract-caller))
    (ok (var-set token-symbol new-symbol))
  )
)

;; Set the SIP-16 URI for token metadata.
;; Only the `governance` role is allowed to call this function.
(define-public (protocol-set-token-uri (new-uri (optional (string-utf8 256))))
  (begin
    ;; #[filter(new-uri)]
    (try! (validate-protocol-active))
    (try! (validate-protocol-caller governance-role contract-caller))
    (ok (var-set token-uri new-uri))
  )
)

;; Helper function to mint tokens to multiple recipients.
;; Only the `mint` role is allowed to call this function.
(define-private (protocol-mint-many-iter (item {
  amount: uint,
  recipient: principal,
}))
  ;; #[allow(unchecked_data)]
  (ft-mint? usdcx-token (get amount item) (get recipient item))
)

;; Mint tokens to multiple recipients.
;; Only the `mint` role is allowed to call this function.
(define-public (protocol-mint-many (recipients (list 200 {
  amount: uint,
  recipient: principal,
})))
  (begin
    ;; #[filter(recipients)]
    (try! (validate-protocol-active))
    (try! (validate-protocol-caller mint-role contract-caller))
    (ok (map protocol-mint-many-iter recipients))
  )
)

;; Set an active protocol caller.
;; Only the `governance` role is allowed to call this function.
(define-public (set-active-protocol-caller
    (caller principal)
    (role (buff 1))
    (enabled bool)
  )
  (begin
    ;; #[filter(caller, role, enabled)]
    (try! (validate-protocol-active))
    (try! (validate-protocol-caller governance-role contract-caller))
    (map-set active-protocol-contracts {
      caller: caller,
      role: role,
    }
      enabled
    )
    (ok true)
  )
)

;; Pause the protocol.
;; Only the `pause` role is allowed to call this function.
(define-public (pause)
  (begin
    (try! (validate-protocol-caller pause-role contract-caller))
    (print {
      topic: "pause",
      paused: true,
      caller: contract-caller,
    })
    (ok (var-set paused true))
  )
)

;; Unpause the protocol.
;; Only the `pause` role is allowed to call this function.
(define-public (unpause)
  (begin
    (try! (validate-protocol-caller pause-role contract-caller))
    (print {
      topic: "pause",
      paused: false,
      caller: contract-caller,
    })
    (ok (var-set paused false))
  )
)

```

{% endcode %}

## **USDCx-Token Contract Summary**

This contract implements **USDCx**, a SIP-010 fungible token on Stacks with a **role-based access control system** and **pause functionality** for protocol safety. It exposes the standard SIP-010 interface for transfers, supply queries, and metadata, while providing protocol-only functions for minting, burning, governance updates, and pausing.

#### **Roles**

The contract defines three privileged roles:

* **Governance (`governance-role`)** – manages protocol configuration, updates token metadata, and assigns roles.
* **Mint (`mint-role`)** – authorized to mint, burn, and perform protocol-level transfers.
* **Pause (`pause-role`)** – authorized to pause and unpause the protocol.

A protocol pause halts state-changing operations for safety. The contract deployer automatically receives the **governance** role. The companion contract `.usdcx-v1` automatically receives the **mint** role.

***

### Function-by-Function Breakdown

### **SIP-010 Standard Functions**

#### **`transfer(amount, sender, recipient, memo)`**

Transfers USDCx between principals, following SIP-010 rules. The function checks that the sender is either `tx-sender` or `contract-caller` (for contracts managing escrow or vaults) and then performs the transfer. An optional memo is logged on-chain.

#### **`get-name()`**, **`get-symbol()`**, **`get-decimals()`**

Standard SIP-010 metadata getters returning token name, symbol, and decimal precision.

#### **`get-balance(who)`**, **`get-balance-available(who)`**, **`get-balance-locked(who)`**

Returns the token balance for the given principal. In this implementation, all three accessor functions return the same SIP-010 balance value.

#### **`get-total-supply()`**

Returns the total USDCx supply minted minus burned.

#### **`get-token-uri()`**

Returns the token metadata URI.

***

### **Protocol Caller Validation**

These functions enforce the contract’s role-based permissions.

#### **`is-protocol-caller(role, contract)`**

Checks whether the specified contract principal holds the required role.

#### **`validate-protocol-caller(role, contract)`**

Ensures the caller has the correct role. If not, returns `ERR_UNAUTHORIZED`.

#### **`is-protocol-paused()`**

Returns whether the protocol is currently paused.

#### **`validate-protocol-active()`**

Asserts that the protocol is not paused, otherwise returns `ERR_PAUSED`.

***

### **Protocol-Only Token Operations**

These functions enable minting/burning/transfers strictly for authorized protocol contracts.

#### **`protocol-transfer(amount, sender, recipient)`**

Performs a protocol-level transfer on behalf of another contract. Only callers with the **mint role** can use it. Fails if the protocol is paused.

#### **`protocol-mint(amount, recipient)`**

Mints new USDCx to a principal. Restricted to the **mint role** and disabled when paused.

#### **`protocol-burn(amount, owner)`**

Burns tokens from a principal’s balance. Also restricted to the **mint role** and disabled when paused.

#### **`protocol-mint-many(recipients)`**

Batch-mints tokens to multiple recipients in a single call. Each item includes `{ amount, recipient }`. Only callable by entities with the **mint role**.

***

### **Governance Functions**

Only the **governance role** may call these functions.

#### **`protocol-set-name(new-name)`**

Updates the token’s SIP-010 name.

#### **`protocol-set-symbol(new-symbol)`**

Updates the token’s SIP-010 ticker symbol.

#### **`protocol-set-token-uri(new-uri)`**

Updates the SIP-016 metadata URI.

#### **`set-active-protocol-caller(caller, role, enabled)`**

Adds or removes a principal from a specific protocol role.\
Used for rotating systems, updating companion contracts, or delegating new responsibility.

***

### **Pause Controls**

These functions allow the protocol to halt operations for safety or maintenance.

#### **`pause()`**

Pauses the contract, disabling minting, burning, and all protocol-only actions. Only callable by the **pause role**.

#### **`unpause()`**

Re-enables the protocol after a pause. Also restricted to the **pause role**.

Both functions emit an on-chain event for transparency.


# USDCx Bridge App

<div data-with-frame="true"><figure><img src="https://2842511454-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2FH74xqoobupBWwBsVMJhK%2Fuploads%2FSuduZsE83ADzAHbctKvG%2Fusdcx-bridge-app.png?alt=media&#x26;token=59426f21-6227-454a-b1ff-44ef4fb15e22" alt=""><figcaption><p><a href="http://bridge.stacks.co/">https://bridge.stacks.co</a></p></figcaption></figure></div>

The USDCx Bridge app is maintained by Stacks Labs and is powered by Circle xReserve.

Acquire USDCx through the [official bridge app](https://bridge.stacks.co/) or migrate your aeUSDC into USDCx to take advantage of better liquidity and improved trust assumptions.&#x20;

At launch, the USDCx bridge on Stacks supports transfers between Ethereum and Stacks. The first aeUSDC–USDCx liquidity pool will be available on Bitflow in early January.

Support for additional Circle / CCTP-compatible networks is on the roadmap and will roll out in Q1 2026, enabling broader interoperability across Circle’s multichain USDC ecosystem.


# Migrating aeUSDC

Migrate your aeUSDC tokens to USDCx.

### What is aeUSDC?

aeUSDC on Stacks is a bridged form of USDC managed by Allbridge. Now that USDCx is live on Stacks, aeUSDC holders should upgrade to USDCx for better liquidity, better UX and improved trust assumptions.

aeUSDC was first released in 2023. It will be gradually depreciated in favor of USDCx.

{% hint style="warning" %}
Minting aeUSDC is disabled. Users will not be able to mint new aeUSDC. Only transfers from Stacks to Ethereum enabled.
{% endhint %}

### Why should you migrate your aeUSDC to USDCx?

* **Better liquidity** → USDCx gives you deeper liquidity and smoother swaps, powered by a more connected market.
* **Better UX** → Enjoy a cleaner, faster experience with tools and apps built for real usability, not workarounds.
* **Trust & reputation via attestations** → Onchain attestations backed by trusted issuers, Circle, strengthen transparency, credibility, and confidence.

***

### How to migrate aeUSDC to USDCx

There are two primary ways to migrate aeUSDC tokens to USDCx. We’ll explain both of them here.&#x20;

<details>

<summary>Swap via Bitflow's Conversion Pool</summary>

{% hint style="warning" %}
Please note, the first aeUSDC:USDCx pool will be available in early January via Bitflow. This pool is not yet live.
{% endhint %}

aeUSDC holders can use the aeUSDC/USDC pool on Bitflow. This is the fastest and cheapest way to migrate to USDCx.

* Navigate to Swaps in the [Bitflow app](https://app.bitflow.finance/trade).&#x20;
* Connect your wallet.
* Select aeUSDC as the “From” token.
* Set the amount you want to migrate. You may decide to migrate your full aeUSDC balance at once, or test a small amount first before migrating the full balance.&#x20;
* Select USDCx as the “To” token.
* Click “Swap” button to initiate the swap. You’ll need to sign the transaction requests from your wallet in order to complete the transaction.

</details>

<details>

<summary><strong>Bridge via Allbridge Classic</strong></summary>

Users can bridge aeUSDC back to Ethereum and then bridge back to mint USDCx on Stacks.

* Navigate to the [Allbridge](https://app.allbridge.io/bridge?from=STX\&to=ETH\&asset=aeUSDC) app.
* Choose “Stacks” in the dropdown menu in the “From” field
* Choose “Ethereum” in the dropdown menu in the “To” field
* Choose “aeUSDC” as the asset.
* Connect your wallet.
* Set the amount you want to migrate. You may decide to migrate your full aeUSDC balance at once, or test a small amount first before migrating the full balance.&#x20;
* Note that it may take 60 minutes (six confirmation blocks) to complete the transaction.
* Once you have migrated aeUSDC back to USDC on Ethereum, you can use the USDCx Stacks bridge to deposit USDC on Stacks. <http://bridge.stacks.co/>

</details>


# FAQ

<details>

<summary>What's the purpose of having stablecoins on Stacks?</summary>

Stablecoins make capital move. They enable institutions to lend and borrow, and they give users access to liquidity without leaving the Bitcoin economy.

</details>

<details>

<summary>Why is it USDCx and not native USDC on Stacks?</summary>

USDCx is a 1:1 USDC-backed stablecoin issued through Circle xReserve and native to Stacks. xReserve provides cryptographic attestations for deposits and minting, while Circle Gateway and CCTP handle cross-chain movement. The result is USDC on Stacks without third-party bridges, wrapped assets, or fragmented liquidity.

With this setup, Stacks now has a fully USDC-backed stablecoin that plugs directly into Circle’s multichain ecosystem and brings stable, interoperable dollar liquidity to Bitcoin’s leading Layer 2. USDCx will always be fully backed by USDC on the source chain.<br>

</details>

<details>

<summary>Which networks are supported for USDCx interoperabiity?</summary>

Currently, interoperability is between Ethereum and Stacks. Other Circle/CCTP-compatible networks will be added in the future.

</details>

<details>

<summary>How is USDCx different from aeUSDC?</summary>

aeUSDC on Stacks is a bridged form of USDC managed by Allbridge. Now that USDCx is live on Stacks, aeUSDC holders should upgrade to USDCx for better liquidity, better UX and improved trust assumptions. aeUSDC was first released in 2023. It will be gradually depreciated in favor of USDCx.

</details>

<details>

<summary>How does USDCx differ from the other stablecoins already on Stacks?</summary>

USDCx is a fully USDC-backed, cryptographically attested dollar asset that moves across chains through Circle’s native infrastructure. It works everywhere USDC works, from Ethereum to Solana and beyond, all while settling on Bitcoin through Stacks.

With USDCx, developers get a reliable dollar rail to build with, users get predictable liquidity, and protocols get a trusted base asset for markets and collateral. It provides the missing piece for deeper liquidity, healthier markets, and real Bitcoin-denominated yield.

* Deeper liquidity pools on Stacks DeFi protocols
* Simplified user experience with Circle-managed reserves
* Institutional confidence and proven infrastructure
* Bitcoin capital flowing freely to where it's most productive

</details>

<details>

<summary>What will happen to aeUSDC?</summary>

aeUSDC will be gradually depreciated in favor of USDCx. Now that USDCx is live on Stacks, aeUSDC holders should upgrade to USDCx for better liquidity, better UX and improved trust assumptions.

</details>